{"posts":[{"title":"2024 ICPC 网络赛 第二场","text":"The 2024 ICPC Asia EC Regionals Online Contest (II) 双打 7 题，成功翻盘出线！！！ 赛时榜单 Problems AC A. Gambling on Choosing Regionals ○ B. Mountain Booking C. Prefix of Suffixes D. Query on Tree E. Escape ○ F. Tourist ○ G. Game ○ H. Points Selection I. Strange Binary ○ J. Stacking of Goods ○ K. Match L. 502 Bad Gateway ○ F 签到123456789101112131415void solve() { int n = read(); int now = 1500; for (int i = 1; i &lt;= n; i++) { now += read(); if (now &gt;= 4000) { cout &lt;&lt; i; return; } } puts(&quot;-1&quot;);} J 排序微扰法进行排序 1234567891011121314151617181920212223242526272829303132struct Node { int w, v, c; bool friend operator &lt; (Node a, Node b) { return a.w * b.c &lt; b.w * a.c; }};void solve() { int n = read(); vector&lt;Node&gt; a(n); for (int i = 0; i &lt; n; i++) { a[i].w = read(); a[i].v = read(); a[i].c = read(); } std::sort(a.begin(), a.end()); i64 ans = 0; i64 sum = 0; for (int i = 0; i &lt; n; i++) sum += a[i].w, ans += a[i].v; i64 tot = 0; for (int i = 0; i &lt; n; i++) { ans -= a[i].c * sum; tot += a[i].w; ans += a[i].c * tot; } cout &lt;&lt; ans &lt;&lt; '\\n';} I 二进制L 期望AG gcdE 分层图，奇偶 bfsC border解法一每次新加入一个字符 $c_i$ 时，考虑答案的增量。 如果加入这个字符后，$z_j$ 变大了 $1$，那么答案就会增加 $B_j \\times A_i$。 反之如果 $z_j$ 没有变大，那么以后就再也不会变大了，对应的 $B_j$ 以后也不会再有贡献了。 用 vector 动态地存那些没有被确定 $z$ 的位置。谔谔这个复杂度真的对吗，不会算，但是自己试随机数据好像均摊下来并没有多少。 123456789101112131415161718192021222324252627282930313233void solve() { int n = read(); vector&lt;int&gt; rems; i64 ans = 0, sumb = 0; vector&lt;int&gt; a(n), b(n), c(n); for (int i = 0; i &lt; n; i++) { c[i] = read(), a[i] = read(), b[i] = read(); c[i] = (c[i] + ans) % n; if (c[i] == c[0]) { sumb += b[i]; rems.eb(i); } vector&lt;int&gt; nrems; for (int j : rems) { if (c[i] == c[i - j]) { nrems.eb(j); } else { sumb -= b[j]; } } rems = std::move(nrems); ans += a[i] * sumb; cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; }}","link":"/2024-icpc-%E7%BD%91%E7%BB%9C%E8%B5%9B-%E7%AC%AC%E4%BA%8C%E5%9C%BA/"},{"title":"UIC-ACM CCPC2024 校内选拔赛","text":"楼神出的题，好有水平 Problems AC A. 移动路线 ○ B. 圆形切割 ○ C. 连加连乘 ○ D. 牛车采矿 ○ E. 海明码 ○ F. 最短路问题 ○ G. 序列分段 待补 H. 分身游走 待补 前六道题都很简单，就不写了。 主要是后两题","link":"/uic-acm-ccpc2024-%E6%A0%A1%E5%86%85%E9%80%89%E6%8B%94%E8%B5%9B/"},{"title":"VP 2024 ICPC 杭州","text":"比赛链接 Problems AC Note A. ○ B. ⊕ C. ○ D. ○ E. ○ F. ACode >folded1 BCode >folded1 CCode >folded1 DCode >folded1 ECode >folded1","link":"/vp-2024-icpc-%E6%9D%AD%E5%B7%9E/"},{"title":"VP 2024 女生赛","text":"2024 China Collegiate Programming Contest (CCPC) Female Onsite (2024年中国大学生程序设计竞赛女生专场) Problems AC Note A. Box ○ 签到 B. Aho-Corasick Automaton C. CCPC ○ 签到 D. Excellent Splitting E. Centroid Tree ○ 并查集 F. Perfect Square ⊕ 数学、背包 G. Increasing Sequence ○ 拆数位 H. Square Root ○ 签到 I. String Duplication ⊕ SAM J. Sum of Squares of GCDs K. Xiao Kai’s Dream of Provincial Scholarship 模拟 L. Puzzle ○ 思维 M. Covering a Tree ○ 贪心 A. BoxCode >folded12345678910111213141516171819202122232425262728293031void solve() { int z0 = read(); int h = read(); int u0 = read(); int v0 = read(); int u1 = read(); int v1 = read(); // u0 v0 z0 // u1 v1 z0 // u0 v1 z0 // u1 v0 z0 if (u0 &gt; u1) { swap(u0, u1); } if (v0 &gt; v1) { swap(v0, v1); } for (int q = read(); q--; ) { int x = read(); int y = read(); int z = read(); if (x &lt; u0 or x &gt; u1 or y &lt; v0 or y &gt; v1 or z &gt; z0 + h or z &lt; z0) { puts(&quot;NO&quot;); } else { puts(&quot;YES&quot;); } } } C. CCPCCode >folded123456789101112131415void solve() { string s; cin &gt;&gt; s; int a = 0, b = 0; for (auto ch : s) { if (ch == 'C') a++; if (ch == 'P') b++; } if (a &lt; 3 or b &lt; 1) { puts(&quot;0&quot;); return; } cout &lt;&lt; min((a - 1) / 2, b) &lt;&lt; '\\n';} E. Centroid TreeCode >folded123456789101112131415161718192021222324252627void solve() { int n = read(); DSU dsu(n + 1); vector&lt;int&gt; c(n + 1); vector&lt;vector&lt;int&gt;&gt; e(n + 1); for (int i = 1; i &lt;= n; i++) { c[i] = read(); for (int j = 1; j &lt;= c[i]; j++) { int x = read(); e[i].eb(x); } } vector&lt;int&gt; par(n + 1); for (int i = n; i &gt;= 1; i--) { for (auto x : e[i]) { int now = dsu.find(x); par[now] = i; dsu.merge(i, now); } } for (int i = 2; i &lt;= n; i++) { cout &lt;&lt; par[i] &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; '\\n'; }} F. Perfect Square 给出一个长度为 $n$ 的正整数序列 $a$，求所有序列 $d$ 满足 $d_i|a_i$ 且 $d_i$ 的乘积为完全平方数的乘积开方之和。 $1 \\le n \\le 10^6, 1 \\le a_i \\le 10^6$ 每个质因子的贡献是独立的。 相当于 $n$ 个物品，每个物品可以拿最多 $c_i$ 个，问总共取偶数个的方案里，$p ^ \\frac{取的数量}{2}$ 的和。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051void solve() { int n = read(); vector&lt;vector&lt;int&gt;&gt; g(1e6); for (int i = 1; i &lt;= n; i++) { for (int x = read(); x != 1; ) { int p = minp[x]; int c = 0; while (x % p == 0) { x /= p; c++; } g[p].eb(c); } } auto go = [&amp;](vector&lt;int&gt; c, int p) -&gt; Z { int m = c.size(); if (m == 0) return Z(1); int sum = std::accumulate(c.begin(), c.end(), 0); vector&lt;int&gt; pow(sum + 1); pow[0] = 1; for (int i = 1; i &lt;= sum; i++) { pow[i] = pow[i - 1] * p; } vector&lt;Z&gt; dp(2); dp[0] = 1; for (int i = 0; i &lt; m; i++) { vector&lt;Z&gt; ndp(2); for (int j = 0; j &lt;= 1; j++) { for (int k = 0; k &lt;= c[i]; k++) { int nj = (j + k) % 2; ndp[nj] += dp[j] * pow[(j + k) / 2]; } } dp = std::move(ndp); } return dp[0]; }; Z ans = 1; for (auto p : primes) { ans *= go(g[p], p); } cout &lt;&lt; ans &lt;&lt; '\\n';} G. Increasing Sequence 给定长度为 $n$ 的数列 $a$ 和整数 $k$，询问有多少整数满足 $x \\in [0, k]$，且有 $a_1 \\oplus x, a_2 \\oplus x, \\cdots , a_n \\oplus x$ 是单调不降序列。 $1 \\le n \\le 2 \\cdot 10^5, 1 \\le k \\le 10^{18}$ 对于相邻两项 $a_i \\oplus x \\le a_{i + 1} \\oplus x$，从高到低找到 $a_i$ 和 $a_{i + 1}$ 第一个不同的位。在这一位上，如果 $a_{i}$ 为 $0$，$a_{i + 1}$ 为 $1$，则 $x$ 必须为 $0$；反之 $x$ 必须为 $1$。 那么现在有一些限制，问你有多少个 $x \\in [0, k]$，就是数位 DP 的板子。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071void solve() { int n = read(); int k = read(); vector&lt;int&gt; a(n + 1); vector&lt;int&gt; b(65, -1); // vector&lt;int&gt; c(65, -1); for (int i = 1; i &lt;= n; i++) { a[i] = read(); } for (int i = 1; i &lt; n; i++) { for (int j = 60; j &gt;= 0; j--) { int x = a[i] &gt;&gt; j &amp; 1; int y = a[i + 1] &gt;&gt; j &amp; 1; if (x != y) { int now = x; if (b[j] != -1 and b[j] != x) { puts(&quot;0&quot;); return; } b[j] = x; break; } } } // for (int i = 0; i &lt; 60; i++) { // b[i] = b[i] == -1 ? 2 : 1; // cerr &lt;&lt; b[i] &lt;&lt; &quot; &quot;; // } // int ans = 1; // for (int i = 60; i &gt;= 0; i--) { // int x = k &gt;&gt; i &amp; 1; // if (x) { // cout &lt;&lt; &quot;i: &quot; &lt;&lt; i &lt;&lt; '\\n'; // int res = 1; // // i - b[i] // if (i - 1 &gt;= 0) // res *= 1LL &lt;&lt; (i - b[i - 1]); // // cout &lt;&lt; &quot;res: &quot; &lt;&lt; res &lt;&lt; '\\n'; // ans += res; // } // } vector dp(65, vector&lt;int&gt;(2, -1)); auto dfs = [&amp;](auto&amp;&amp; self, int now, bool f) -&gt; int { if (now == -1) return 1; if (~dp[now][f]) return dp[now][f]; int res = 0; int lim = f ? (k &gt;&gt; now &amp; 1) : 1; for (int j = 0; j &lt;= lim; j++) { if (b[now] == -1 or b[now] == j) { res += self(self, now - 1, f &amp;&amp; (j == lim)); } } dp[now][f] = res; return res; }; int ans = dfs(dfs, 60, 1); cout &lt;&lt; ans &lt;&lt; '\\n';} H. Square RootCode >folded123456789101112131415161718192021222324void solve() { string s; cin &gt;&gt; s; int n = s.size(); for (int i = 0; i + 1 &lt; n; i++) { if (i - 1 &lt; 0 or i + 1 &gt;= n) continue; if (s[i - 1] == '1' and s[i] == '1' and s[i + 1] == '1') s[i] = '0'; } double ans = 0; s += '0'; int cnt = 0; for (int i = 0; i &lt;= n; i++) { if (s[i] == '0') { ans += pow(cnt, 0.5); // cout &lt;&lt; cnt &lt;&lt; '\\n'; cnt = 0; } else { cnt++; } } printf(&quot;%.10f&quot;, ans);} I. String Duplication 给定一个字符串 $S$，求 $S$ 复制 $m$ 次拼接起来的的字符串的本质不同子串个数。 $1 \\le |S| \\le 3 \\times 10^5, 1 \\le m \\le 10^9$ 打表可以直接发现规律，以下是参考官方题解的证明： 令函数 $f(S, m)$ 表示 $S$ 复制 $m$ 次的本质不同子串个数。 当 $m \\ge 3$ 时，如果一个串是 $SSS$ 的子串，而且不是 $SS$ 的子串，那么可以被写成 $x[S]y$ 的形式（$x$ 为 $S$ 的非空后缀，$y$ 为 $S$ 的非空前缀$。 同理一个串是 $SSSS$ 的子串，而且不是 $SSS$ 的子串，那么可以被写成 $x[SS]y$ 的形式 显然 $x[S]y$ 的数量等于 $x[SS]y$ 的数量。并且这个数量等于 $f(S, 3) - f(S, 2)$。 等差数列求和就做完了。求本质不同子串直接 sam 即可。 Code1234567891011121314151617181920212223242526void solve() { int n = read(); int m = read(); SAM sam; string s; cin &gt;&gt; s; vector&lt;Z&gt; ans(3); int p = 1; for (int k = 0; k &lt; 3; k++) { for (auto c : s) { p = sam.extend(p, c - 'a'); } for (int i = 2; i &lt; sam.size(); i++) { ans[k] += sam.len(i) - sam.len(sam.link(i)); } } if (m &lt;= 2) { cout &lt;&lt; ans[m - 1] &lt;&lt; '\\n'; } else { cout &lt;&lt; (ans[2] - ans[1]) * (m - 2) + ans[1] &lt;&lt; '\\n'; }} J. Sum of Squares of GCDsCode >folded1 M. Covering a TreeCode >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748void solve() { int n = read(); vector&lt;int&gt; par(n + 1); vector&lt;vector&lt;int&gt;&gt; g(n + 1); for (int i = 2; i &lt;= n; i++) { int p = read(); par[i] = p; g[p].eb(i); } vector&lt;int&gt; dep(n + 1); vector&lt;pii&gt; leaf; auto dfs = [&amp;](auto&amp;&amp; self, int u) -&gt; void { for (int v : g[u]) { dep[v] = dep[u] + 1; self(self, v); } if (g[u].empty()) { leaf.eb(dep[u], u); } }; dfs(dfs, 1); std::sort(leaf.begin(), leaf.end()); // for (auto [d, u] : leaf) { // cerr &lt;&lt; d &lt;&lt; &quot; &quot; &lt;&lt; u &lt;&lt; &quot;\\n&quot;; // } int ans = 0; vector&lt;int&gt; vis(n + 1); for (auto [_, u] : leaf) { int res = 0; for (int v = u; par[v] != 0; v = par[v]) { // v -&gt; par[v] res++; // cout &lt;&lt; &quot;vis&quot; &lt;&lt; v &lt;&lt; &quot; &quot; &lt;&lt; par[v] &lt;&lt; &quot;\\n&quot;; if (vis[v]) break; vis[v] = 1; ans = max(ans, res); } } cout &lt;&lt; ans &lt;&lt; '\\n';}","link":"/vp-2024-%E5%A5%B3%E7%94%9F%E8%B5%9B/"},{"title":"VP 2024 ICPC 昆明","text":"比赛链接 Problems AC Note A. ○ B. ⊕ C. ○ D. ○ E. ○ F. ACode >folded1 BCode >folded1 CCode >folded1 DCode >folded1 ECode >folded1","link":"/vp-2024-icpc-%E6%98%86%E6%98%8E/"},{"title":"2024 ICPC 网络赛 第一场","text":"The 2024 ICPC Asia East Continent Online Contest (I) 赛时榜单 Problems AC A. World Cup ○ B. Graph C. Permutation Counting 4 ⊕ D. Protection War E. Random Dungeon F. Make Max ○ G. The Median of the Median of the Median ○ H. Rainbow Bracket Sequence I. Boxes J. Rivals K. AC Automation Chicken L. Bull Farm ⊕ M. Find the Easiest Problem ○ M 签到赛时脑瘫 + 没仔细读题。脑残把队伍名的 team 去掉了，实际上不一定以 team 开头，怒吃一发罚时。 12345678910111213141516171819void solve() { int n = read(); std::set&lt;std::string&gt; st[26]; for (int i = 1; i &lt;= n; i++) { std::string s, sta; char t; cin &gt;&gt; s &gt;&gt; t &gt;&gt; sta; bool f = (sta == &quot;accepted&quot;); if (f == 0) continue; st[t - 'A'].insert(s); } int res = 0; for (int i = 0; i &lt; 26; i++) { if (st[i].size() &gt; st[res].size()) res = i; } cout &lt;&lt; char(res + 'A') &lt;&lt; '\\n';} F 单调栈赛时第一反应竟然都不是单调栈而是 set / 链表。小齐直接化身指针仙人。如果用单调栈写的话应该能少不少罚时吧。 1234567891011121314151617181920212223242526272829void solve() { int n = read(); vector&lt;int&gt; a(n + 2); a[0] = a[n + 1] = 2e9; for (int i = 1; i &lt;= n; i++) a[i] = read(); i64 ans = 0; vector&lt;int&gt; stk {0}; for (int i = 1; i &lt;= n; i++) { while (!stk.empty() and a[stk.back()] &lt; a[i]) { stk.pop_back(); } ans += i - stk.back() - 1; stk.push_back(i); } stk = {n + 1}; for (int i = n; i &gt;= 1; i--) { while (!stk.empty() and a[stk.back()] &lt; a[i]) { stk.pop_back(); } if (a[stk.back()] != a[i]) ans += stk.back() - i - 1; stk.push_back(i); } cout &lt;&lt; ans &lt;&lt; '\\n';} A 签到赛时秒了，分别考虑作为 $A1$ 或者 $A2$ 出线，然后算下需要多少个队伍小于他就行了 1234567891011121314151617181920void solve() { int a[32]; for (int i = 0; i &lt; 32; i++) { a[i] = read(); } int cnt = 0; for (int i = 1; i &lt; 32; i++) { if (a[i] &lt; a[0]) { cnt++; } } int ans = 32; if (cnt &gt;= 31) ans = 1; else if (cnt &gt;= 27) ans = 2; else if (cnt &gt;= 13) ans = 4; else if (cnt &gt;= 6) ans = 8; else if (cnt &gt;= 2) ans = 16; cout &lt;&lt; ans &lt;&lt; '\\n';} C 思维 / 线性代数很申必的一个题 解法一赛后卧龙的做法，感觉很思维。 你考虑构造一些双射，让他们抵消掉。因为如果两个区间是一样的，那么他们可以交换，那么就是 $0$。所以就把区间之间的包含关系搞掉，拆开来，然后看是否有一样的区间。 比如有 $5$ 个区间分别是 $[1, 5], [1, 4], [4, 5], [5, 5], [1, 2]$。 你把 $[1, 5], [1, 4], [1, 2]$ 拆成 $[1, 2], [3, 4], [5, 5]$。然后和已有的 $[5, 5]$ 撞了，所以就是 $0$。 1234567891011121314151617181920212223void solve() { int n = read(); vector&lt;vector&lt;int&gt;&gt; vec(n + 1); for (int i = 1; i &lt;= n; i++) { int L = read(), R = read(); vec[L].eb(R); } for (int i = 1; i &lt;= n; i++) { auto &amp;a = vec[i]; if (a.empty()) { puts(&quot;0&quot;); return; } std::sort(a.begin(), a.end()); int siz = a.size(); for (int j = 0; j + 1 &lt; siz; j++) { if (a[j] == a[j + 1]) { puts(&quot;0&quot;); return; } vec[a[j] + 1].eb(a[j + 1]); } } puts(&quot;1&quot;);} 解法二 行列式待更。 G 中位数 trick唐完了，最后十几分钟我突然会了，直接上机 rush。不知道为什么调不对。赛后仔细想了一下发现 check 区间和得要 $&gt;= 1$ 而不是 $&gt;= 0$。因为偶数的时候最坏其实是 $(+1) + (+1) = 2$。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364void solve() { int n = read(); vector&lt;int&gt; a(n + 1); for (int i = 1; i &lt;= n; i++) a[i] = read(); vector&lt;vector&lt;int&gt;&gt; b(n + 1, vector&lt;int&gt;(n + 1)); for (int i = 1; i &lt;= n; i++) { std::priority_queue&lt;int&gt; G, L; for (int j = i; j &lt;= n; j++) { if (G.empty() or a[j] &lt;= G.top()) { G.push(a[j]); } else { L.push(-a[j]); } if (G.size() &gt; (j - i + 2) / 2) { L.push(-G.top()); G.pop(); } else if (G.size() &lt; (j - i + 2) / 2) { G.push(-L.top()); L.pop(); } b[i][j] = G.top(); } } auto judge = [&amp;](int lim) { vector&lt;vector&lt;int&gt;&gt; c(n + 2, vector&lt;int&gt;(n + 2)); for (int i = 1; i &lt;= n; i++) { for (int j = i; j &lt;= n; j++) { int k = 1; if (b[i][j] &lt; lim) k = -1; c[1][j] += k; c[i + 1][j] -= k; } } int res = 0; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { c[i][j] += c[i - 1][j] + c[i][j - 1] - c[i - 1][j - 1]; if (i &gt; j) continue; if (c[i][j] &gt;= 1) res++; else res--; } } return res &gt;= 1; }; int res = 0; for (int L = 1, R = 1e9; L &lt;= R; ) { int mid = L + R &gt;&gt; 1; if (judge(mid)) res = mid, L = mid + 1; else R = mid - 1; } cout &lt;&lt; res;} L bitset首先可以将询问离线，按 $c$ 排序，依次加边。 一个序列合法只能是一个没有重复的排列或者只有一个数出现了两次。 考虑空位的移动，每个询问等价于空格能否从 $a$ 移动到 $b$。 如果是一个排列，那么对于每个 $i$，如果空格在 $i$，空格就能移动到 $p_i$。 如果是一个数出现了两次的情况，设 $p_x = p_y$，那么空格只能从 $x$ 或 $y$ 移动到那个没出现的位置。 用 $bitset$ 维护可达性即可。 最多 $O(n^2)$ 条边。加一条边的复杂度是 $O(\\frac{n^2}{\\omega})$。 但是实际跑不到那么多，因为在加边的时候有记忆化。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768void solve() { int n = read(), l = read(), q = read(); vector g(n + 1, std::bitset&lt;2005&gt;()); for (int i = 1; i &lt;= n; i++) g[i][i] = 1; vector t(l + 1, vector&lt;int&gt;(n + 1)); for (int i = 1; i &lt;= l; i++) { for (int j = 1; j &lt;= n; j++) { t[i][j] = input(); } } vector&lt;int&gt; ans(q); vector qry(l + 1, vector&lt;std::array&lt;int, 3&gt;&gt;()); for (int i = 0; i &lt; q; i++) { int a = input(), b = input(), c = input(); qry[c].pb({a, b, i}); } auto add = [&amp;](int a, int b) { if (g[a][b]) return; for (int i = 1; i &lt;= n; i++) { if (g[i][a]) { g[i] |= g[b]; } } }; auto go = [&amp;](const auto &amp;p) { vector&lt;int&gt; buk(n + 1); int f = 0; for (int i = 1; i &lt;= n; i++) { if (!buk[p[i]]) buk[p[i]] = 1; else if (f) return; else f = p[i]; } if (!f) { for (int i = 1; i &lt;= n; i++) { add(i, p[i]); } } else { int x = 0; for (int i = 1; i &lt;= n; i++) { if (!buk[i]) x = i; } for (int i = 1; i &lt;= n; i++) { if (p[i] == f) { add(i, x); } } } }; for (int i = 0; i &lt;= l; i++) { go(t[i]); for (auto [a, b, idx] : qry[i]) { ans[idx] = g[a][b]; } } for (int x : ans) cout &lt;&lt; x; puts(&quot;&quot;);}","link":"/2024-icpc-%E7%BD%91%E7%BB%9C%E8%B5%9B-%E7%AC%AC%E4%B8%80%E5%9C%BA/"},{"title":"todo-list","text":"Something Todo","link":"/todo-list/"},{"title":"「笔记」Border","text":"","link":"/%E3%80%8C%E7%AC%94%E8%AE%B0%E3%80%8Dborder/"},{"title":"Lecture Notes: Computer Organization","text":"COMP1003 Computer Organisation Prof. Haipeng GUO Lec01-03What is a Computer? Definition:A computer is an electronic, digital, general-purpose machine that follows follows a step-by-step list (computer program) of instructions for solving a problem计算机是一个电子的、数字化的通用机器，它按照逐步指令程序解决问题。 Turing Machine 1936年，Alan Turing。 Definition:Turing machine, which is the abstract model of all computers Components: a tape divided into cells a moving read/write head a state register storing the state of the Turing machine a finite table of instruction The Church-Turing Thesis: All things that can be computed can be computed by a Turing machine Universal Turing Machine: a Turing machine that could simulate all other Turing machines. It is programmable – so it is a computer! A computer is a Universal Turing Machine! Historical Development Generation Zero: Mechanical Calculating Machines (1642-1945) The First Generation: Vacuum Tube Computers (1945-1953) The Second Generation: Transistor Computers (1954-1965) The Third Generation: Integrated Circuit (IC) Computers (1965-1980) The Fourth Generation: VLSI(Very-Large-Scale Integration) Computers (1980-) Von Neumann ArchitectureAlso called stored-program architecture Both data and program are stored in the memory Components:CPU (control unit, ALU, registers), memory, and an I/O system.CPU（控制单元，算术逻辑单元，寄存器）、内存和I/O系统。 von Neumann Bottleneck:The speed difference between the CPU and memory creates a delay, as the CPU is faster than memory. Von Neumann Execution Cycle also called the fetch-decode-execute cycle the control unit fetch the next instruction from the memory the instruction is decoded into a language that the ALU understands data operands are fetched from the memory into the registers inside CPU the ALU executes the instruction and places the result into the registers or memory Abstraction The essence of abstraction is preserving information that is relevant in a given context, and forgetting information that is irrelevant in that context. Levels of Transformations Problem –(Software Design)-&gt; Algorithm –(Programming)-&gt; Program –(Compiling/Interpreting)-&gt; Instr Set Architecture Problem: What you want to do Algorithm: step-by-step procedure to solve the problem Program: a computer program that implements the algorithm using some programming languages The Machine Levels Instruction Set Architecture (ISA): instructions that a CPU can execute Microarchitecture: implementation of ISA Circuits: Details of electrical circuits Devices (transistors): Circuits are built by interconnecting transistors Bits: Transistors operate on bits (“0” or “1”) that represent data and information Signed Interger Representation Sign-magnitude：原码，最高位是符号位，剩下表示大小 1’s complement：正数的话同原码。负数的话，在原码基础上，符号位不变，剩下取反。 2’s complement：正数的话同原码。负数的话，在原码基础上，符号位不变，剩下取反，再加一。 Real Number Representation以下是 IEEE754 Single Point Precision Numbers 的示例 单精度浮点数，32 bits。从左到右，1 个 bit 表示 sign，8 个 bit 表示 exponent，23 个 bit 表示 fraction。 $$(-1)^{sign} \\times (1 + fraction) \\times 2 ^ {exponent - 127}$$ e.g. $(12.375)_{10}$ to float $(12.375){10} = (1100.011){2} = 1.100011 \\times 2 ^ 3$ Sign bit = 0 Exponent: $3 + 127 = 130 = 1000 0010$ Mantissa: 1000 1100 0000 0000 000 Answer: 0 1000 0010 1000 1100 0000 0000 000 Lec04-06 Integrated Circuits (IC)The integration of large numbers of tiny transistors into a small chip Two Types of Circuits Combinational logic circuits Its output depends solely on its current input. No storage, memoryless Sequential logic circuits Its output depends not only on its current input, but also on its current state (previous input) Can remember previous input, storage devices Combinational logic circuitsDecoder A decoder uses the inputs and their respective values to select one specific output line. from a set of n inputs to a maximum of 2^n outputs for a given input, one unique output line is asserted, or set to 1, while the other output lines are set to zero All memory addresses in a computer are specified as binary numbers. When a memory address is referenced (whether for reading or for writing), the computer first has to determine the actual address.在计算机中，所有内存地址都用二进制数字表示。当计算机需要读取或写入某个内存地址时，它首先必须确定该地址的实际位置。 This is done using a decoder这个过程通常是通过解码器完成的。计算机将地址作为输入传递给解码器，解码器然后将正确的内存单元激活，以便进行数据读取或写入。 MultiplexerA multiplexer behaves like a channel selector It selects a single output from several inputs. The particular input chosen for output is determined by the value of the multiplexer’s control lines. To be able to select among n inputs, log2 n control lines are needed Sequential logic circuitsSequential Circuits = Combinational Circuits + Memory memoryWhat exactly is memory? Write: You should be able to change (write) the valuethat’s saved. Hold the value: It should be able to hold a value. Read: You should be able to read the value thatwas saved. Lec07-10Finite State MachineThe concept of state: The output of a sequential circuit is a function of the current input and the previous state The state is stored in the storage element A system is a finite state machine if it has the following five properties: A finite number of states A finite number of external inputs A finite number of external outputs An explicit specification of all allowed state transitions所有合法状态转换的明确规范 An explicit specification of the rules for each external output value每个外部输出值的规则的明确规范 Turing Machine vs FSM A Turing machine = a FSM + a tape memory. Each transition may be accompanied by anoperation on the tape (move, read, write). Its total possible configurations are arbitrarily large, regardless of the size of the program; it expands towards infinity.它的总可能配置是任意大的，与程序的大小无关；它会向无穷大扩展。 Turing machines have more computational power than FSM.图灵机比 FSM 具有更强的计算能力。 Microarchitecture Micro-architecture transfers the ISA into an implementation An architecture is a collection of circuits connected together The von Neumann ArchitectureThe Stored Program Computer Memory stores not only data, but coded instructions that make up a computer program内存不仅存储数据，还存储组成计算机程序的编码指令 CPU fetches and executes – interprets - successive instructions of the programCPU 获取并执行 - 解释 - 程序的连续指令 Program is simply data for the interpreter – as in a Universal Turing Machine!程序只是解释器的数据 - 就像通用图灵机一样！ Single expandable resource pool – main memory – constrains both data and program size单个可扩展资源池 - 主内存 - 限制数据和程序大小 Memory Array of stored bits Address - unique (n-bit) identifier of location Contents - m-bit value stored in location Basic Operations LOAD – read a value from a memory location STORE – write a value to a memory location Interface to Memory How does CPU get data to/from memory? MAR: Memory Address Register (D flip-flops) MDR: Memory Data Register (D flip-flops) CPU The brain of the computer It is the part that actually executes the machine instructions Inside the CPU Data path Registers PC, IR, MAR, MDR ALU DataBus 数据总线 Control Path CU 解析当前指令并生成相应的控制信号，控制指令的执行过程。 a finite state machine coordinates execution of the program IR (instruction register) 存储当前执行的指令，用于CU解码和生成控制信号。 PC (program counter) 存储下一条要执行指令的地址，每执行完一条指令，PC会更新指向下一条指令地址。PC可以在跳转指令下由CU修改。 LC-3LC-3 是一种简化的教学计算机架构（Little Computer 3），用于帮助学习和理解计算机组成原理。它是一种虚拟的计算机模型，不用于实际应用，而是为了帮助学生掌握计算机指令执行、内存管理和CPU工作原理等基础概念。LC-3架构的指令集和寄存器设计都尽可能简单，以便于学习和理解。 LC-3 计算机架构： LC-3 特点：LC-3拥有16位的指令和16位的数据，总共支持15条基本指令，使用简单的寄存器和内存结构，适合教学。 Input and Output– Keyboard (KBDR &amp; KBSR)– Monitor (DDR &amp; DSR) Memory Address space: 2^16 memory locations Addressability: 16-bit addressable, MAR and MDR内存：LC-3的内存地址空间为16位，意味着可以访问的地址范围是0到65535（即64 KB的内存）。 The Processing Unit ALU (ADD, AND, NOT) 8 generał register (R0, R1, …, R7)寄存器：LC-3有8个通用寄存器（R0到R7），其中每个寄存器都是16位，用于存储操作数和结果。 The Control Unit The FSM that directs all the activities The instruction Register (IR) and Program Program Counter (PC) InstructionOne instruction specifies two things: opcode: operation to be performed操作码：要执行的操作 operands: data/locations to be used for operation操作数：用于操作的数据/位置 A computer’s instructions and their formats is known as its Instruction Set Architecture (ISA). 计算机的指令及其格式被称为其指令集架构 (ISA)。 Lec11-13SubroutineA subroutine is a program fragment that:– performs a well-defined task– is invoked (called) by another user program– returns control to the calling program when finished Call JSR/JSRR instruction Return RET instruction Input &amp; Output MechanismI/O Programming Interface How are device registers identified? Memory-mapped vs. special instructions Memory-mapped设备寄存器被映射到计算机的内存地址空间。CPU通过访问特定的内存地址与设备通信。优点：统一了I/O设备与内存的访问方式，无需专用指令。 Special InstructionsCPU使用专门的I/O指令与设备通信。这种方法与内存访问分离，需要特定指令集支持。 How is timing of transer managed? Asynchronous vs. synchronous Asynchronous数据传输速率不固定，依赖于设备的准备状态。CPU需要与设备同步以避免数据丢失或写入过快。 Synchronous数据以固定、可预测的速率传输。CPU和设备以固定周期协调工作，减少同步问题。 Who controls transfer? CPU(polling) vs. device(interrupts) CPU(polling)CPU不断检查设备状态寄存器，直到设备准备就绪。缺点：CPU资源浪费严重，因为它需要不断轮询设备。 Device(interrupts)当设备准备好数据时，发送中断信号通知CPU。CPU可以在等待设备时执行其他任务，大幅提高效率。","link":"/lecture-notes-computer-organization/"},{"title":"Lecture Notes: Database Management Systems","text":"COMP3013 Database Management Systems Dr. Zhiyuan Li 数据库规范化与 BCNFIntro 1. 什么是规范化？ 目标： 减少数据库中的数据冗余（Redundancy）。 消除插入、删除和更新异常（Anomalies）。 方法： 将关系模式分解为符合一定范式的子关系模式。 常见的范式包括： 第一范式（1NF） 第二范式（2NF） 第三范式（3NF） BCNF（Boyce-Codd Normal Form） 2. 规范化的核心原则 无损分解（Lossless Decomposition）： 分解后的子关系模式可以通过自然连接（Natural Join）无损恢复到原始关系模式。 依赖保留（Dependency Preservation）： 分解后仍然可以在子关系模式中检查所有函数依赖（Functional Dependencies）。 Lecture 09: Functional Dependencies 1. 什么是函数依赖 (Functional Dependency, FD)? 定义： 在关系模式 $R$ 中，如果属性集合 $\\alpha$ 的值唯一确定属性集合 $\\beta$ 的值，那么 $\\alpha \\to \\beta$ 是一个函数依赖。 公式：$\\alpha \\to \\beta$ 含义：$\\alpha$ 的值唯一决定 $\\beta$ 的值。 例子： 学生表（Student）：Student_ID → Student_Name 表示学号唯一决定姓名。 在关系 $r(A, B)$ 中，如果 $A → B$ 成立，则关系中的每个 $A$ 值对应唯一的 $B$ 值。 2. 平凡依赖 (Trivial Dependency) 定义： 如果 $\\beta \\subseteq \\alpha$，则 $\\alpha → \\beta$ 是平凡依赖。 平凡依赖总是成立，无论关系中的数据如何。 例子： $Course_{Code} → Course_{Code}$ $Student_{ID}, Course → Student_{ID}$ 3. 闭包 (Closure) 定义：给定函数依赖集合 $F$，其闭包 $F^+$ 是包含 $F$ 和所有由 $F$ 推导出的函数依赖的集合。 如何计算闭包？ 规则（Armstrong 公理）： 自反性 (Reflexivity): 如果 $\\beta \\subseteq \\alpha$，则 $\\alpha → \\beta$。 增广性 (Augmentation): 如果 $\\alpha → \\beta$，则 $\\gamma\\alpha → \\gamma\\beta$。 传递性 (Transitivity): 如果 $\\alpha → \\beta$ 且 $\\beta → \\gamma$，则 $\\alpha → \\gamma$。 4. 闭包例子 给定 $R = \\lbrace A, B, C \\rbrace$ 和 $F = \\lbrace A → B, B → C\\rbrace$： 计算 $F^+$: $A → B$（已知）。 $B → C$（已知）。 $A → C$（通过 $A → B$ 和 $B → C$ 的传递性推导）。 5. 如何检查超键？ 超键：一个属性集合是超键，如果其闭包包含关系中的所有属性。 检查方法： 计算属性集合 $\\alpha$ 的闭包 $\\alpha^+$。 如果 $\\alpha^+$ 包含关系中的所有属性，则 $\\alpha$ 是超键。 6. 伪代码：闭包计算12345678输入: 属性集合 α, 函数依赖集合 F输出: 属性集合 α 的闭包 α+1. 初始化 α+ = α2. 重复以下步骤，直到 α+ 不再变化: 3. 对于每个函数依赖 β → γ ∈ F: a. 如果 β ⊆ α+: 将 γ 加入 α+4. 返回 α+ 12345678910111213输入: 函数依赖集合 F输出: F 的闭包 F+1. 初始化 F+ 为 F (即 F+ 开始时仅包含初始依赖集合 F)。2. 重复以下步骤，直到 F+ 不再增加新的依赖： 3. 对于 F+ 中的每个函数依赖 α → β: a. 根据以下规则生成新的函数依赖： i. 自反性 (Reflexivity): 如果 β ⊆ α，则 α → β。 ii. 增广性 (Augmentation): 如果 α → β，则 γα → γβ。 iii. 传递性 (Transitivity): 如果 α → β 且 β → γ，则 α → γ。 b. 将新生成的依赖加入 F+，如果它尚未存在。4. 返回 F+ Lecture 10: Boyce–Codd Normal Form (BCNF) 1. 什么是 BCNF？BCNF 是一种数据库设计规则，用来解决数据冗余和更新异常的问题。它是第三范式（3NF）的增强版本，要求更严格。 核心要求： 如果一个表 $R$ 中存在一个函数依赖 $\\alpha \\to \\beta$，那么： 要么 $\\beta$ 是 $\\alpha$ 的子集（平凡依赖）。 要么 $\\alpha$ 是这个表的超键（Superkey）。 如果表中的每一个函数依赖都符合上面的要求，那么这个表就是 BCNF。 2. 直观例子假设我们有一个表 Course_Info： 1234567+------------+-------------+-------------+-----------+| c_name | professor | credits | domain |+------------+-------------+-------------+-----------+| Database | Dr. Smith | 3 | CS || Database | Dr. Johnson | 3 | CS || Algebra | Dr. Smith | 4 | Math |+------------+-------------+-------------+-----------+ 函数依赖： $c_{name} \\to credits, domain$（课程名称唯一决定学分和领域）。 $c_{name}, professor \\to credits, domain$（课程名称和教授一起也可以决定学分和领域）。 分析： 这里 $c_{name} \\to credits, domain$ 是一个有效的函数依赖，但 $c_{name}$ 不是超键（不能唯一标识表中的每一行）。 因此，这个表不符合 BCNF。 3. 如何解决？通过BCNF 分解，将表分解为两个更小的表： 一个表保存课程的基础信息： 123456+------------+-------------+-----------+| c_name | credits | domain |+------------+-------------+-----------+| Database | 3 | CS || Algebra | 4 | Math |+------------+-------------+-----------+ 另一个表保存教授信息： 1234567+------------+-------------+| c_name | professor |+------------+-------------+| Database | Dr. Smith || Database | Dr. Johnson || Algebra | Dr. Smith |+------------+-------------+ 现在，每个表都符合 BCNF。 4. 总结 BCNF 的定义简化版： 每个函数依赖的左边（$\\alpha$）必须是超键。 检查方法： 找出表中的函数依赖。 检查依赖的左边是否是超键。 不符合时： 通过分解表来解决，确保每个子表都符合 BCNF。 Lecture 11: Third Normal Form (3NF) 1. 什么是第三范式 (3NF)? 定义：关系模式 $R$ 满足 3NF，当对于每个函数依赖 $\\alpha → \\beta$： $\\beta \\subseteq \\alpha$ （平凡依赖），或 $\\alpha$ 是超键 (Superkey)，或 $\\beta - \\alpha$ 中的每个属性是某个候选键的属性。 2. 为什么需要 3NF？ 在某些情况下，BCNF 分解可能无法保留依赖。 3NF 允许一定的冗余，确保所有依赖都可以在分解后的关系中检查。 3. 示例 给定关系模式 $R = \\lbrace J, K, L\\rbrace$ 和函数依赖 $F = \\lbrace JK → L, L → K\\rbrace$： 候选键：$\\lbrace J, K\\rbrace$, $\\lbrace J, L\\rbrace$。 检查函数依赖： $JK → L$：满足 $JK$ 是超键。 $L → K$：满足 $K$ 属于候选键。 结论：$R$ 已满足 3NF。 4. 3NF 分解算法123456输入: 关系模式 R, 函数依赖集合 F输出: 分解后的 3NF 子关系模式1. 计算 F 的标准覆盖 (Canonical Cover)。2. 对于每个函数依赖 α → β: a. 创建子关系模式 {α ∪ β}。3. 如果没有包含候选键的子关系模式，添加一个包含候选键的子关系。 Lecture 12: Multivalued Dependencies and 4NF 1. 什么是多值依赖 (Multivalued Dependency, MVD)? 定义：如果属性集合 $\\alpha$ 确定 $\\beta$ 的多个独立值，则称 $\\alpha ↠ \\beta$ 是一个多值依赖。 公式：$\\alpha ↠ \\beta$ 例子： 学生 $ID ↠ ISBN$ 和 $ID ↠ Phone$。 学生的书籍 $ISBN$ 和电话 $Phone$ 彼此独立。 2. 第四范式 (4NF) 定义：关系模式 $R$ 满足 4NF，当对于每个多值依赖 $\\alpha ↠ \\beta$： $\\beta \\subseteq \\alpha$ 或 $\\alpha ∪ \\beta = R$ （平凡 MVD），或 $\\alpha$ 是超键。 3. 示例 $R = \\lbrace ID, ISBN, Phone \\rbrace$ 多值依赖：$ID ↠ ISBN$ 和 $ID ↠ Phone$ 违反 4NF： 因为 $ID$ 不是超键。 分解： $R_1 = \\lbrace ID, ISBN \\rbrace$ $R_2 = \\lbrace ID, Phone \\rbrace$ 4. 4NF 分解算法1234567输入: 关系模式 R, 多值依赖集合 D输出: 4NF 分解后的子关系模式1. 找到违反 4NF 的多值依赖 α ↠ β。2. 将 R 分解为: a. 包含 α ∪ β 的子关系。 b. 包含 R - β 的子关系。3. 重复以上步骤，直到所有子关系满足 4NF。","link":"/lecture-notes-database-management-systems/"},{"title":"Hexo Icarus 主题魔改记","text":"退役后以来，高考的摧残使得老博客几万年没更新过了。 大一开始以后，本着记录知识点的需要，开了一个新的博客，从 Hugo 重新换回了 Hexo Icarus。 因为太懒了所以一整个大一 Blog 都是跑在本地的，现在把 Blog 放到 GitHub Pages 上面了。 但是放上来的时候手残把 Icarus 重装了，得重新魔改一下 Icarus，想着干脆直接开一个贴子记录一下。 布局页面宽度主题默认是三栏布局，在阅读文章时显得有些拥挤。可以通过配置的方式把所有文章变为两栏布局，在 _config.post.yml 把需要的 widget 显示在一边即可，可以参考官方文档。 但两栏整体宽度跟三栏不同，因此强制指定为三栏布局，并且修改相应的宽度，这样所有的页面侧边栏宽度保持一致。 diff 并优化在不同屏幕小大下的宽度 diff 文章时间信息原来是显示相对时间，改为绝对时间，直接显示日期，并增加 icon diff 目录粘性定位原来只支持侧边栏整体粘性定位，为了阅读体验，只针对目录开启粘性定位，增加 column-left is-sticky 类，并调整样式。 diff References Xinyu Liu – Icarus 主题自定义","link":"/hexo-icarus-%E4%B8%BB%E9%A2%98%E9%AD%94%E6%94%B9%E8%AE%B0/"},{"title":"Stanford CS231n 笔记","text":"Stanford CS231n: Deep Learning for Computer Vision Course Website 放在前面一些有用的资源 Lecture Lecture Video on Youtube (2017 Spring) 【【公开课】最新斯坦福李飞飞cs231n计算机视觉课程【附中文字幕】】 Lecture Notes Richard YU – Stanford CS231n 笔记 杜客 – CS231n官方笔记授权翻译 Assignments 理智点 – cs231n assignment 1 2 3作业解析导航页 mantasu – CS231n: Assignment Solutions Assignment 1Q1 k-NN就是找 k 个距离最近的，然后看这 k 个里面哪种最多 Assignment 1 Q1 k-NN 已完成，我的答案 Q2 SVMAssignment 1 Q2 SVM 已完成，我的答案 Q3 SoftmaxAssignment 1 Q3 Softmax 已完成，我的答案 Q4 Two Layer Net小跑进入 Neural Network My Solution Q5 FeaturesHigher Level Representations: Image Features assignment1/features.ipynb Assignment 2Q1","link":"/stanford-cs231n-%E7%AC%94%E8%AE%B0/"},{"title":"Master theorem","text":"$T(n)=aT(\\frac{n}{b})+O(n^d)$ 上 DSA 用到了就从以前 Blog 上面扒到这里来继续用了（ 简要做法$$Total work = \\sum_{0}^{\\log_bn}O(n^d)(\\frac{a}{b^d})^i$$ 这东西是个等比数列,公比为 $(\\frac{a}{b^d})$ 等比数列的求和公式为 $$S=\\frac{a_1(1-q^n)}{1-q}$$ 时间复杂度是由最大的那一项决定的对吧，那么分类讨论下公比即可知道哪一项是最大的 公比 &lt; 1显然等比数列第一项最大，后面逐渐变小 即 $$(\\frac{a}{b^d}) &lt; 1 \\Rightarrow d &gt; \\log_ba$$ $$Total work = O(O(n^d)(\\frac{a}{b^d})^0) = O(n^d)$$ 公比 &gt; 1那么是最后一项最大 $$(\\frac{a}{b^d}) &gt; 1 \\Rightarrow d &lt; \\log_ba$$ $$Total work = O(O(n^d)(\\frac{a}{b^d})^{\\log_bn}) = O(n^d(\\frac{a}{b^d})^{\\log_bn}) = O(n^d(\\frac{a^{\\log_bn}}{b^{d\\log_bn}}))$$ $$O(n^d(\\frac{a^{\\log_bn}}{b^{d\\log_bn}})) = O(n^d(\\frac{a^{\\log_bn}}{n^d})) = O(a^{\\log_bn})$$ $$a^{\\log_bn} = a^{\\frac{\\log_an}{\\log_ab}} = (a^{\\log_an})^{\\frac{1}{\\log_ab}} = n^{\\frac{1}{\\log_ab}}$$ $$\\frac{1}{\\log_ab} = \\log_ba$$ $$O(a^{\\log_bn}) = O(n^{\\log_ba})$$ 公比 = 1每一项都一样大，要求和 $$Total work = O(n^d)(1+\\log_bn) = O(n^d\\log_bn)$$ 综上 如果 $d &gt; \\log_ba$，$T(n) = O(n^d)$ 如果 $d = \\log_ba$，$T(n) = O(n^d\\log_bn)$ 如果 $d &lt; \\log_ba$，$T(n) = O(n^{log_ba})$","link":"/master-theorem/"},{"title":"2024 ICPC 沈阳游记","text":"b0912037589f211b8f44b9d5e6d4bde91705d429e793024d2aa97cc83169599f82c50a66bb401a3673a59126d36ca7930850e636cae263d2dc24e37ab2426f44583528e8970b6583bb42cc88524151ef5462ba44fcf02d5359b4b73466f7437c45d2a2379f456bb298641b1b35aa058eef6be64dc6705a091c63ec2acc257e4c4137bb8ebe88751604cea3b2b5c59b2317478034341a4df6fc2ef6e0f22b1a2626c2b2d110aa39b48d8fe34772fe5af88f91c1148e33349a98c7f2cf772e19788d7d097a7e725d5272428209ecc7efe7a567cf7a02a15f3cca2ddef72f53ed37314ea97920ec91838e36addbd48e6295ea809d29559840511c8cc84a9ef0f90aba2262183dfbdd76e36aadbc7df5dea989f4fe166b2ceed817e24863d0e285e80fec9019371bc99538ea5ddf1cb3b3a434e3cb6252667515690e894e45b1e7ea577a9908943d04dde7837306658bf4f28622f273e2249988ea4166f5beb267396b0257c89e91c31f476520b392b2f7ef54360e533ab64b866cc2f4f9d54b78b48ec0b6cf68201482ca1e0888683ff750af45c63dda02488448fb4b987a84e4935cd715bd6c8352a7999c19495d906f3b0f7d11361069f9d310b0c42a43fedfb4b4b0ea8383b704b44618e43609edec315dc3b7a0722b9b28e1c8ecf29ac766286196393f1438a60f0e50e7a3408e6ba1f4101993dc9eb51d722a35ef07f87a4d98c56662f739e85337737b572c9f8b35e36ab59735fe173f8bd915c7c2006f80304bfb495179bb0f06d2031d0e98cd4b58af1ae7801278206ef8d56e2814295fb97699b6a8405601f4d3b5d919a9283f12cd032d13683137f5144687798a910e0fd69550c1123ccb6421b67765621a26c47ec9b1d0b3ae7a8a2f2e0a349c0a4aea04ec79b4389ab4c5cd6efdc39f5d4d2303ce1ddc3b35db520ce912d1e9b2077a14e0d7c62440c4d770df556d07a6ff8f4818939e574e75229bc2c86813199b4f530b511718f1f80bfb9a7ec6353e283ffaa407274d877c3938d7c9737b2996f85a16a93667c2fdf26d936de545ec66f3d4837b993b49ed5954f4174c51207795dad318bb8a4a158a23cf6f4d48626ab436e2d397ac45ccb6683ef821a9f1e4bf02a038d484a7756dafc518fd7acb9dd75ea8c7d6d40ffacc2b02846b3e63fb50fb48850035e48725ccdce01551bb47e10abf6664924ee407b704d57d2998c1543552460a9373bef867a080a8018f0e26df76009ba9231a33aef1902eda1f46da204f6e186990fc78ea8c8a1c3b91df44d7b5a6ece2fa25bd767a6518bbf5516dc2b008a1c7683c99057532518fadf68f87d17381b1ded79fd83e510a3c2cfcf3e162dee1a1c062c83c39ab00da22e5ed215df4aaa378b3d302e97cff61320a47de9b360683c6a1d69be97815a8dc8dd2278ec332b325a74f41324155572819acfd3d5535179c1a251b3da157116d92039c09d62dd238a9958bf8098c41126275b3cfb962e52827609728a3f16f0577c0016fa54d3f17588ae10f9326be73e3a6433358c737f4456ef517d51239ca27064aaa1e17ebe4fbb07688e41b3e28c39f2a032aafba7dfcf4a1c235f371b8b55e154027ccd4919a928cab353e6494ab1200acbeaa06aac669606205aaebaa71619637fc8669f2616f59d8a15964940ba5eda88650dab3381f2b32725343d4bf37388032bb893f0868afb2066952d73db4a1cd842e2f08155a73a1af7ff598c2e308d87d0d31a113ff0c5b1676abb6e657e7b19403ac53aba15022cabafd950e9b8b6d4539c6b967c0d2a39114ad002feb1a4a17a97a98124d303f220f459b5aac8da1bed36811e75b577f82c853ee9004ecd8cb2d59d3a668ea35db5126c76feee7cb4193fb553dc62db6dcaf66948df8ad0a3202fc293d6adbefc294f5b5803d08f6636dbe54464ab2bcdf743bab0f60457eacbb1b52225a9b1f7baddf6f5438b5c804cb33eb63e52129ab3afcbe02c9563ea55e694f216bfc30e49273df777504649d14234827a3a181dae3ebd1fd4b069d20447fc709798bbaf1315a3d9a0304601c31046066ad31b9f4653df37075e17efbbfaebac27d005d5dd65cafdc2a8a2ed7419df3b8936848e0deb507ed88cd752e300b7098c14da2f343ff3a2d45822eecdec18d8dae6c3e0adb7bd0801eee727dd55b22fc4c9e5010654baa8f6c436616a00ab3cd8c184abaac9e8f0e7cd4a8d3ce8369d8e72f795fe07c7c7810f641a817d81dec589dd3fc15f790a3f375faa0a245d8a92f9fec7e83ddf793745ee49e210aab2ea59ebdee6ecbc5b1907e1b00ee8ea7f5138d67670f0d531c22e4eb88e3d77db33dc00b55c22c99a82ea9b6d3ee1c72a4e622f8e8f16f15a0c1c00dae70a0a174d63949899c8dc33bea8af53601f8f0475511e418eb1995f4ddab4031f3d33b37c22a8f79c7dc3740f71112176065dfa59906f540608fe88fb2d40b53837d256785d58274985aa60e7740c0c9835e8d97f746d65ac1658c4c2377d472db4c200d99d4e38ed1bc5ad9502b76d079c25f0c25d44c5e11ed6b91bfeffcec5417cc10cedb54def705f7b2eaa9b7726f22485cffe9fc98d19b85266654ea654969aba2493ba7ec463a21957764aaf94d18258290a9b1ec6693d4bf5f86ca52a65934b4aa629dc6be2fb977b7565b7df0c139d49cbd493d0b122fc91511bfa58c4e2f4d74342d2fc0fae50649545741eb0521fc87d73925f998144f982994c1c11005e63c949d023555d7ced3f0077301eae810a3cab29f0077e72b3988b07a98b32108746f4ad261a7a0c930968aa6c9cbf5386ada8e0fe0da6bf3d45c812a490fac1935101dc051dd114a36ffa5f01ea54901562ab0428768d5ddba1ed41fe0bda1fa87b9a6b988018b0d9215a60ef4b5975a4d0f925ee1639e345192a5dce27223dfaf6af869df491582469015da71b901479b025cf2ff13514af7942073e31eb9d028a1eb2c1f07e4ca55d1418e5e07287add6450452e38d8a120cdcca68df29b205c72938173f5f25184e0b4eea4f4d1153fe62946bdfbee0bd23a15e58d53ac30322837abd1ad4d99700758e6138006ea81b1ca4c05f51bf659096eae5cad02ec0d69f524e07693a8fa8073f412e51c8928271685bf69695e11c925963a63126af5f1342c15d321bf21977045922a8f4c8ca8b7c8403c5d082e65c86c9d91ffefb0ba4c35f912320af1be9ae92b0c381d6f8191bcd1e48cd183195848e1a0ec323c0f5722cb999335d335c9b1cad6d360e2bb8a5e16d5218ed52f31fa244f9f5e5ba2f2e59326424babf70c2690a1a42c4a566440c795940b35ce13e3d589e24b1131102bddaf5a6d1a6f3b6f0d52ae1349e4038c0abeefe700871bd558bb07404ae9ab655710c596dd1561184056e187ebd8af48644894861e942a2d08094fd8299a40c478c119b09a830486dbc30902a14c81f3cbf539c6414b5a7ea93cf7c00233d2c8ed56a3e9f01b6d7a3119daa622fa4ddd19bf36015f64a0773010860fd3554a77a01073bc9e516ecc6324d201e2a62a64d1a4cd5f7e60617ef856f704fbedec97c68eeae3f1a4e949b5bb4ab4f6da1e4f5c5fdc15916231dae0c221a05548bdb875d2a484e876d93cfc2b114ba0ec81d63faf6e6626c5c821964d73ec71edb86e8ac6733f83917c84276eaeee9666034ebd6b90061e8a850312458e3a866d05b941b6d3857a7a1ac196fd6149a2a470f7e66404c49d1b98b32b38d9b2c9637777fb27ab38979b34c787080acfe909491ca1a52f759afce3575a9268084c31e7647be653bb451655361703998a21cd4d37543ef98c071849c901254485492e5c11b8e484b0286f67ca18d91f9697c6a1756a236f53d646bd5db7fe678c49981a2418a2ddef245f3a6b2927af09526861cc30b91081f38ab9d030876e453a6c2ce456eb3e21d33f39699e3d0da0589e8ea9fed8f43b68c6d7553e30ccfa9abb99f6aa94e4703124319b27a8a76eceaf090d00ae3342dc07941b1828f6ba0bd7980c8a3ede7b2efb8e1ca659ee44055563ad45188613741ff5a7661549a281a336df66dc81de8c5736a71059c51655eae109dcc828fbaa6035e78ba3384016564f00461767a53f553f37c891fe99e62b806cfd81b049dd4415e621094344e60f5e17f0e8649526c3c8360f6a61c692b203bb71fe13477acd3217b280b5c38b770c1ca58e2a4f5af4d46b0fe7a2398e4ba721dca4525e2676b0908fb1e8a1e652df06394d6f8bcf70639e20aa29660735d6a17b75d8b576d19a419af598d8600f6bcb670f3e1fe15fed822527b6c346a6be7c0aeef1130491c862fb271d9cdb1e64db5bc394859dac4c039f148d3c91f285692954ca3bebe230ce09faacd3d8b6106b54484916a22b64d7df1109de4fb2ec6e31863eac1eee5bd7f90d3160c206b78d0e391e39fc85673b3122e5f0662a73d633b7657ca52ce480c992a2056e440eaedc5b55e7a5b60998089be8a7986a86bb4d56c0ffa3f91c87b97454469f2394b5d30819ac1c5d481702367a9b8e3d301fa5c55d6a9ffda939dc9f65263cd25d7094f197bf777152de2d4a8cc679b06a133e86e5fe956c9de7e4c39624b4ef08461fdfae9ec94393eaca690934debbef01f9e5a76c5c9c9766f6154af5d1c1b2aa45797f342cbd127e513c8f868fa57af7b0004d2fb47cd283d4c8c8cfa551b2bf2b440137022e3f39b8dd22b694dd5c7381e6fca9882175135a6d95ff5427b20e8f73a68f711b3cf2daac06dc91eba1c92b69252e9fcf9a48fe271f5eabb972273010cac5dd80966cc4233a612ea91c0ec6d04d3008a32694ca0f1e41ddeebf3c1f44e82be930dfae3bcf79ae0321e078c7eade303ad7e58983cd485163629985eb20d595af2b55cce780d6f2e65e374def5664aafc690743d0eae89d4d62d2778214a0d0955ab58aceb57d335c7bb0f6836b29b0ed5a32cc20dd3784501eb950908f888e8d369ad5e68f6c685a1315f6d2821eedf17a8e9d8d604a058484d6ba69bb8cb3055f1329376225e9a648e10f6e42917f0e1ee9e456d5e7ecc158746fe98dd4bafea5f7e46eec9906210901bfaede5181775d395a70893681f822c051bcdca771eaa33b409876c1e8bc1d13895956b8a00ccaa453388c6fccca003e8899b6955d8d663143933424045f3ab017c75295df773d93e6850de49c6bb46d3efa411b5bff1618a211f611ec9b611ce7d653300197629e5d1adddc2d5264481c2943e7efcf4baa6c1d298cce2e6df51ae568e735312750d9620612f13775cac0c67f27643b857271515af21b06b88f973cfc44ad82a2a1e2250486b44c3c0605dd9d3846a00edc20fb8fd6264783b90c82a3823b1a0577ff17cabd2e99e0e57824d58b955235c03e2f7838707b659c562bc5e8e86d5e457e82888f6f16c9adf26d585f9b2c8d70c69cfb9f366f783c1443b48f1dac3a6b6fe07b985f2152e7dca09675a0bb65b0b33190316916c1dc73222ec947fe92242a95bdc47e8d266c2bcec9c0c54cf3fb09d27b22958331ee90a957340dabf0c13a2d86b592edf76ed32b37899815f8315771d494737b8d2936022f7ceed0c33434a0e083ec73a0d738394231ad21aa0c2863f3a59879be6273c15a76030727819c5c02b64a060e91ccc6b0eb33432cdead5250b486bc111483dfd18c55ae9222525c6b64e42f006e3c99223131f484d29a557b0d430912a5fd49109240383e35b5121660554b569d798a8206bf46fd06bc6afe5657e1610d45332cad16538440ccb6e1921b6257f597469b26ec835022d2f9a29f329f7c8d8fdbb0c65e215d723a516d5ad1b5565485a1cedac5ab89632d5397185d03ecd4165e470fcc7fce41798c74c6179ca9405d5d6e27dd6bd4a904fc04aa54345a6a5c6cdb3c0a66f515fce8bd5e8ef2c76d104d263ef8c0dae9cc8a608087d52b20af7c8e1bef3f93e5863318a244e5ea77261be949eb04fd4db770256cfec732bd7bdc5ee2e8efb74cf4afe0734a13ebcce78581855c47bfe12c1af514165d481f62fa7eb2982592c3fa6b7218d9d77158f5871a3855e3e25d88be9a0d9a9e3c8bc9fce42e40cd254889019a6df48fc413b0c00e28369d279c188b642ee773ba7cd3f8cf933320da6dfd18a3c56afb964765de0eedb820f820cdeec2ff482ab1712b8f8387d3f3a6a692a9e494f8bd80578798340858ab7a710caff233fa7f5f70716f10c25a131a577210dfd860955e1629348eba7fb7a5566423d940114257ec9292d301b6f385a4fc000900e246aa3056061015cc2367c99e24d76fce0c078ceb3f1e913485ba326fe66454e480a91821cd664359675b77110ac095e33c035f79dd26996ef6254861c3939a421f24e49a314233aff1583607550df5c4fb8a86d0b9e0e28e3bccfdaea378b0ac28677dbf155a90510aa92bf4ccb481c632a5f98e64b77a3d5aaab7acc03c05e0ef139f1b3737bae60ac2d88b121c32f4ba0b25f25e0b605a06dd14cdc933ec228b8d18fd1172c4cbc6f1f96e2a7769849e6b51b4628980053b9c057194f156a4460e873b28c0f7ca7c52ecf571f0f52fdcbbbe728bb486e1d979ca10233439daa598e5977f85179d233431bbec19820fbba5376d5b604df3d4ee33f4528dee9ceaa80aba108cf409a1a6b5c4cbb1c8cc09d2b2fb0947003bc6a4d644852dd5eeb1214075d06dc008a00557e5f77e1b2ec719562d5afc16cf6c2e8c0e5c5aa54e407c621048cf59653fe674adb6de2b9f5c78c0ccf27b2a2b8637011634cc4568d73e11eea11e29b96b495cd1aa961f27305b9e24cc5bdd1ae5cd89223420285c949c3df8f90acf1f5ea17b57df1823bad3427bd0909a1ae22f6302d770eca9e4672fc97a54c2de19077649df7da039b9331017cd9630d28f6865b16cf0f6ae0fd79a5e481f0816c795b2c1995fd4cdfb0bbf5a0554904c63b8fcab770accdb7dfcedfefdd256f176b00218417c114e1e5c0ba98a68a3e2efcefafe90698f670dd4d6cffdafdcf022fbf8d7bd9c4e67bae614bb95631e9d2e1072aec39ec6bd9b92d67b44e752ea6c3825e6e6fb9a2ff115cb3c6a1a2fc3b213135c689558a113dec3c351b77e3b4f7298bbe803a9d06fb6838ec0f25eaba07ca4628d5044329e5434a8ca6ce7c19c7566a0553bdfb4fbb747325057e746309201f7bde636bead9cc8402d65316580de28f27fe32432d99741a1314df9bd100367762f784ab5641a67e8fa9eefcce9449456b17e3de675305c401e7b7333b85cd07aa5e8b80b656fd5ebcaa1ee32c9823965d6b947c6daee2d9c98f5abc2187763d6615193efb1c913d827b918b440e2b53a3d841d157457a36cf37705d31d41737613c0d9ccf0a76bc8e10d6121e38f930894307a37cdb580f75489728c3e175a5cece50e8bc8591a453b9ba7ee1bea8be2ebcb23f6327bc0f3cd81b014f98ca1575725501a738f17290624d033a615447a3b8526d334db858c0ddd30b4111d2febda756a90f2be73b05407abdce39ed767d313c77a1197cbd8afb38aca55946d259e52b554e6c4dd33877ada68260ddc31c6289728d8cb9595f49ba9c8358840eca8f7c8edc46da4deaaf951df2baad183ba335316c9ef5f04488034318d429742bbe806ab91384dc3ddfaa52a751224d08c02993c5140b0ad58fe880e5c156a129b7cdea9d69730e498bd806023a461a05253d44e3bf2f5e766938a66347179b2acc3492f00cc7f41cc86ecdc6e2a50b5b41c75672844ce3a05058bf76f1b8240125c6b4ce621ea6a72fa3a03d4ecdbc1a3dba7c44e4e983fd25782d0d64ce1f5cac537dae2be9e612bc18211ffbce23f0cc3d4bdb7f5f33acc855279af1441b216a86bb8e80f3f8f5e2023506110bd199c3f4e137c39bc5e7db807ad1a15543f47956ff2e0c5605e518f1e14acd9869d7b085db90d78fa2fc269b0cc0a38f62bbdd0f93d2c6aed11113b6c24afc3526ee5ed63d010b5111b4cc28a53cbba676030f7f7078ac25c8c11b706b42b74704056907f7ecca40aa757b02a5ace28e6524080045b5240a2eb0bd914583746694b5feb156760da40ad4a62659541fa7ebe29a9721974bf9b83d9a0002146e6d7c7b9c2a6ca62634cf55c19518420b38c2463f45a24381e6e3bf2cc2d99b5bd41ec345d515b699af336e23f7738eb42529e8d21a143c6059d32c6e671bd5911655699d0e908d39c0371b5a3db694fbbe4e8ce9133eb8f1bff44eb70549c91e9d0d99f894c62358a79b220adb71b1befc26d18c27cffb913424345f87423636d15b5a2ae919453701d1320f374ef980349bee2f955c42be29a076c686d0d269eaeb73445d356dbb6d5230da3a8f40e8591c1952761af0cf0ce9b6043b75bed85cf583a7b4e5fde4675b44625d7e5ac86c6d71627df977d7eb9c531be8858383daac5a355a0dd0f1829c5c2f5221adb2bcf46d123a1ae676fedb1566614bd6a178f01c22e1729f1158c5524b9b3005ff646000f88a7031064295f4290b49779bc60f76d2827dcd9527d6d00200ce1a95ea146925c90f1900bae1e072c7883599b500ede0d77a0ce702f95aa356f82c25cd227bed0a0b0f0ff38443f9d227c6b98eeb29d90a7ccb0cadf1e501a51d4fb6704a6e67ab9d66a27739a8cb153f392048b58f9e7e4293fac41591610ea0e5b55da260b8ff11d63e1e0172d7f90ce7e03e6412842d75ee589ac2debee4f27d95b4cc0397f14c2cec6b6e72280772ee836fdd95dd22aa703d6a3eb144983cd5c3aafa4437716fdc0984417175233d54a04065233da203948fe7919f18cd86a1fd233b64565b2578a94a42a0636e8735ce86dcd6ff3979814c09e8a02bb9fb402c718dd5a6e4a7aa443bf5fa627f661ded0b979fa457cc64c258ec842e0b4b4436a19a31e464881027d6f19cd67cca1dc79594696410f1f9a2e9b0790653cf4cbf69552c13ef1faaa4d007639c63fdaa35083bd4d75e43c070c4e871f09f194fd8f290083530395e2438211a72630c19148fb9ad82cfba330d685ff5123e9a2e67bb8041a1fe5d1597d7fbcdb1cdbd812a40f26259a8da32965e102200b102a18e035e93ace7f5b5ed65bf1fc70db165209f362c7facf57dd05fe0552878c72c4d2547d551f73b0cbc36ae3115db335e3db3ad9a644df2f1a17e2d596ed91fa4919330d631980576d318bd771393a114356f97538ea186ab1d3de42ee2b56ad565bcc809f9e7454b856c199b78b60febefce8b2bac6f4352f992692ef1fec01e2e4b663051f27102c8083b71283647de8f0683e250c9f15bcaa99703d533001f34d4af8f10b3242656b84cbff750abf2d1cfcd096d3ccfbb504ce62339e1774f5c4fcfd5299964c2a1131296516e25b54fe7b3b5fb9358d2d1a93aeadc889106553237611c5a741ba211e1f4e0156ab12f0ff03acf111fd46d6408b2144e71728eb980663de68ad24a9d16d7d32399332ac11cf691c9a6a2821929c3e3a63d873586790ee9282746dde3843e1e259cacf570a61d9767490da4c918a90be6c995ce020f6c729c0aec36d6693ebfcff975801d2bf92fe329cfef2e52c6b5d2807cb2ddd4cb7e05421e3001e40aa5b3226bb80fcf79f6b59ef2cacc65d548539a58b9b9acd707fca05a93b5b2c9efe47684e4c5c167682bb8f055b10303e4a7688de0b4f849b654958e6b3098fd54bdd83b311641f6c72c03838b95c6bac27da590e14e359813d6471c297827a3c2bb4651bcb20b303c0c05700dc223c8cd1d059413f50568f9857551212c7213f47630a9a0ad128cda50809b452c1db340f26d02f0e2e1c65c5fecb1aba1175f00a2d553882bab47d6e6a627fb7a4c846c844842b0e49fe5a40ba69ef5da9c6925489a87d65078ad44b4bee204bdc4501c37230d8aeaf5386d16adf4222dac67537cb750fc9640cf713333e1a9bb83a01c6316ad8f6a9a1c5994fdb7e91ac04318e7d3af167aa5c0fa0822905ab60967677f9677a6845aa8b8b394963a254271cd252610cb276ce0cd9ca2e0a43ce2b3d6683a5eb959da01fd812fa6ab36d9a919e08abf5031e9001a08be22d2ddf9e49d156978b9a6e78f1154e1a9990bff20f1ade506035f0622c3a0c9e36c49c0fcfda35e872a1a00426814cdadba1905cccf1d2bcf17a407177c36e164f80cc33d67f5f365b04029a41199c640a63ff0dcfcb8feff3a22ea187b6993e0a5ee3373cec01c42ed6a5736b84a91a97b5c63985737b661ebfa53d17732de6162672fc110aab08aa49f3482e53832696f75cbd3cf4f9890534d3c3569d9cd1264a1d0801ba74dfa24279c0e5d6e7b611fe6e33ac34a43de1bf5aac8829edb377770c5f435e640c8fe7f169b695281e261bf89635ae6634db65e27cd88431e6aeb165faae09bc00e7b9ee088d2ab6fe26a5870d3b75a10195a8ace87e5c784b3613a94a0aefb3913db64e03a41afa9aca1a9902f1f33f1a8e1476189b34886d88109d99422813ea04 您好, 这里需要密码. 解锁后请刷新页面以保证文章能被正常加载","link":"/2024-icpc-%E6%B2%88%E9%98%B3%E6%B8%B8%E8%AE%B0/"},{"title":"2024 ICPC 全国邀请赛（昆明）打铁记","text":"耻辱打铁，狠狠反思 这场是 sua 出题，赛前 vp 过的 2023 GDCPC 也是 sua 出题。从这两场的对比中，我们可以发现一些问题。 23 gdcpc vp 情况： 赛时 5 （745），换算过来排名 85 / 237 (= 35.8 %)，铜牌区前列。ACDIK 过了，E 赛时正解思路，B 赛时错误方向 24 icpc 邀请赛 昆明情况： 赛时 4 (486)，排名 172 / 256 (= 67.2 %), 铁牌区前列，ABGI 通过，M 赛时正解思路，E 赛时错误思路 upd 2024/6/14: 水群的时候听说 E 题数据水过了一堆假算法。。。。。。。 Day 0 2024/5/24中午去一期的时候遇到正在出发的 GY，但是下午还有节 EAP 有 vocabulary quiz 不得不去 Day 1 2024/5/25珠海下巨大暴雨，到广州的时候鞋子袜子湿完了，但是广州是大晴天。然后在白云机场复习 Devlopmental Psychology。 Day 2 2024/5/26E 题Code","link":"/2024-icpc-%E5%85%A8%E5%9B%BD%E9%82%80%E8%AF%B7%E8%B5%9B%EF%BC%88%E6%98%86%E6%98%8E%EF%BC%89%E6%89%93%E9%93%81%E8%AE%B0/"},{"title":"Codeforces Global Round 26","text":"比赛链接 Problems AC A. Strange Splitting ○ B. Large Addition ○ C1. Magnitude (Easy Version) ○ C2. Magnitude (Hard Version) ○ D. ‘’a’’ String Problem ○ E. Shuffle F. Reconstruction A 将已经排序的数组元素红蓝染色，使得两种颜色均有，且红色数组的极差不等于蓝色数组的极差，或报告这不可能。保证数组元素数量至少有 $3$ 个。 将第二个染成红色，其余蓝色即可。 Code B 问：正整数 $x$ 是否是两个满足以下条件的数的和： 两数位数相同 两数均仅由 $5,6,7,8,9$ 组成 最后一位不能是 $9$，第一位只能是 $1$，中间不能是 $0$ Code C1 给定长度为 $n$ 的数组 $a$，进行以下流程，有整数 $c = 0$，枚举 $1, 2, \\cdots, n$，每次可选择： $c \\leftarrow c + a_i$ $c \\leftarrow \\mid{c + a_i}\\mid$求 $c$ 的最大值 只需要记录 $c$ 的最小值和最大值即可。只有可能从这两个中转移。 Code C2 对于 C1 的问题，求取得最大值的方案数。 直接 dp 即可。 Code D 给定一个由小写拉丁字符组成的字符串 $s$ 。计算非空字符串 $t \\neq$ “ $\\texttt{a}$ ” 的数量，以便可以将 $s$ 划分 $^{\\dagger}$ 为满足以下条件的子字符串： 每个子字符串等于 $t$ 或 “ $\\texttt{a}$ ”，并且 至少一个子字符串等于 $t$ 。 $^{\\dagger}$ 字符串 $s$ 的划分是一些 $k$ 字符串 $t _ 1, t _ 2, \\ldots, t _ k$ (称为子字符串)的有序序列，例如 $t _ 1 + t _ 2 + \\ldots + t _ k = s$ ，其中 $+$ 表示连接操作。 对于 $s$ 中的非 $\\texttt{a}$ 字符数量一定是 $t$ 中的非 $\\texttt{a}$ 字符数量的整数倍。 质因数分解，然后从每一个非 $\\texttt{a}$ 字符段的起点开始枚举。 考虑 $t$ 的最终形式左右都可以拼上一些数量的 $\\texttt{a}$。假设左边有 $x$ 个，右边有 $y$ 个。 我们遍历 $s$，假设在 $s$ 中出现的每一段 $t$ 左边有 $A_i$ 个，右边有 $B_i$ 个 $\\texttt{a}$ 字符。 我们应该需要满足： $$0 \\leq x \\leq \\min{A_i}$$ $$0 \\leq y \\leq \\min{B_i}$$ $$0 \\leq x + y \\leq \\min\\left{A_{i + 1} - B_{i}\\right}$$ Code E 两只饥饿的小熊猫，奥斯卡和露拉，有一棵有 $n$ 个节点的树 $T$。他们愿意对整个树 $T$ 执行以下 Shuffle Procedure 一次。通过这个 Shuffle Procedure，他们将用旧树的节点创建一棵新树。 从原始树 $T$ 中选择任意节点 $V$。创建一棵以 $V$ 为根的新树 $T_2$。 从 $T$ 中移除节点 $V$，使得原始树被分割成一个或多个子树（如果 $V$ 是 $T$ 中唯一的节点，则为零个子树）。 对每个子树执行相同的 Shuffle Procedure（再次选择任意节点作为根），然后将所有 Shuffle 后的子树的根节点重新连接到 $V$，完成构建 $T_2$。 在此之后，奥斯卡和露拉得到一棵新树 $T_2$。它们只能吃树叶，并且非常饥饿，所以请找出通过一次 Shuffle 后可以创建的树中叶子的最大数量。 注意，叶子是所有度为 $1$ 的节点。因此，如果根节点只有一个子节点，它也可以被视为叶子。 观察一下。 想象一个“人”字形状的树，我们选择中间那个点可以让叶子变得最多。那么对于一个不相邻的点集，可以通过操作让他们全部变成叶子吗？我们只需要找到 不在点集里面 而且 和点集里的点相邻 的点 进行操作，就能让他们全部变成叶子。那么答案就是求一个树上的最大的点集，满足点集里面的点互不相邻。 但是结合样例 1，会发现答案并不是最大独立集。原因出在什么地方呢？因为在样例 1 中，我们将 3 作为根，但 3 本身是个叶子结点，所以答案会 +1。也就是说我们要做的就是每次枚举一个点删去，在剩下的点中跑最大独立集，然后如果删去的那个点是叶子的话答案就要 +1。 Code","link":"/codeforces-global-round-26/"},{"title":"2023 CCPC 深圳游记","text":"b0912037589f211b8f44b9d5e6d4bde9921254f8cd2db87c59b08a373a241aa1 您好, 这里需要密码. 解锁后请刷新页面以保证文章能被正常加载","link":"/2023-ccpc-%E6%B7%B1%E5%9C%B3%E6%B8%B8%E8%AE%B0/"},{"title":"2024第十五届蓝桥杯省赛游记","text":"上次 ccpc 深圳的时候曾口出狂言（我要写游记），这次决定不能再鸽游记了 唉，OI 赛制，熟悉又陌生的感觉。 可是，再也回不到过去了。 Day -1考试前夜Tony102 给新生讲基础 DP，让我给新生分享下参赛经验 我一个 OI Loser 怎么会知道篮球杯的参赛经验呢 趁 Tony102 讲课的时候，把上次给高中生讲考前经验分享的课件改了改 备课备着备着越来越觉得篮球杯是一个 屑 比赛，OI 赛制连大样例都没有（我不会又是因为什么奇奇怪怪的原因 Boom 吧 小插曲Tony102 的堂客来探班了，给我们小群每个人都点了杯古茗柠檬百香果真好喝😋，感谢 Tony102 和他的堂客 讲完课去校门口的小吃摊开始狂吃，回寝被室友打呼噜折磨 睡前 Stanford Dr.Guan: @rabbitdit @Tosaka 明天早上一起去吧，7:40 那班车 Day 0早晨7:20 痛苦起床，上校巴后环视了一下没有看到 关教授 和 小齐（内心 os：他们不会睡过头了吧 到一期了过一会 唐暖 来了，发现就我和唐暖，于是在门口陆陆续续等了快半个小时（这下早知道坐 8:10 的车过来了 骑车去北师珠，早饭吃了麦麦。不得不说，麦当劳的早餐从性价比和种类多样性上面真是薄纱 KFC。什么时候我校才能引进麦当劳啊（恼） 然而我们一行人中只有 王少 打过蓝桥杯，知道 北师珠的木铎楼 怎么走（实际上王少带着我们在北师珠进行记忆化搜索 fun fact: 关教授骑车过来的时候摔到北师珠的草丛里了，获得了【草的祝福】，拥有了能暴力嗯草过题的能力 Update 2024/11/16 Tony102: 建议补上关教授没有return 0;并喜提爆0的Fun fact Fun fact: 在篮球杯中，Guanyue1234 因为没有在 main 函数中 return 0，喜提爆 0。并没有嗯草过题。 这警示我们，一定要遵守代码规范。 赛时诶怎么我到点了还不能下载压缩包，都发解压密码了。遂举手而问之，得到的回答是电脑机器都快了几分钟 开场，什么填空题，不看直接跳（伏笔） C 题，一看诶怎么不是无敌傻逼题。写了一下过了。 D 题，感觉很麻烦，不太可做的样子，跳了，有点汗流浃背了 （&lt;censored&gt;没仔细看数据范围，赛后同学告诉我这个题每个点颜色都保证互不相同，直接开个 map 搜就行了。这下人麻了。） 写了个 hash 乱搞，希望能多点分 E 题，一眼发现题面方差的公式错了，然后信心满满推了下柿子，结果发现卧槽怎么不好做，冷静一下，发现柿子有个地方拆和式写错了。 然后就是按值域排序，维护一下检查滑动窗口是否合法，合法的话就是个区间最大值，考场不想写 st 表，写了个线段树就切了 F 题，一眼容斥，可惜我是容斥垃圾，写了个 n^4 跑路 G 题，转化了一下题面，就是树上的区间本质不同颜色数量，维护个 las 的话就是求区间 las &gt;= k 的 las 数量，然后汗流浃背了，好几年没写过主席树忘了怎么写了。 后来突然看到了 颜色数量只有 20 个，就开了 20 个前缀和数组搞了下就过了。 值得一提，我的树剖实在抽象。曾经的树人已经枯萎！ 写两个 dfs 里的东西的时候感觉是刻在 dna 里的操作 写在重链上面跳的时候写的巨无敌抽象（希望不要像 NOIP 一样把代码放出来，不然就《贻笑大方》了 这时候返回去写了两个两个填空题，跳转到 A 题题面。日期计算 –– 心跳骤停。那一刻我 julian.cpp PTSD 要犯了（） H 题时间来不及写了个暴力，感觉加个 set 或者 pq 可以乱搞多点分 赛后因为我校就我是 a 组，所以无法参与讨论。听了下 b 组的题，怎么感觉比 a 组还难（ 赛后在北师珠吃了家 纸包鱼 的店（就在麦麦旁边，每次来北师珠都看到这家店，一直没来吃过 点了锅蛙 和 鱼（并不怎么够吃）（7 个人疯狂抢食） 因为关教授摔伤了不能骑车，所以在午后大热天走路回 uic。 关教授在回 uic 以后进入了一个导昏了的状态（） 后来和小齐在关教授的办公室里面昏睡了一会，去调试了一下天梯赛的设备。 后记2024/11/16 Update：","link":"/2024%E7%AC%AC%E5%8D%81%E4%BA%94%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%81%E8%B5%9B%E6%B8%B8%E8%AE%B0/"},{"title":"2018 学车校赛 游记","text":"2024/08/07: 搬点旧博客的唐氏游记回来 省流：TXMMQQW，MZGGZYB。ZZY 神速阿克。 Day -1第一次参加 ACM 赛制的比赛，队友是初三已经进学车的 MZGG 和 初三马上进杭高的 LZM 有点小激动，打了几个数据结构板子 Day 0起床发现下雪了，是杭州今年的初雪 在家吃完午饭打车到校门口后另外两位队友还没来 在保安室冻了 15 min，队友来了后被已经在学车待了很久的 MZGG 直接轻车熟路带去机房签到了 环境都是 Ubuntu，忘了看配置（） 这电脑还可以折叠到桌子下面，真神奇（后来用了三年发现真是傻逼设计） 自带 vscode 还是很舒服的，但坐下来后发现很多人不会直接用命令行 g++ 编译（？？？ 坐下来后发现左边的对面就是 Samsara-Karma 他们队，膜拜 在离结束几个小时的时候 Samsara-Karma 他们队就 AK 离场了 还有半个小时就要结束了，感觉剩下都是不可做题，雪越下越大我们就提前离场了 坐 MZGG 家的车回滨江了，去天街逛了逛，然后决定走回 MZGG 家吃外卖（） 路上疯狂玩雪打雪仗，去 MZGG 家以后就是各种 [数据删除] TXMZQQW MZGGZYB。","link":"/2018-%E5%AD%A6%E8%BD%A6%E6%A0%A1%E8%B5%9B-%E6%B8%B8%E8%AE%B0/"},{"title":"Codeforces Global Round 28","text":"比赛链接 Problems AC Note A. Kevin and Combination Lock ○ B. Kevin and Permutation ○ C. Kevin and Binary Strings ○ D. Kevin and Competition Memories ○ E. Kevin and Bipartite Graph ⊕ 二分图、构造 F. Kevin and Math Class ⊕ 笛卡尔树、树形 DP G. Kevin and Matrices H. Kevin and Strange Operation I1. Kevin and Puzzle (Easy Version) I2. Kevin and Puzzle (Hard Version) A直接蜘蛛感应出做法了，懒得证了。 Code >folded12345678void solve() { int n = read(); if (n % 33 == 0) { puts(&quot;YES&quot;); } else { puts(&quot;NO&quot;); }} B最优一定是间隔放置，很典 Code >folded1234567891011121314151617void solve() { int n = read(); int k = read(); vector&lt;int&gt; a(n + 1); int cnt = 1; for (int i = k; i &lt;= n; i += k) { a[i] = cnt++; } for (int i = 1; i &lt;= n; i++) { if (!a[i]) a[i] = cnt++; } for (int i = 1; i &lt;= n; i++) { cout &lt;&lt; a[i] &lt;&lt; &quot; \\n&quot;[i == n]; }} C赛时做法是把所有字符串扔到 Trie 里面，然后在 Trie 上面 dfs，似乎是写复杂了 Code >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849void solve() { string s; cin &gt;&gt; s; int n = s.size(); int p = -1; for (int i = 1; i &lt; n; i++) { if (s[i] == '0') { p = i; break; } } if (p == -1) { cout &lt;&lt; &quot;1 1 1 &quot; &lt;&lt; n &lt;&lt; '\\n'; return; } int len = n - 1 - p + 1; int nod = 0; std::unordered_map&lt;int, int&gt; ch[2], info; pii ans; for (int i = 0; i + len - 1 &lt; n; i++) { int cur = 0; for (int j = i; j &lt;= i + len - 1; j++) { int x = s[j] - '0'; if (!ch[x][cur]) { ch[x][cur] = ++nod; } // assert(cur &lt; ch.size()); cur = ch[x][cur]; } info[cur] = i + 1; } int cur = 0; for (int i = p; i &lt; n; i++) { int x = s[i] - '0'; if (ch[x ^ 1][cur]) { cur = ch[x ^ 1][cur]; } else { cur = ch[x][cur]; } } cout &lt;&lt; &quot;1 &quot; &lt;&lt; n &lt;&lt; ' '; cout &lt;&lt; info[cur] &lt;&lt; ' ' &lt;&lt; (info[cur] + len - 1) &lt;&lt; '\\n';} D随便写写就过了。 Code >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960void solve() { int n = read(); int m = read(); vector&lt;int&gt; a(n + 1); vector&lt;int&gt; b(m + 1); for (int i = 1; i &lt;= n; i++) a[i] = read(); std::sort(a.begin() + 2, a.end()); for (int i = 1; i &lt;= m; i++) b[i] = read(); std::sort(b.begin() + 1, b.end()); int cnt = 0; int le = 0, ri = -1; for (int i = 1; i &lt;= m; i++) { if (b[i] &lt;= a[1] or b[i] &gt; a[n]) { cnt++; } else { if (le == 0) { le = i; } ri = i; } } vector&lt;int&gt; c(m + 1); for (int i = le; i &lt;= ri; i++) { for (int L = 2, R = n; L &lt;= R; ) { int mid = L + R &gt;&gt; 1; if (a[mid] &gt;= b[i]) { c[i] = n - mid + 1; R = mid - 1; } else { L = mid + 1; } } } for (int k = 1; k &lt;= m; k++) { int tot = m / k; int tcnt = cnt; int ans = 0; int l = le, r = ri; for (int i = 1; i &lt;= tot; i++) { int need = k; int rk = 1; int tmp = min(tcnt, need); tcnt -= tmp, need -= tmp; tmp = min(need, r - l + 1); r -= tmp, need -= tmp; if (r + 1 &lt;= m) rk = 1 + c[r + 1]; ans += rk; } cout &lt;&lt; ans &lt;&lt; &quot; \\n&quot;[k == m]; }} E 一个完全二分图，左部有 $2n$ 个点，右部有 $m$ 个点，给每个边染上 $[1,n]$ 的颜色，使得没有同色简单环。 唉又被构造单杀了。前几天刚 VP 完 2022 ICPC 澳门，这个题关键点和那个差不多，都是算边数限制的。 由 $2nm \\le n(2n + m - 1)$ 得 $m \\le 2n - 1$。 $m$ 越大时限制越紧，尝试构造 $m = 2n - 1$ 的解。 此时每个右部点度数是 $2n$，一共有 $n$ 中颜色，令每种颜色的边恰好 $2$ 条。那么对于每个颜色，就相当于通过这个右部点，使两个左部点连通。最后经过 $m = 2n - 1$ 次连接，左部点需要形成树。可以让左边直接形成一条链，每次 shift 一下颜色即可。 在这种情况下，边 $(i, j)$ 的颜色为 $\\lfloor \\frac{(i + j) \\bmod 2n}{2} \\rfloor + 1$ Code >folded1234567891011121314151617void solve() { int n = read(); int m = read(); if (m &gt;= n * 2) { puts(&quot;NO&quot;); return; } puts(&quot;YES&quot;); for (int i = 1; i &lt;= 2 * n; i++) { for (int j = 1; j &lt;= m; j++) { int t = (i + j) % (2 * n) / 2 + 1; cout &lt;&lt; t &lt;&lt; &quot; \\n&quot;[j == m]; } }} F Kevin 是 Eversleeping Town 的一名学生，目前正在上数学课，老师正在给他布置除法练习。 黑板上写着两行正整数，每行包含 $ n $ 个数字。第一行是 $ a _ 1, a _ 2, \\ldots, a _ n $ ，第二行是 $ b _ 1, b _ 2, \\ldots, b _ n $ 。 对于每个除法练习，Kevin 可以选择任意段 $ [l, r] $ ，并在 $ b _ l, b _ {l+1}, \\ldots, b _ r $ 中找到最小值 $ x $ 。然后，他将 $ l \\leq i \\leq r $ 中的每个 $ a _ i $ 修改为 $ a _ i $ 除以 $ x $ 的上限。 正式来说，他选择了两个整数 $ 1 \\leq l \\leq r \\leq n $ ，设置了 $ x = \\min _ {l \\leq i \\leq r} b _ i $ ，并将所有 $ a _ i $ 中的 $ l \\leq i \\leq r $ 更改为 $ \\lceil \\frac{a _ i}{x} \\rceil $ 。 当所有 $ a _ i $ 都变为 $ 1 $ 时，Kevin 就可以下课回家了。他很想离开，想知道实现这一目标所需的最少除法练习次数。 前两天 VP icpc 杭州刚做过类似的。首先显然你要搞个笛卡尔树，考虑在笛卡尔树上面 DP。 令 $f(u, i)$ 代表 $u$ 这个点操作 $i$ 次后，区间内的 $a$ 的最大值最小是多少。 因为 $b \\ge 2$，所以最多 $\\log$ 次操作。那么应该可以类似树形背包，枚举左右子树选了多少个，然后做合并。 然而这道题卡 2log。观察发现 $f(u, i)$ 是单调不增的。因此做 $\\min - \\max$ 卷积等价于对两个序列做归并排序。那么就是一只 log 了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const int K = 61;int ceil_div(int x, int y) { return x / y + (x % y != 0); }void solve() { int n = read(); vector&lt;int&gt; a(n), b(n); for (auto &amp;x : a) x = read(); for (auto &amp;x : b) x = read(); vector&lt;int&gt; lc(n, n), rc(n, n); vector&lt;int&gt; stk; for (int i = 0; i &lt; n; i++) { while (!stk.empty() and b[i] &lt; b[stk.back()]) { rc[stk.back()] = lc[i]; lc[i] = stk.back(); stk.pop_back(); } stk.eb(i); } while (stk.size() &gt; 1) { int x = stk.back(); stk.pop_back(); rc[stk.back()] = x; } vector&lt;std::array&lt;int, K&gt;&gt; dp(n + 1); auto dfs = [&amp;](this auto &amp;&amp;self, int x, int l, int r) { if (x == n) return; self(lc[x], l, x); self(rc[x], x + 1, r); auto &amp;L = dp[lc[x]]; auto &amp;R = dp[rc[x]]; auto &amp;f = dp[x]; int i = 0, j = 0; f[0] = std::max({L[0], R[0], a[x]}); while (i + j + 1 &lt; K) { if (L[i] &gt; R[j]) { i++; } else { j++; } f[i + j] = max({L[i], R[j], a[x]}); } for (int i = 1; i &lt; K; i++) { f[i] = min(f[i], ceil_div(f[i - 1], b[x])); } }; dfs(stk[0], 0, n); auto &amp;f = dp[stk[0]]; int ans = std::find(f.begin(), f.end(), 1) - f.begin(); cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;}","link":"/codeforces-global-round-28/"},{"title":"Codeforces Round 919 (Div. 2)","text":"比赛链接 A[Codeforces 1920A] Satisfying Constraints.cpp >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;int read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 1e6 + 5;int n, a[N];void solve(){ n = read(); int max = 1e9 + 5, min = 0; std::set&lt;int&gt; s; for (int i = 1; i &lt;= n; i++) { int opt = read(), x = read(); if (opt == 1) min = std::max(min, x); else if (opt == 2) max = std::min(max, x); else s.insert(x); } int ans = max - min + 1; for (auto x : s) if (min &lt;= x and x &lt;= max) ans --; ans = std::max(ans, 0); printf(&quot;%d\\n&quot;, ans);}int main(){ // freopen(&quot;A.in&quot;, &quot;r&quot;, stdin); for (int T = read(); T--; solve()); return 0;} B给定一个全都是正整数的数组，A 玩家可以先移去最多 k 个元素，随后 B 玩家可以最多给 x 个元素加上负号。A 希望最大化数组元素之和，而 B 希望最小化数组元素之和。如果双方都以最优方式进行游戏，求游戏结束后数组元素的总和。 n &lt;= 2e5 B 的决策肯定是给最大的几个都加上负号。A 要删肯定是删大的，枚举即可 [Codeforces 1920B] Summation Game.cpp >folded123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;int read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 1e6 + 5;int n, k, x, a[N], pre[N];void solve(){ n = read(), k = read(), x = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(); std::sort(a + 1, a + 1 + n, [](int a, int b){return a &gt; b;}); for (int i = 1; i &lt;= n; i++) pre[i] = pre[i - 1] + a[i]; int ans = -1e9 + 5; for (int i = 0; i &lt;= k; i++) { int p = std::min(i + x, n); ans = std::max(ans, -(pre[p] - pre[i]) + pre[n] - pre[p]); } printf(&quot;%d\\n&quot;, ans);}int main(){ // freopen(&quot;A.in&quot;, &quot;r&quot;, stdin); for (int T = read(); T--; solve()); return 0;} C把数组切成正好 k 块，然后把每个数都 mod m，问你有多少个 k，存在 m 使得 mod m 后每一块都相同 两个数如果在模意义下相等，那他们的差必然在模意义下为 0。对这些差求 gcd 即可 check 是否存在 m。 [Codeforces 1920C] Partitioning the Array.cpp >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;numeric&gt;int read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 2e5 + 5;int n, a[N], ans;void judge(int k){ int cnt = 0, x = 0; for (int i = 1; i &lt;= k; i++) for (int j = i + k; j &lt;= n; j += k) { int val = abs(a[j] - a[j - k]); if (!val) continue; if (!x) x = val, cnt = 1; else x = std::gcd(x, val); } if (x &gt;= 2 or cnt == 0) ans++;}void solve(){ n = read(), ans = 0; for (int i = 1; i &lt;= n; i++) a[i] = read(); for (int i = 1; i * i &lt;= n; i++) if (n % i == 0) { judge(n / i); if (n / i != i) judge(i); } printf(&quot;%d\\n&quot;, ans);}int main(){#ifndef ONLINE_JUDGE freopen(&quot;C.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;} D给定一个空数组，两种操作，一种是末尾 push 进去一个数，一种是把自己复制 x 次，push 到末尾 多次询问，查询任意位置 赛时嘴巴秒了，但是不会实现。做法是不断取模，往前跳。 记录每一次操作后数组的长度和数组末尾的数的位置。对于一个询问，不断二分取模即可 [Codeforces 1920D] Array Repetition.cpp >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#define int long longint read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 1e6 + 5;int las[N], dp[N];void solve(){ int n = read(), q = read(); for (int i = 0; i &lt;= n; i++) las[i] = dp[i] = 0; for (int i = 1; i &lt;= n; i++) { int opt = read(), x = read(); if (opt == 1) las[i] = x, dp[i] = dp[i - 1] + 1; else las[i] = las[i - 1], dp[i] = (x + 1) &gt; 2e18 / dp[i - 1] ? (long long)2e18 : dp[i - 1] * (x + 1); } for (int k; q--; ) { k = read(); while (1) { int pos = std::lower_bound(dp + 1, dp + 1 + n, k) - dp; if (dp[pos] == k) { std::cout &lt;&lt; las[pos] &lt;&lt; ' '; break; } if (k % dp[pos - 1] == 0) { std::cout &lt;&lt; las[pos - 1] &lt;&lt; ' '; break; } k %= dp[pos - 1]; } } puts(&quot;&quot;);}signed main(){#ifndef ONLINE_JUDGE freopen(&quot;D.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;} E>folded1","link":"/codeforces-round-919-div-2/"},{"title":"Codeforces Hello 2025","text":"比赛链接 Problems AC Note A. MEX Table ○ B. Gorilla and the Exam ○ C. Trip to the Olympiad ○ D. Gifts Order ○ 线段树 E1. Another Exercise on Graphs (Easy Version) ⊕ 二分 E2. Another Exercise on Graphs (hard version) ⊕ 并查集 F. Formation G. Secret Message H. Coffee Break ACode12345678void solve() { int n = read(); int m = read(); int ans = 0; ans += max(n, m) + 1; cout &lt;&lt; ans &lt;&lt; '\\n';} BCode12345678910111213141516171819202122232425void solve() { int n = read(); int k = read(); vector&lt;int&gt; a(n); std::map&lt;int, int&gt; mp; for (auto &amp;x : a) { x = read(); mp[x]++; } vector&lt;pii&gt; b; for (auto [x, y] : mp) { b.eb(x, y); } std::sort(b.begin(), b.end(), [&amp;](pii a, pii b) { return a.se &gt; b.se; }); int ans = b.size() - 1; while (ans &gt;= 1LL and b[ans].se &lt;= k and k &gt;= 0LL) { k -= b[ans].se; ans--; } cout &lt;&lt; ans + 1 &lt;&lt; '\\n';} CCode123456789101112131415161718192021222324252627void solve() { int l = read(); int r = read(); auto calc = [&amp;](int x, int y, int z) { return (x ^ y) + (y ^ z) + (x ^ z); }; int sum = 0; int p = 30; #define x (1LL &lt;&lt; p) while (p &gt;= 0) { if ((l &amp; x) == (r &amp; x)) { if (l &amp; x) sum += x; } else break; --p; } if (r &gt; sum + x) { cout &lt;&lt; sum + x - 1 &lt;&lt; ' ' &lt;&lt; sum + x &lt;&lt; ' ' &lt;&lt; sum + x + 1 &lt;&lt; '\\n'; } else { cout &lt;&lt; sum + x - 2 &lt;&lt; ' ' &lt;&lt; sum + x - 1 &lt;&lt; ' ' &lt;&lt; sum + x &lt;&lt; '\\n'; } } DCode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108template&lt;class Info&gt;struct SegmentTree { int n; std::vector&lt;Info&gt; info; SegmentTree() : n(0) {} SegmentTree(int n_, Info v_ = Info()) { init(n_, v_); } template&lt;class T&gt; SegmentTree(std::vector&lt;T&gt; init_) { init(init_); } void init(int n_, Info v_ = Info()) { init(std::vector(n_, v_)); } template&lt;class T&gt; void init(std::vector&lt;T&gt; init_) { n = init_.size(); info.assign(4 &lt;&lt; std::__lg(n), Info()); std::function&lt;void(int, int, int)&gt; build = [&amp;](int p, int l, int r) { if (r - l == 1) { info[p] = init_[l]; return; } int m = (l + r) / 2; build(2 * p, l, m); build(2 * p + 1, m, r); pull(p); }; build(1, 0, n); } void pull(int p) { info[p] = info[2 * p] + info[2 * p + 1]; } void modify(int p, int l, int r, int x, const Info &amp;v) { if (r - l == 1) { info[p] = v; return; } int m = (l + r) / 2; if (x &lt; m) { modify(2 * p, l, m, x, v); } else { modify(2 * p + 1, m, r, x, v); } pull(p); } void modify(int p, const Info &amp;v) { modify(1, 0, n, p, v); } Info rangeQuery(int p, int l, int r, int x, int y) { if (l &gt;= y || r &lt;= x) { return Info(); } if (l &gt;= x &amp;&amp; r &lt;= y) { return info[p]; } int m = (l + r) / 2; return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y); } Info rangeQuery(int l, int r) { return rangeQuery(1, 0, n, l, r); }};constexpr int inf = 1E9 + 1;struct Info { int cnt; int minPre; int maxPre; int minSuf; int maxSuf; int mx = -inf;};Info get(int x) { return { 1, x + 1, x - 1, x + 1, x - 1, 0 };}Info operator+(const Info &amp;a, const Info &amp;b) { return { a.cnt + b.cnt, min(a.minPre, a.cnt + b.minPre), max(a.maxPre, b.maxPre - a.cnt), min(b.minSuf, b.cnt + a.minSuf), max(b.maxSuf, a.maxSuf - b.cnt), max({a.mx, b.mx, -a.minSuf + b.maxPre + 1, a.maxSuf - b.minPre + 1}) };}void solve() { int n = read(); int m = read(); vector&lt;int&gt; a(n); for (auto &amp;x : a) x = read(); SegmentTree&lt;Info&gt; seg(n); for (int i = 0; i &lt; n; i++) { seg.modify(i, get(a[i])); } // cerr &lt;&lt; a &lt;&lt; '\\n'; cout &lt;&lt; seg.rangeQuery(0, n).mx &lt;&lt; '\\n'; for (int i = 1; i &lt;= m; i++) { int p = read() - 1, x = read(); // a[p] = x; seg.modify(p, get(x)); cout &lt;&lt; seg.rangeQuery(0, n).mx &lt;&lt; '\\n'; }} E1Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364void solve() { int n = read(); int m = read(); int q = read(); vector&lt;array&lt;int, 3&gt;&gt; edges(m); vector dp(m + 1, vector(n, vector(n, INF))); for (auto &amp;[u, v, w] : edges) { u = read() - 1; v = read() - 1; w = read(); } std::ranges::sort(edges, [&amp;](auto x, auto y) { return x[2] &lt; y[2]; }); for (int i = 0; i &lt; n; i++) { dp[0][i][i] = 0; } for (auto [u, v, w] : edges) { dp[0][u][v] = dp[0][v][u] = 1; } for (int k = 0; k &lt; n; k++) { for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { dp[0][i][j] = min(dp[0][i][j], dp[0][i][k] + dp[0][k][j]); } } } for (int p = 1; p &lt;= m; p++) { auto [u, v, _] = edges[p - 1]; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { dp[p][i][j] = min({ dp[p - 1][i][j], dp[p - 1][i][u] + dp[p - 1][v][j], dp[p - 1][i][v] + dp[p - 1][u][j] }); } } } for (int _ = 1; _ &lt;= q; _++) { int a = read() - 1; int b = read() - 1; int k = read(); int ans = m - 1; for (int lo = 0, hi = m - 1; lo &lt;= hi; ) { int mid = lo + hi &gt;&gt; 1; if (dp[mid + 1][a][b] &lt; k) { ans = mid; hi = mid - 1; } else { lo = mid + 1; } } cout &lt;&lt; edges[ans][2] &lt;&lt; &quot; \\n&quot;[_ == q]; }} E2Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677void solve() { int n = read(); int m = read(); int q = read(); DSU dsu(n); vector&lt;array&lt;int, 3&gt;&gt; edges(m); vector dp(n, vector(n, vector(n, INF))); for (auto &amp;[u, v, w] : edges) { u = read() - 1; v = read() - 1; w = read(); } std::ranges::sort(edges, [&amp;](auto x, auto y) { return x[2] &lt; y[2]; }); for (int i = 0; i &lt; n; i++) { dp[0][i][i] = 0; } for (auto [u, v, w] : edges) { dp[0][u][v] = dp[0][v][u] = 1; } for (int k = 0; k &lt; n; k++) { for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { dp[0][i][j] = min(dp[0][i][j], dp[0][i][k] + dp[0][k][j]); } } } int id = 1; vector vals(n, 0); for (int p = 1; p &lt;= m; p++) { auto [u, v, w] = edges[p - 1]; if (dsu.same(u, v)) { continue; } dsu.merge(u, v); for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { dp[id][i][j] = min({ dp[id - 1][i][j], dp[id - 1][i][u] + dp[id - 1][v][j], dp[id - 1][i][v] + dp[id - 1][u][j] }); } } vals[id] = w; id++; } for (int _ = 1; _ &lt;= q; _++) { int a = read() - 1; int b = read() - 1; int k = read(); int ans = m; for (int lo = 0, hi = n - 1; lo &lt;= hi; ) { int mid = lo + hi &gt;&gt; 1; if (dp[mid][a][b] &lt; k) { ans = mid; hi = mid - 1; } else { lo = mid + 1; } } cout &lt;&lt; vals[ans] &lt;&lt; &quot; \\n&quot;[_ == q]; }}","link":"/codeforces-hello-2025/"},{"title":"Codeforces Round 921 (Div. 2)","text":"比赛链接 A[Codeforces 1925A] We Got Everything Covered!.cpp >folded12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;int read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 1e6 + 5;int n, a[N];void solve(){ int n = read(), k = read(); for (int i = 0, j = 1; j &lt;= n * k; j++, i = (i + 1) % k) printf(&quot;%c&quot;, 'a' + i); puts(&quot;&quot;);}int main(){#ifndef ONLINE_JUDGE freopen(&quot;A.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;} B[Codeforces 1925B] A Balanced Problemset?.cpp >folded12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;// #define int long longint read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 3e5 + 5;int n, a[N];int b[N];void solve(){ int x = read(), n = read(), ans = 1; for (int i = 1; i * i &lt;= x; i++) if (x % i == 0) { if (n &lt;= x / i) ans = std::max(ans, i); if (n &lt;= i) ans = std::max(ans, x / i); } std::cout &lt;&lt; ans &lt;&lt; '\\n';}signed main(){#ifndef ONLINE_JUDGE freopen(&quot;B.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;} C在答案的构造上有一些小细节容易被坑 前面的不能乱填 [Codeforces 1925C] Did We Get Everything Covered?.cpp >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;int read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}bool buk[26];void solve(){ int n = read(), k = read(), m = read(); std::string s, ans; std::cin &gt;&gt; s; int cnt = 0, tot = 0; memset(buk, 0, sizeof buk); for (auto ch : s) { if (ans.size() == n) break; cnt += !buk[ch - 'a'], buk[ch - 'a'] = 1; if (cnt == k) cnt = 0, ans += ch, memset(buk, 0, sizeof buk); } if (ans.size() == n) puts(&quot;YES&quot;); else { puts(&quot;NO&quot;); for (int i = 0; i &lt; k; i++) if (!buk[i]) while (ans.size() &lt; n) ans += char(i + 'a'); std::cout &lt;&lt; ans &lt;&lt; '\\n'; }}int main(){#ifndef ONLINE_JUDGE freopen(&quot;C.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;} D出题人出的什么瘠薄题面 best sol [Codeforces 1925D] Good Trip.cpp >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#define int long longint read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int P = 1e9 + 7;int pow(int x, int k, int res = 1){ for (x = (x + P) % P; k; k &gt;&gt;= 1, x = x * x % P) if (k &amp; 1) res = res * x % P; return res;}void solve(){ int n = read(), m = read(), k = read(); int sum = 0, ans = 0; for (int i = 1; i &lt;= m; i++) read(), read(), sum = (sum + read()) % P; int all = pow(n * (n - 1) / 2, P - 2), p = m * all % P; for (int i = 1; i &lt;= k; i++) ans = (ans + sum * all) % P, sum = (sum + p) % P; std::cout &lt;&lt; ans &lt;&lt; '\\n';}signed main(){#ifndef ONLINE_JUDGE freopen(&quot;D.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;} E>folded1","link":"/codeforces-round-921-div-2/"},{"title":"Codeforces Round 924 (Div. 2)","text":"比赛链接 A[Codeforces 1928A] Rectangle Cutting.cpp >folded12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;#define int long long#define pb push_backusing std::cin, std::cout, std::string;int read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 1e6 + 5;const int INF = 1LL &lt;&lt; 60;int n, a[N];void solve(){ int a = read(), b = read(); if (a &lt; b) std::swap(a, b); if (a % 2 == 0) { // a / 2, b * 2 int c = a / 2, d = b * 2; if (c &lt; d) std::swap(c, d); if (a != c or b != d) return puts(&quot;YES&quot;), void(); } if (b % 2 == 0) { int c = b / 2, d = a * 2; if (c &lt; d) std::swap(c, d); if (a != c or b != d) return puts(&quot;YES&quot;), void(); } puts(&quot;NO&quot;);}signed main(){#ifndef ONLINE_JUDGE freopen(&quot;A.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;} B去重以后在数轴上滑动窗口 [Codeforces 1928B] Equalize.cpp >folded1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;#define int long long#define pb push_backusing std::cin, std::cout, std::string;int read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 1e6 + 5;const int INF = 1LL &lt;&lt; 60;int n, a[N];void solve(){ n = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(); std::sort(a + 1, a + 1 + n); int m = std::unique(a + 1, a + 1 + n) - a - 1, ans = 1; for (int i = 1; i &lt;= m; i++) { int res = i; for (int L = i, R = m, mid; L &lt;= R;) if (a[mid = (L + R) / 2] - a[i] &lt; n) res = mid, L = mid + 1; else R = mid - 1; ans = std::max(ans, res - i + 1); } printf(&quot;%d\\n&quot;, ans);}signed main(){#ifndef ONLINE_JUDGE freopen(&quot;B.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;} C第一个出现的位置是 x 和 2k - x，循环节长度是 2k - 2 解方程 $n \\equiv x \\pmod{2k - 2}$ 和 $n \\equiv {2k - x} \\pmod{2k - 2}$ 等价于 $n - x \\equiv 0 \\pmod{2k - 2}$ 和 $n + x - 2 \\equiv 0 \\pmod{2k - 2}$ 枚举因数即可 [Codeforces 1928C] Physical Education Lesson.cpp >folded1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;// #define int long long#define pb push_backusing std::cin, std::cout, std::string;int read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 1e6 + 5;int n, x, kmax, a, b;std::set&lt;int&gt; S;void push(int y){ if (y % 2 != 0) return; int k = (y + 2) / 2; if (std::max(2, x) &lt;= k and k &lt;= kmax) S.insert(k);}void solve(){ n = read(), x = read(), S.clear(); kmax = (n + x) / 2, a = n - x, b = n + x - 2; for (int i = 1; i * i &lt;= a; i++) if (a % i == 0) push(i), push(a / i); for (int i = 1; i * i &lt;= b; i++) if (b % i == 0) push(i), push(b / i); printf(&quot;%d\\n&quot;, S.size());}signed main(){#ifndef ONLINE_JUDGE freopen(&quot;C.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;} D假如队伍数固定以后贡献是固定的，而且贡献可以独立计算，直接一个预处理然后枚举队伍数 有一个小优化是每次 k 不用枚举到 max(c)，只需要枚举到当前 c 即可，后面都是一个人一个队了。但是这样的话最后算答案的时候就会漏，要加个计数器累计现在超过了的东西的贡献 [Codeforces 1928D] Lonely Mountain Dungeons.cpp >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;#define int long long#define pb push_backusing std::cin, std::cout, std::string;int read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 2e5 + 5;const int INF = 1LL &lt;&lt; 60;int c[N], sum[N], add[N];int calc(int n, int k){ if (n &amp; k == 0) return 0; int x = n / k; int l = n % k, r = k - l; int L = (x + 1) * l, R = x * r; return R * L + (R - x) * R / 2 + L * (L - x - 1) / 2;}void solve(){ int n = read(), B = read(), X = read(); for (int i = 1; i &lt;= n; i++) c[i] = read(); int m = *std::max_element(c + 1, c + 1 + n); memset(sum, 0, (m + 1) * 8UL); memset(add, 0, (m + 1) * 8UL); for (int i = 1; i &lt;= n; i++) { for (int k = 1; k &lt;= c[i]; k++) sum[k] += calc(c[i], k); add[c[i]] += calc(c[i], c[i]); } int ans = 0, tot = 0; for (int k = 1; k &lt;= m; k++) ans = std::max(ans, B * (sum[k] + tot) - (k - 1) * X), tot += add[k]; printf(&quot;%lld\\n&quot;, ans);}signed main(){#ifndef ONLINE_JUDGE freopen(&quot;D.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;} E>folded1","link":"/codeforces-round-924-div-2/"},{"title":"Codeforces Round 922 (Div. 2)","text":"比赛链接 A[Codeforces 1918A] Brick Wall.cpp >folded1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;int read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 1e6 + 5;int n, a[N];void solve(){ int n = read(), m = read(); printf(&quot;%d\\n&quot;, n * (m / 2));}int main(){#ifndef ONLINE_JUDGE freopen(&quot;A.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;} B[Codeforces 1918B] Minimize Inversions.cpp >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;// #define int long longint read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 3e5 + 5;int n;struct Node{ int x, y; bool friend operator &lt; (Node a, Node b) { return a.x + a.y &lt; b.x + b.y; }} a[N];void solve(){ n = read(); for (int i = 1; i &lt;= n; i++) a[i].x = read(); for (int i = 1; i &lt;= n; i++) a[i].y = read(); std::sort(a + 1, a + 1 + n); for (int i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, a[i].x); puts(&quot;&quot;); for (int i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, a[i].y); puts(&quot;&quot;);}signed main(){#ifndef ONLINE_JUDGE freopen(&quot;B.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;} C按位贪心即可 有个小坑是从第一个 1-0 的下一位开始操作 [Codeforces 1918C] XOR-distance.cpp >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#define int long longint read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}void solve(){ int a = read(), b = read(), r = read(); int k = 0, ans = 0; if (a &lt; b) std::swap(a, b); for (int i = 63; i &gt;= 0; i--) if (((a &gt;&gt; i) &amp; 1LL) == 1 and ((b &gt;&gt; i) &amp; 1LL) == 0) { k = i; break; } // printf(&quot;k : %lld\\n&quot;, k); for (int i = k - 1; i &gt;= 0; i--) { int x = (a &gt;&gt; i) &amp; 1LL, y = (b &gt;&gt; i) &amp; 1LL; if (x == 1 and y == 0) { if (ans + (1LL &lt;&lt; i) &lt;= r) ans += 1LL &lt;&lt; i; } } // printf(&quot;[%lld]\\n&quot;, ans); int x = a ^ ans; int y = b ^ ans; printf(&quot;%lld\\n&quot;, x - y);}signed main(){#ifndef ONLINE_JUDGE freopen(&quot;C.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;} D一眼二分，赛时不会 judge。不会处理断点的和。 一个常见的处理方法是把断点的和放到 dp 数组里面维护，转移的时候从距离小于限制的地方转移即可 可以转移的范围是一个滑动窗口 $$f_i = a_i + \\min_{s_{i - 1} - s_j \\leq lim}{f_j}$$ [Codeforces 1918D] Blocking Elements.cpp >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#define int long longint read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 1e6 + 5;const int INF = 1LL &lt;&lt; 60;int n, a[N], sum[N], q[N], f[N];bool judge(int lim){ int h = 1, t = 0; q[++t] = 0; for (int i = 0; i &lt;= n + 1; i++) f[i] = 0; for (int i = 1; i &lt;= n + 1; i++) { for (; h &lt;= t and sum[i - 1] - sum[q[h]] &gt; lim; h++); f[i] = a[i] + f[q[h]]; for (; h &lt;= t and f[i] &lt;= f[q[t]]; t--); q[++t] = i; } return f[n + 1] &lt;= lim;}void solve(){ n = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(); a[n + 1] = 0; for (int i = 1; i &lt;= n; i++) sum[i] = sum[i - 1] + a[i]; int ans = 0; for (int L = 1, R = sum[n], mid; L &lt;= R; ) if (judge(mid = (L + R) &gt;&gt; 1)) ans = mid, R = mid - 1; else L = mid + 1; std::cout &lt;&lt; ans &lt;&lt; '\\n';}signed main(){#ifndef ONLINE_JUDGE freopen(&quot;D.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;} E>folded1","link":"/codeforces-round-922-div-2/"},{"title":"Codeforces Round 925 (Div. 3)","text":"比赛链接 A脑袋一片混乱，删了又写写了又删，某些常数调了半天，00:17 才 a，而且吃了发罚时，心态小崩 [Codeforces 1931A] Recovering a Small String.cpp >folded12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;// #define int long long#define pb push_backusing std::cin, std::cout, std::string;int read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 1e6 + 5;const int INF = 1 &lt;&lt; 30;// const long long INF = 1LL &lt;&lt; 60;int n, a[N];void solve(){ int x = read(); string ans = &quot;&quot;; if (x &gt; 52) ans += char('a' + x - 52 - 1), x -= (ans[0] - 'a' + 1); else ans += 'a', x--; if (x &gt; 26) ans += char('a' + x - 26 - 1), x -= (ans[1] - 'a' + 1); else ans += 'a', x--; ans += char('a' + x - 1); cout &lt;&lt; ans &lt;&lt; '\\n';}signed main(){#ifndef ONLINE_JUDGE freopen(&quot;A.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;} B[Codeforces 1931B] Make Equal.cpp >folded123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;#define int long long#define pb push_backusing std::cin, std::cout, std::string;int read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 1e6 + 5;const int INF = 1 &lt;&lt; 30;// const long long INF = 1LL &lt;&lt; 60;int n, a[N];void solve(){ int n = read(), sum = 0, f = 1, tot = 0; for (int i = 1; i &lt;= n; i++) a[i] = read(), sum += a[i]; sum /= n; for (int i = 1; i &lt;= n; i++) { if (a[i] &gt; sum) tot += a[i] - sum; else tot -= sum - a[i]; if (tot &lt; 0) f = 0; } puts(f ? &quot;YES&quot; : &quot;NO&quot;);}signed main(){#ifndef ONLINE_JUDGE freopen(&quot;B.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;} C贪心是显然的 [Codeforces 1931C] Make Equal Again.cpp >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;// #define int long long#define pb push_backusing std::cin, std::cout, std::string;int read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 2e5 + 5;const int INF = 1 &lt;&lt; 30;// const long long INF = 1LL &lt;&lt; 60;int n, a[N], b[N], c[N];void solve(){ n = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(); if (n == 1) return puts(&quot;0&quot;), void(); int l, r, ans = n; l = 0, r = n + 1; for (int i = 1; i &lt;= n; i++) if (a[i] == a[1]) l = i; else break; for (int i = n; i &gt;= 1; i--) if (a[i] == a[1]) r = i; else break; if (l == n and r == 1) return puts(&quot;0&quot;), void(); ans = r - l - 1; l = 0, r = n + 1; for (int i = 1; i &lt;= n; i++) if (a[i] == a[n]) l = i; else break; for (int i = n; i &gt;= 1; i--) if (a[i] == a[n]) r = i; else break; ans = std::min(ans, r - l - 1); cout &lt;&lt; ans &lt;&lt; '\\n';}signed main(){#ifndef ONLINE_JUDGE freopen(&quot;C.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;} D相当于 mod y 相等，mod x 互补的数对个数 [Codeforces 1931D] Divisible Pairs.cpp >folded12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;#define int long long#define pb push_backusing std::cin, std::cout, std::string;int read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 1e6 + 5;const long long INF = 1LL &lt;&lt; 60;int n, a[N];void solve(){ int n = read(), x = read(), y = read(), res = 0; std::map&lt;int, std::vector&lt;int&gt;&gt; cnt; for (int i = 1; i &lt;= n; i++) a[i] = read(), cnt[a[i] % y].pb(a[i]); for (auto map : cnt) { std::map&lt;int, int&gt; buk; auto vec = map.second; std::map&lt;int, int&gt; vis; for (auto i : vec) buk[i % x]++; for (auto i : vec) if (!vis[i % x]) vis[i % x] = vis[x - i % x] = 1, res += i % x == x - i % x ? buk[i % x] * (buk[i % x] - 1) / 2 : buk[i % x] * buk[x - i % x]; res += buk[0] * (buk[0] - 1) / 2; } cout &lt;&lt; res &lt;&lt; &quot;\\n&quot;;}signed main(){#ifndef ONLINE_JUDGE freopen(&quot;D.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;} E这傻卵题就直接模拟就行了 开个堆 因为一定是每一步贪心把后导零最多的拿出来操作 md，又大的实现细节边想边写，写的巨慢改来改去，写久了 [Codeforces 1931E] Anna and the Valentine's Day Gift.cpp >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;// #define int long long#define pb push_backusing std::cin, std::cout, std::string;int read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 1e6 + 5;const int INF = 1 &lt;&lt; 30;// const long long INF = 1LL &lt;&lt; 60;int a[N];struct Node{ int bit, cnt0; bool friend operator &lt; (Node a, Node b) { return a.cnt0 &lt; b.cnt0; }};int countbit(int x){ int res = 0; while (x &gt; 0) x /= 10, res++; return res;}int count0(int x){ int res = 0; while (x &gt; 0 and x % 10 == 0) x /= 10, res++; return res;}void solve(){ int n = read(), m = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(); std::priority_queue&lt;Node&gt; Q; int T = 0, ans = 0; for (int i = 1; i &lt;= n; i++) Q.push(Node{countbit(a[i]), count0(a[i])}); for (int i = 1; i &lt;= n - 1; i++) { int x = Q.top().bit, y = Q.top().cnt0; Q.pop(); int k = Q.top().bit; Q.pop(); Q.push(Node{k + x - y, 0}); } ans = Q.top().bit; if (n == 1) ans -= Q.top().cnt0; puts(ans &gt; m ? &quot;Sasha&quot; : &quot;Anna&quot;);}signed main(){#ifndef ONLINE_JUDGE freopen(&quot;E.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;} Fmd，降智了，一眼差分约束了 好久没写图论手速慢的一笔，然后多测邻接表和数组清空还搞了半天 又因为细节原因代码没搞出来下大分了 赛后发现直接判断有没有环就行了 [Codeforces 1931F] Chat Screenshots.cpp >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;// #define int long long#define pb push_backusing std::cin, std::cout, std::string;int read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 2e5 + 5;const int INF = 1 &lt;&lt; 30;int n, m, a[N], ind[N];std::vector&lt;int&gt; g[N];bool toposort(){ int cnt = 0; std::queue&lt;int&gt; Q; for (int i = 1; i &lt;= n; i++) if (!ind[i]) Q.push(i); for (int u; !Q.empty(); ) { u = Q.front(), Q.pop(), cnt++; for (auto v : g[u]) if (!--ind[v]) Q.push(v); } return cnt == n;}void solve(){ n = read(), m = read(); for (int i = 1; i &lt;= n; i++) g[i].clear(), ind[i] = 0; while(m--) { for (int i = 1; i &lt;= n; i++) a[i] = read(); for (int i = 2; i &lt; n; i++) g[a[i]].pb(a[i + 1]), ind[a[i + 1]]++; } puts(toposort() ? &quot;YES&quot; : &quot;NO&quot;);}signed main(){#ifndef ONLINE_JUDGE freopen(&quot;F.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;}","link":"/codeforces-round-925-div-3/"},{"title":"Codeforces Round 926 (Div. 2)","text":"比赛链接 A[Codeforces 1929A] Sasha and the Beautiful Array.cpp >folded123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;// #define int long long#define pb push_backusing std::cin, std::cout, std::string;int read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 1e6 + 5;const int INF = 1 &lt;&lt; 30;// const long long INF = 1LL &lt;&lt; 60;int a[N];void solve(){ int n = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(); std::sort(a + 1, a + 1 + n); cout &lt;&lt; a[n] - a[1] &lt;&lt; '\\n';}signed main(){#ifndef ONLINE_JUDGE freopen(&quot;A.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;} B>folded1 C>folded1 D题意：给定一棵树，选择一些点成为坏点，但限制是树上任意一条简单路径最多包含 2 个坏点，问你有多少种选法 首先对于一条树上路径 (u, v) 可以拆成 (u, lca) + (lca, v)，把视角转换到 lca 上。一个根向下到叶子的链只能是 0, 1, 2 三种，并且相加不大于 2 >folded1 E>folded1","link":"/codeforces-round-926-div-2/"},{"title":"Codeforces Round 929 (Div. 3)","text":"比赛链接 A[Codeforces 1933A] Turtle Puzzle: Rearrange and Negate.cpp >folded1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;#define int long long#define pb push_backusing std::cin, std::cout, std::string;int read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 1e6 + 5;const int INF = 1 &lt;&lt; 30;// const long long INF = 1LL &lt;&lt; 60;int a[N];void solve(){ int n = read(), ans = 0; for (int i = 1; i &lt;= n; i++) ans += abs(read()); cout &lt;&lt; ans &lt;&lt; '\\n';}signed main(){#ifndef ONLINE_JUDGE freopen(&quot;A.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;} B[Codeforces 1933B] Turtle Math: Fast Three Task.cpp >folded123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;#define int long long#define pb push_backusing std::cin, std::cout, std::string;int read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 1e6 + 5;const int INF = 1 &lt;&lt; 30;// const long long INF = 1LL &lt;&lt; 60;int n, a[N];void solve(){ n = read(); int sum = 0; for (int i = 1; i &lt;= n; i++) a[i] = read(); for (int i = 1; i &lt;= n; i++) sum += a[i]; if (sum % 3 == 0) return puts(&quot;0&quot;), void(); if ((sum + 1) % 3 == 0) return puts(&quot;1&quot;), void(); for (int i = 1; i &lt;= n; i++) if ((sum - a[i]) % 3 == 0) return puts(&quot;1&quot;), void(); return puts(&quot;2&quot;), void();}signed main(){#ifndef ONLINE_JUDGE freopen(&quot;B.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;} C[Codeforces 1933C] Turtle Fingers: Count the Values of k.cpp >folded12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;#define int long long#define pb push_backusing std::cin, std::cout, std::string;int read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 1e6 + 5;const int INF = 1 &lt;&lt; 30;// const long long INF = 1LL &lt;&lt; 60;int a, b, l;int work(int a, int b){ int res = 0, X = l; std::set&lt;int&gt; S; for (int A = 1; 1; A *= a) { for (int B = 1; 1; B *= b) if (l % (A * B) == 0) S.insert(l / (A * B)); else break; if (l % A != 0) break; } return S.size();}void solve(){ a = read(), b = read(), l = read(); if (a &lt; b) std::swap(a, b); cout &lt;&lt; work(a, b) &lt;&lt; '\\n';}signed main(){#ifndef ONLINE_JUDGE freopen(&quot;C.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;} D[Codeforces 1933D] Turtle Tenacity: Continual Mods.cpp >folded123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;// #define int long long#define pb push_backusing std::cin, std::cout, std::string;int read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 1e6 + 5;const int INF = 1 &lt;&lt; 30;// const long long INF = 1LL &lt;&lt; 60;int a[N];void solve(){ int n = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(); std::sort(a + 1, a + 1 + n); if (a[n] == a[1]) return puts(&quot;NO&quot;), void(); int c = 0; for (int i = 1; i &lt;= n; i++) if (a[i] == 1) c++; if (c &gt; 1) return puts(&quot;NO&quot;), void(); if (a[2] != a[1]) return puts(&quot;YES&quot;), void(); for (int i = 2; i &lt;= n; i++) if (a[i] % a[1] != 0) return puts(&quot;YES&quot;), void(); puts(&quot;NO&quot;);}signed main(){#ifndef ONLINE_JUDGE freopen(&quot;D.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;} E[Codeforces 1933E] Turtle vs. Rabbit Race: Optimal Trainings.cpp >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;#define int long long#define pb push_backusing std::cin, std::cout, std::string;int read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 1e6 + 5;const int INF = 1 &lt;&lt; 30;// const long long INF = 1LL &lt;&lt; 60;int n, a[N], b[N];void solve(){ n = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(); for (int i = 1; i &lt;= n; i++) b[i] = b[i - 1] + a[i]; for (int q = read(), l, u; q--; ) { l = read(), u = read(); int res = l; for (int L = l, R = n; L &lt;= R; ) { int mid = (L + R) &gt;&gt; 1; int tot = b[mid - 1] - b[l - 1]; int st = u - tot, ed = u - tot - a[mid] + 1; int sum = (st + ed) * a[mid] / 2; if (sum &gt; 0) res = mid, L = mid + 1; else R = mid - 1; } cout &lt;&lt; res &lt;&lt; ' '; } cout &lt;&lt; '\\n';}signed main(){#ifndef ONLINE_JUDGE freopen(&quot;E.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;} F观察到几个事情 往上走相当于把原图固定没走 往下走 1 格相当于原图把原图固定走 2 格 往右走 1 格相当于把原图固定以后 向下 1 格 + 向右 1 格 [Codeforces 1933F] Turtle Mission: Robot and the Earthquake.cpp >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;// #define int long longusing pii = std::pair&lt;int, int&gt;;#define pb push_backusing std::cin, std::cout, std::string;int read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 1e3 + 5;const int INF = 1 &lt;&lt; 30;// const long long INF = 1LL &lt;&lt; 60;int n, m, a[N][N], f[N][N];void upd(int &amp;x, int y) { x = std::min(x, y); }void solve(){ n = read(), m = read(); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) a[i][j] = read(), f[i][j] = -1; std::queue&lt;pii&gt; q; q.emplace(0, 0), f[0][0] = 0; int ans = INT_MAX; while (!q.empty()) { auto [x, y] = q.front(); q.pop(); if (y == m - 1) ans = std::min(ans, f[x][y] + ((x - (n - 1 + f[x][y])) % n + n) % n); if (f[(x + 1) % n][y + 1] == -1 and a[(x + 1) % n][y + 1] == 0 and y + 1 &lt; m) f[(x + 1) % n][y + 1] = f[x][y] + 1, q.emplace((x + 1) % n, y + 1); if (f[(x + 2) % n][y] == -1 and a[(x + 1) % n][y] == 0 and a[(x + 2) % n][y] == 0) f[(x + 2) % n][y] = f[x][y] + 1, q.emplace((x + 2) % n, y); } if (ans == INT_MAX) ans = -1; cout &lt;&lt; ans &lt;&lt; '\\n';}signed main(){#ifndef ONLINE_JUDGE freopen(&quot;F.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;}","link":"/codeforces-round-929-div-3/"},{"title":"Codeforces Round 930 (Div. 2)","text":"比赛链接 A[Codeforces 1937A] Shuffle Party.cpp >folded12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;#define int long longusing pii = std::pair&lt;int, int&gt;;#define pb push_backusing std::cin, std::cout, std::string;int read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 1e6 + 5;const int INF = 1 &lt;&lt; 30;// const long long INF = 1LL &lt;&lt; 60;int n, m, a[N];void solve(){ n = read(); int res = 1; for (int k = 1; k &lt;= n; k *= 2LL) res = k; cout &lt;&lt; res &lt;&lt; '\\n';}signed main(){#ifndef ONLINE_JUDGE freopen(&quot;A.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;} B[Codeforces 1937B] Binary Path.cpp >folded123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;// #define int long longusing pii = std::pair&lt;int, int&gt;;#define pb push_backusing std::cin, std::cout, std::string;int read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 1e6 + 5;const int INF = 1 &lt;&lt; 30;// const long long INF = 1LL &lt;&lt; 60;int n;void solve(){ string s1, s2; cin &gt;&gt; n &gt;&gt; s1 &gt;&gt; s2; string res = s1[0] + s2; int ans = 0; for (int i = 1; i &lt; n; i++) if (res[i] &gt; s1[i]) res[i] = s1[i], ans = 0; else if (res[i] == s1[i]) ans++; else if (res[i] &lt; s1[i]) break; cout &lt;&lt; res &lt;&lt; '\\n' &lt;&lt; ans + 1 &lt;&lt; '\\n';}signed main(){#ifndef ONLINE_JUDGE freopen(&quot;B.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;} C先找出最大的（n-1）。再在或最大里面找最小的 [Codeforces 1937C] Bitwise Operation Wizard.cpp >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;// #define int long longusing pii = std::pair&lt;int, int&gt;;#define pb push_backusing std::cin, std::cout, std::string;int read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 1e6 + 5;const int INF = 1 &lt;&lt; 30;// const long long INF = 1LL &lt;&lt; 60;void solve(){ int n = read(); int p = 0; for (int i = 1; i &lt; n; i++) { printf(&quot;? %d %d %d %d\\n&quot;, p, p, i, i), fflush(stdout); char ch; cin &gt;&gt; ch; if (ch == '&lt;') p = i; } std::vector&lt;int&gt; a; int q = p; for (int i = 0; i &lt; n; i++) { printf(&quot;? %d %d %d %d\\n&quot;, p, q, p, i), fflush(stdout); char ch; cin &gt;&gt; ch; if (ch == '&lt;') a.clear(), a.pb(i), q = i; else if (ch == '=') a.pb(i); } int m = a.size(); int t = a[0]; for (int i = 1; i &lt; m; i++) { printf(&quot;? %d %d %d %d\\n&quot;, t, t, a[i], a[i]), fflush(stdout); char ch; cin &gt;&gt; ch; if (ch == '&gt;') t = a[i]; } printf(&quot;! %d %d\\n&quot;, t, p), fflush(stdout);}signed main(){#ifndef ONLINE_JUDGE // freopen(&quot;C.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;} D其实应该算一个高级点的模拟题 [Codeforces 1937D] Pinball.cpp >folded12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;#define int long longusing pii = std::pair&lt;int, int&gt;;#define pb push_backusing std::cin, std::cout, std::string;int read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 1e6 + 5;const int INF = 1 &lt;&lt; 30;// const long long INF = 1LL &lt;&lt; 60;int n, a[N], b[N];void solve(){ string s; cin &gt;&gt; n &gt;&gt; s; std::vector&lt;int&gt; ans(n, -1), l, r; for (int i = 0; i &lt; n; i++) if (s[i] == '&gt;') r.pb(i); else l.pb(i); std::reverse(l.begin(), l.end()); for (int i = 0, tot = 0; i &lt; n and !l.empty(); i++) tot += (l.back() - i) * 2, l.pop_back(), ans[i] = i + 1 + tot; for (int i = n - 1, tot = 0; ~i and !r.empty(); i--) tot += (i - r.back()) * 2, r.pop_back(), ans[i] = n - i + tot; for (int i = 0; i &lt; n; i++) cout &lt;&lt; ans[i] &lt;&lt; ' '; puts(&quot;&quot;);}signed main(){#ifndef ONLINE_JUDGE freopen(&quot;D.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;} E看了题解，有一个叫 前后缀优化建边 的 trick 并不需要那么多边，可以将 m 个属性离散化，然后 m 个属性之间 从小到大连边。 [Codeforces 1937E] Pokémon Arena.cpp >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;bits/stdc++.h&gt;#define int long longusing pii = std::pair&lt;int, int&gt;;using tuu = std::tuple&lt;int, int, int&gt;;#define pb push_backusing std::cin, std::cout, std::string, std::vector;int read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 1e6 + 5;const int INF = 1e18;int n, m, a[N];void solve(){ n = read(), m = read(); vector&lt;int&gt; c(n + 1); for (int i = 1; i &lt;= n; i++) c[i] = read(); vector&lt;vector&lt;int&gt;&gt; a(n + 1, vector&lt;int&gt;(m + 1)); vector&lt;vector&lt;pii&gt;&gt; b(m + 1); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) a[i][j] = read(), b[j].pb({a[i][j], i}); vector&lt;vector&lt;int&gt;&gt; rk(n + 1, vector&lt;int&gt;(m + 1)); vector&lt;vector&lt;int&gt;&gt; dec(n + 1, vector&lt;int&gt;(m + 1)); for (int j = 1; j &lt;= m; j++) { std::sort(b[j].begin(), b[j].end()); for (int i = 0; i &lt; n; i++) { auto [x, id] = b[j][i]; rk[id][j] = i + 1; dec[i + 1][j] = id; } } int ans = INF; vector&lt;int&gt; vis(n + 1, 0); vector&lt;vector&lt;int&gt;&gt; dist(n + 1, vector&lt;int&gt;(m + 1, INF)); std::priority_queue&lt;tuu, vector&lt;tuu&gt;, std::greater&lt;tuu&gt;&gt; Q; vis[1] = 1; for (int j = 1; j &lt;= m; j++) dist[1][j] = 0, Q.push({dist[1][j], 1, j}); while (!Q.empty()) { auto [w, x, t] = Q.top(); Q.pop(); // cout &lt;&lt; w &lt;&lt; x &lt;&lt; t &lt;&lt; '\\n'; if (dist[x][t] &lt; w) continue; if (x == n) ans = std::min(ans, w + c[n]); if (rk[x][t] &lt; n) { int z = dec[rk[x][t] + 1][t]; if (w &lt; dist[z][t]) dist[z][t] = w, Q.push({dist[z][t], z, t}); } if (rk[x][t] &gt; 1) { int z = dec[rk[x][t] - 1][t]; if (w + a[x][t] - a[z][t] &lt; dist[z][t]) dist[z][t] = w + a[x][t] - a[z][t], Q.push({dist[z][t], z, t}); } if (!vis[x]) { vis[x] = 1; for (int j = 1; j &lt;= m; j++) if (w + c[x] &lt; dist[x][j]) dist[x][j] = w + c[x], Q.push({dist[x][j], x, j}); } } cout &lt;&lt; ans &lt;&lt; '\\n';}signed main(){#ifndef ONLINE_JUDGE freopen(&quot;E.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;}","link":"/codeforces-round-930-div-2/"},{"title":"Codeforces Round 951 (Div. 2)","text":"比赛链接 Problems AC A. Guess the Maximum ○ B. XOR Sequences ○ C. Earning on Bets ○ D. Fixing a Binary String ○ E. Manhattan Triangle ○ F. Kostyanych’s Theorem A Alice 和 Bob 想出了一个相当奇怪的游戏。他们有一个整数数组 $a_1, a_2,\\ldots, a_n$ 。Alice 选择某个整数 $k$ 并将其告诉 Bob，然后发生以下情况： Bob 选择两个整数 $i$ 和 $j$ ( $1 \\le i &lt; j \\le n$ )，然后在整数 $a_i, a_{i + 1},\\ldots, a_j$ 中找到最大值； 如果获得的最大值严格大于 $k$ ，则 Alice 获胜，否则 Bob 获胜。 帮助 Alice 找到她保证获胜的最大值 $k$ 。 考虑长度为 2 的时候即可 Code B 给定两个不同的非负整数 $x$ 和 $y$ 。考虑两个无限序列 $a_1, a_2, a_3, \\ldots$ 和 $b_1, b_2, b_3, \\ldots$ ，其中 $a_n = n \\oplus x$ ; $b_n = n \\oplus y$ 。 您的任务是找出序列 $a$ 和 $b$ 的最长公共子段的长度。 想象一下，假如 x 是 111 0011，y 是 000 0011。那我们必然可以找到一组 (i, j) 使得 i xor x = j xor y。并且只要 (i, j) 的后 4 位都为 0，将前几位构造到 xor 后相同，那么就能无限加下去，知道第 5 位改变为止。所以答案为 lowbit(x ^ y) Code C 你被邀请玩一个游戏。在这个游戏中，有 $n$ 个可能的结果，对于每个结果，你必须下注一定数量的硬币。如果第 $i$ 个结果获胜，你将获得等于你对该结果下注的硬币数量乘以 $k _ i$ 的硬币数量。请注意， $n$ 个结果中只有一个会获胜。 你的任务是确定如何分配硬币，以便在任何获胜结果出现时你都能领先。更正式地说，你对所有结果下注的硬币总数必须严格小于每个可能获胜结果收到的硬币数量。 设总花费为 $S$ 任意结果的收益必须大于总支出，$x_i k_i &gt; S$，即 $x_i &gt; \\frac{S}{k_i}$ 两边求和，$\\sum{x_i} &gt; \\sum{\\frac{S}{k_i}}$，即 $S &gt; \\sum{\\frac{S}{k_i}}$，即 $1 &gt; \\sum{\\frac{1}{k_i}}$ 即 $lcm &gt; \\sum{\\frac{lcm}{k_i}}$ Code D 对于 01 串 $s$, 能否将 $s$ 分成 $s=s_1+s_2$, 使得 $s^{\\prime}=s_2+r e v\\left(s_1\\right)$ 是 01 交替 $\\mathbf{k}$ 次出现的。 含义是字符串形如 $\\underbrace{00 \\cdots 011 \\cdots 100 \\cdots 011 \\cdots 1}_{k \\uparrow} \\cdots$, 保证 $k$ 是字符串总长 $n$ 的一个因子。 E 两点 $(x _ 1, y _ 1)$ 和 $(x _ 2, y _ 2)$ 之间的曼哈顿距离定义为： $$|x _ 1 - x _ 2| + |y _ 1 - y _ 2|.$$ 我们称曼哈顿三角形为平面上的三个点，每对点之间的曼哈顿距离相等。 给定一组成对的不同点和一个偶数 $d$ 。您的任务是找到由给定集合中的三个不同点组成的任何曼哈顿三角形，其中任何一对顶点之间的曼哈顿距离等于 $d$ 。 假设第一个点是 $O_1$，到 $O_1$ 曼哈顿距离相同点的构成的是一个旋转 45 度的正方形。画一下图你会发现，当 $O_2$ 在 $O_1$ 的正方形上滑动的时候，要么 $O_{1}O_{2}$ 的斜率为 $\\pm 1$，要么 $O_{1}O_{3}$ 的斜率为 $\\pm 1$。 换言之，我们可以枚举 $O_1$，然后在它的 斜率 $\\pm 1$ 方向上找第二点 $O_2$。找到第二点以后，在两个矩形的交线段上面找第三点。 关于这个找第三点的过程。以交线段斜率为 $1$ 举例，在交线段上的点都有相同的 $b = y - x$，那么可以按照这些点在斜率为 $-1$ 的直线上的截距 $b’ = y + x$ 排序，每次二分查找有无在 $\\left[ x_{O_1} + y_{O_1}, x_{O_2} + y_{O_2} \\right] $ 的点即可 Note: 这其实完成了曼哈顿距离和切比雪夫距离的转换，见常见距离算法小记 Code F 这是一个交互式问题。 Kostyanych 选择了一个具有 $n$ 个顶点的完全无向图 $^{\\dagger}$ ，然后从中移除了恰好 $(n - 2)$ 条边。您可以提出以下类型的查询： “？ $d$ ” — Kostyanych 告诉您度数至少为 $d$ 的顶点 $v$ 的数量。在所有可能的此类顶点中，他选择度数最小的顶点，如果有多个这样的顶点，则选择数量最小的顶点。他还告诉您图中另一个顶点的数量，该顶点与 $v$ 没有边连接（如果未找到，则报告 $0$ ）。在所有可能的此类顶点中，他选择数量最小的顶点。然后他删除顶点 $v$ 以及从该顶点出来的所有边。如果未找到所需的顶点 $v$ ，则报告“ $0\\ 0$ ”。 在最多 $n$ 次查询中，在原始图中找到一条汉密尔顿路径 $^{\\ddagger}$ 。可以证明，在这些约束条件下，汉密尔顿路径始终存在。 $^{\\dagger}$ 完全无向图是任意一对不同顶点之间恰好有一条无向边的图。因此，具有 $n$ 个顶点的完全无向图包含 $\\frac{n(n-1)}{2}$ 条边。 $^{\\ddagger}$ 图中汉密尔顿路径是一条恰好经过每个顶点一次的路径。","link":"/codeforces-round-951-div-2/"},{"title":"Codeforces Round 952 (Div. 4)","text":"赛后一个题一个题做的 比赛链接 Problems AC A. Creating Words ○ B. Maximum Multiple Sum ○ C. Good Prefixes ○ D. Manhattan Circle ○ E. Secret Box ○ F. Final Boss ○ G. D-Function ○ H1. Maximize the Largest Component (Easy Version) ○ H2. Maximize the Largest Component (Hard Version) ○ ACode BCode CCode DCode ECode FCode G 假设 $D(n)$ 表示 $n$ 的数字之和。那么有多少个整数 $n$ 满足 $10^{l} \\leq n &lt; 10^{r}$ 且 $D(k \\cdot n) = k \\cdot D(n)$ ？输出答案模 $10^9+7$ 。 显然，不能进位。 令 $x = \\lfloor\\dfrac{9}{k}\\rfloor$，那么一个合法数字最高位 $\\in [1, x]$，其余位 $\\in [0, x]$。 长度为 $len$ 的合法数总共有 $x(x + 1)^{len - 1}$ 那么答案为 $x((x + 1)^l + \\cdots + (x + 1)^{r -1}) = (x + 1)^r - (x + 1)^l$ Code H1 Alex 有一个网格，其行数为 $n$ ，列数为 $m$ ，由 ‘.’ 和 ‘#’ 字符组成。如果从一组 ‘#’ 个单元格中的任何单元格出发，仅通过移动到集合中共享公共边的另一个单元格即可到达该集合中的任何其他单元格，则该集合构成连通分量。连通分量的大小是集合中的单元格数。 在一个操作中，Alex 选择任意行 $r$ ( $1 \\le r \\le n$ ) 或任意列 $c$ ( $1 \\le c \\le m$ )，然后将行 $r$ 或列 $c$ 中的每个单元格设置为 ‘#’。帮助 Alex 找到最多执行一次操作后可以实现的“#”个单元格最大连通分量的最大可能尺寸。 没什么好说的，并查集然后分别枚举哪一行或者哪一列即可，属于是 implement 题。 Code H2 Alex 有一个网格，其行数为 $n$ ，列数为 $m$ ，由 ‘.’ 和 ‘#’ 字符组成。如果从一组 ‘#’ 个单元格中的任何单元格出发，仅通过移动到集合中共享公共边的另一个单元格即可到达该集合中的任何其他单元格，则该集合构成连通分量。连通分量的大小是集合中的单元格数。 在一个操作中，Alex 选择任意行 $r$ ( $1 \\le r \\le n$ ) 和任意列 $c$ ( $1 \\le c \\le m$ )，然后将行 $r$ 和列 $c$ 中的每个单元格设置为 ‘#’。帮助 Alex 找到最多执行一次操作后可以实现的“#”个单元格最大连通分量的最大可能尺寸。 每个联通块实际上会对一个十字形的矩形区域有贡献，这其实就是在矩形上面做矩形加法，二维差分即可。 Code","link":"/codeforces-round-952-div-4/"},{"title":"Codeforces Round 953 (Div. 2)","text":"比赛链接 Problems AC A. Alice and Books ○ B. New Bakery ○ C. Manhattan Permutations ○ D. Elections ○ E. Computing Machine ⊕ F. Large Graph ⊕ A Alice 有 $n$ 本书。第 $1$ 本书包含 $a_1$ 页，第 $2$ 本书包含 $a_2$ 页，$\\ldots$, 第 $n$ 本书包含 $a_n$ 页。Alice 执行以下操作： 她将所有书分成两个非空堆。因此，每本书最终都恰好属于两个堆中的一个。 Alice 在每个堆中阅读了一本编号最高的书。 Alice 非常喜欢读书。通过将书分成两个堆，帮助她找出她可以阅读的最大总页数。 Code B Bob 决定开一家面包店。开业当天，他烤了 $n$ 个面包出售。一个面包的正常价格是 $a$ 个硬币，但为了吸引顾客，Bob 组织了以下促销活动： Bob 选择某个整数 $k$ ( $0 \\le k \\le \\min(n, b)$ )。 Bob 以修改后的价格出售前 $k$ 个面包。在这种情况下，售出的第 $i$ 个面包 ( $1 \\le i \\le k$ ) 的价格为 $(b - i + 1)$ 个硬币。 其余 $(n - k)$ 个面包以每个 $a$ 个硬币的价格出售。 请注意， $k$ 可以等于 $0$ 。在这种情况下，Bob 将以每个 $a$ 个硬币的价格出售所有包子。 帮助 Bob 确定通过出售所有 $n$ 个包子他可以获得的最大利润。 Code C 我们将排列 $^{\\dagger}$ $p$ 的曼哈顿值称为表达式 $|p _ 1 - 1| + |p _ 2 - 2| + \\ldots + |p _ n - n|$ 的值。 例如，对于排列 $[1, 2, 3]$ ，曼哈顿值为 $|1 - 1| + |2 - 2| + |3 - 3| = 0$ ，对于排列 $[3, 1, 2]$ ，曼哈顿值为 $|3 - 1| + |1 - 2| + |2 - 3| = 2 + 1 + 1 = 4$ 。 给定整数 $n$ 和 $k$ 。找出长度为 $n$ 的排列 $p$ ，使得其曼哈顿值等于 $k$ ，或者确定不存在这样的排列。 在评论区大家都说这个 C 题比 DE 简单，但是感觉是个很直觉的题。 考虑最大化的话肯定是 1 和 n 交换，2 和 n - 1 交换，以此类推这个形式。 如果某一次这样移太大了就从后面那一个开始移就行了 Code D 贝尔兰正在进行选举。有$n$位候选人参加选举，编号从1到$n$。第$i$位候选人有$a_i$位支持者会投票给他。另外，有$c$位尚未决定投给谁的人，我们称他们为未决定者。未决定者将投票给编号最小的候选人。 获得最多选票的候选人将赢得选举，如果有多名候选人获得相同的最多选票，则编号最小的候选人获胜。 你觉得这次选举太无聊和可预测了，所以你决定排除一些候选人。如果你不允许编号为$i$的候选人参加选举，那么他所有的$a_i$位支持者将变成未决定者，并投票给编号最小的候选人。 你想知道，对于每个从1到$n$的候选人来说，使编号为$i$的候选人赢得选举，最少需要排除多少名候选人。 首先，对于 i 这个候选人，如果他是最大的，那么就不用操作。 如果 i 不是最大的，那么所有大于 a[i] 的 a[j] 都要被删去。但是被删去以后的选票都加到了 a[1] 上面。本身 a[j] 已经大于 a[i] 了，加上 a[1] + c 就更会大于 a[i]，以此出发，a[1] 到 a[i - 1] 都要被删去。 因此对于每个 i，我们记 x = sum[i] + c，我们用一个堆维护 a[i + 1] ~ a[n]，每次把堆顶中最大的取出来加到 x 上面，直到 x 成为最大值。 Note: 可以发现右边这些数里面最多只删一个最大值就够了，所以其实答案只有可能是 0，i，i + 1 Code E 萨莎有两个相同长度为$n$的二进制字符串$s$和$t$，它们由字符0和1组成。 还有一台计算机，它可以对长度为$k$的二进制字符串$a$和$b$执行两种类型的操作： 如果$a_i = a_{i + 2} = 0$，那么你可以将$b_{i + 1}$赋值为1 ($1 \\le i \\le k - 2$)。 如果$b_i = b_{i + 2} = 1$，那么你可以将$a_{i + 1}$赋值为1 ($1 \\le i \\le k - 2$)。 萨莎对以下问题感兴趣：如果我们考虑字符串$a=s_l s_{l+1} \\ldots s_r$和字符串$b=t_l t_{l+1} \\ldots t_r$，使用计算机后字符串$a$中最多可以有多少个字符1。由于萨莎非常好奇但又很懒，所以你需要回答他感兴趣的多个$(l_i, r_i)$对。 最优的操作肯定是先做 1，再做 2。而且不会反复操作。既然不会反复操作，你可以先对整个序列操作，每个询问只会有区间最左最右的一些数会被改变，暴力即可。 Code F 给定一个长度为$n$的数组$a$。构造一个$n \\times n$的方阵$b$，其中第$i$行包含数组$a$向右循环移动$(i - 1)$次的结果。例如，对于数组$a = [3, 4, 5]$，得到的矩阵是 $$b = \\begin{bmatrix}3 &amp; 4 &amp; 5 \\5 &amp; 3 &amp; 4 \\4 &amp; 5 &amp; 3 \\\\end{bmatrix}$$ 接下来构造如下图： 该图包含$n^2$个顶点，每个顶点对应于矩阵中的一个元素。记与元素$b_{i,j}$对应的顶点为$(i, j)$。 当且仅当$|i_1 - i_2| + |j_1 - j_2| \\le k$ 且$\\gcd(b_{i_1, j_1}, b_{i_2, j_2}) &gt; 1$时，在顶点$(i_1, j_1)$和$(i_2, j_2)$之间画一条边，其中$\\gcd(x, y)$表示整数$x$和$y$的最大公约数。 你的任务是计算所得图中的连通分量的数量。 连通分量是图中的一个顶点集合，其中任何一个顶点可以通过边到达集合中的任意其他顶点，并且添加任何其他顶点到集合中会违反此规则。 曼哈顿距离的几何意义就是一个旋转了 45度 的正方形。因为矩阵的构造方式是特殊的，所以每条斜对角线上的元素都是相同的。将这 $2n - 1$ 条斜对角线自左下到右上标号 $1, 2, \\ldots, 2n - 1$，那么曼哈顿距离的限制就转化为每条斜对角线和上下相邻的各 k 条斜对角线。 那么现在转化为了一个序列大小为 $m = 2n - 1$ 的序列问题。不需要同时考虑两个方向，从左到右做，维护一个 las[p] 代表 p 这个质因子上次出现的位置，如果 i - las[p] &lt;= k 则连边即可。 Code","link":"/codeforces-round-953-div-2/"},{"title":"Codeforces Round 934 (Div. 2)","text":"比赛链接 A[Codeforces 1944A] Destroying Bridges.cpp >folded1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;// #define int long longusing pii = std::pair&lt;int, int&gt;;using tuu = std::tuple&lt;int, int, int&gt;;#define pb push_backusing std::cin, std::cout, std::string, std::vector;int read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 1e6 + 5;// const int INF = 1e18;int n, m, a[N];void solve(){ n = read(), m = read(); if (m &gt;= n - 1) return puts(&quot;1&quot;), void(); int k = n - 1; while (m &gt;= k and k &gt; 0) n--, m -= k, k--; cout &lt;&lt; n &lt;&lt; '\\n';}signed main(){#ifndef ONLINE_JUDGE freopen(&quot;A.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;} B[Codeforces 1944B] Equal XOR.cpp >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;// #define int long longusing pii = std::pair&lt;int, int&gt;;using tuu = std::tuple&lt;int, int, int&gt;;#define pb push_backusing std::cin, std::cout, std::string, std::vector;int read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 1e6 + 5;// const int INF = 1e18;int n, m, a[N];void solve(){ n = read(), m = read() * 2; int cnta = m, cntb = m; vector&lt;int&gt; a(n), b(n), ansa, ansb; for (int i = 0; i &lt; n; i++) a[i] = read() - 1; for (int i = 0; i &lt; n; i++) b[i] = read() - 1; vector&lt;int&gt; visa(n, 0), visb(n, 0), pushed(n, 0); for (int i = 0; i &lt; n and cnta &gt; 0; i++) { if (visa[a[i]] and cnta &gt;= 2) cnta -= 2, ansa.pb(a[i]), ansa.pb(a[i]), pushed[a[i]] = 1; visa[a[i]] = 1; } for (int i = 0; i &lt; n and cntb != cnta; i++) { if (visb[b[i]] and cntb &gt;= 2) cntb -= 2, ansb.pb(b[i]), ansb.pb(b[i]), pushed[b[i]] = 1; visb[b[i]] = 1; } for (int i = 0; i &lt; n and cnta &gt; 0; i++) if (!pushed[a[i]]) ansa.pb(a[i]), ansb.pb(a[i]), cnta --; for (auto x : ansa) cout &lt;&lt; x + 1 &lt;&lt; ' '; puts(&quot;&quot;); for (auto x : ansb) cout &lt;&lt; x + 1 &lt;&lt; ' '; puts(&quot;&quot;);}signed main(){#ifndef ONLINE_JUDGE freopen(&quot;B.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;} C[Codeforces 1944C] MEX Game 1.cpp >folded123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;// #define int long longusing pii = std::pair&lt;int, int&gt;;using tuu = std::tuple&lt;int, int, int&gt;;#define pb push_backusing std::cin, std::cout, std::string, std::vector;int read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 1e6 + 5;// const int INF = 1e18;int n, m, a[N];void solve(){ n = read(); vector&lt;int&gt; cnt(n + 1, 0); for (int i = 1; i &lt;= n; i++) a[i] = read(), cnt[a[i]] ++; for (int i = 0, tmp = 0; i &lt;= n; i++) { tmp += (cnt[i] == 1); if (!cnt[i] or cnt[i] and tmp == 2) { cout &lt;&lt; i &lt;&lt; '\\n'; break; } }}signed main(){#ifndef ONLINE_JUDGE freopen(&quot;C.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;} D A string $t$ is said to be $k$-good if there exists at least one substring$^\\dagger$ of length $k$ which is not a palindrome$^\\ddagger$. Let $f(t)$ denote the sum of all values of $k$ such that the string $t$ is $k$-good. You are given a string $s$ of length $n$. You will have to answer $q$ of the following queries: Given $l$ and $r$ ($l &lt; r$), find the value of $f(s_ls_{l + 1}\\ldots s_r)$. 一个字符串 t 如果至少存在一个长度为 k 的子串不是回文，则可以被称作是 k-good。每次求一个串的所有 k-good 的和 e.g. 对于 s[1…..10]，如果 k = 4，而且 s[1…4] 是回文串。也就是说 s[1] == s[4], s[2] == s[3] 假如后面也都是回文串，那么有 s[2] == s[5], s[3] == s[4] …… 不考虑自身的情况下： 如果一个串偶数位奇数位对应相等，那么对于所有 奇数 k 都是不好的 如果一个串每一位都相等，那么对于所有 k 都是不好的 如果一个串不是奇数位和偶数位都对应相等，那么 2 &lt;= k &lt;= len - 1 的奇数 k 也都是好的 如果一个串不是每一位都相等，那么 2 &lt;= k &lt;= len - 1 的偶数 k 都是好的 接下来再考虑一下自身是不是回文串即可 唉这个题赛时没发现这个性质，然后补题发现 hash 也不会打了 CF 赛制单模数 hash 也容易被 hack，最保险的是双随机模数 hash [Codeforces 1944D] Non-Palindromic Substring.cpp >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;#define int long longusing pii = std::pair&lt;int, int&gt;;using tuu = std::tuple&lt;int, int, int&gt;;#define pb push_backusing std::cin, std::cout, std::string, std::vector;int read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 1e6 + 5;// const int INF = 1e18;int n, m, a[N];std::vector&lt;int&gt; manacher(string s){ string t = &quot;#&quot;; for (auto ch : s) t += ch, t += '#'; int n = t.size(); vector&lt;int&gt; r(n); for (int i = 0, j = 0; i &lt; n; i++) { if (2 * j - i &gt;= 0 and j + r[j] &gt; i) r[i] = std::min(r[2 * j - i], j + r[j] - i); while (i - r[i] &gt;= 0 and i + r[i] &lt; n and t[i - r[i]] == t[i + r[i]]) r[i]++; if (i + r[i] &gt; j + r[j]) j = i; } return r;}void solve(){ n = read(), m = read(); string s; cin &gt;&gt; s; vector&lt;int&gt; f1(n), f2(n); for (int i = n - 1; ~i; i--) f1[i] = i + 1 &lt; n and s[i] == s[i + 1] ? f1[i + 1] : i, f2[i] = i + 2 &lt; n and s[i] == s[i + 2] ? f2[i + 2] : i; auto rad = manacher(s); for (int l, r; m--; ) { l = read() - 1, r = read() - 1; int ans = 0, len = r - l + 1; if (f1[l] &lt; r) { // 存在偶数 k int m = (len - 1) - (len - 1) % 2; ans += (m + 2) * (m / 2) / 2; } if (f2[l] + 1 &lt; r or f2[l + 1] + 1 &lt; r) { // 存在奇数 k int m = len - 1 - len % 2; ans += (m + 3) * ((m - 1) / 2) / 2; } if (rad[l + r + 1] &lt; len) ans += len; cout &lt;&lt; ans &lt;&lt; '\\n'; }}signed main(){#ifndef ONLINE_JUDGE freopen(&quot;D.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;} E 给你一棵树，树上有 $n$ 个顶点，编号为 $1, 2, \\ldots, n$ 。最初，所有顶点都被涂成白色。 您可以执行以下两步操作： 选择顶点 $v$ ( $1 \\leq v \\leq n$ ) 和距离 $d$ ( $0 \\leq d \\leq n-1$ )。 对于所有顶点 $u$ ( $1 \\leq u \\leq n$ ) 且 $\\text{dist}^\\dagger(u,v)=d$ 的顶点，将 $u$ 着色为黑色。构造一个操作序列，用尽可能少的操作次数将树中的所有节点涂成黑色。可以证明，我们总是可以用最多 $n$ 次的操作来实现这一目的。 考虑一条链上的情况，分奇偶讨论，最优的方法一定是从中心开始，向两边拓展 树上呢？用直径即可 [Codeforces 1944E] Tree Compass.cpp >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;// #define int long longusing pii = std::pair&lt;int, int&gt;;using tuu = std::tuple&lt;int, int, int&gt;;#define pb push_backusing std::cin, std::cout, std::string, std::vector;int read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 1e6 + 5;// const int INF = 1e18;int n, m, a[N];void solve(){ n = read(); vector&lt;vector&lt;int&gt;&gt; g(n); for (int i = 1, u, v; i &lt; n; i++) u = read() - 1, v = read() - 1, g[u].pb(v), g[v].pb(u); vector&lt;int&gt; fa(n); auto find = [&amp;](int rt) { vector&lt;int&gt; dep(n, -1); fa[rt] = -1, dep[rt] = 0; std::queue&lt;int&gt; Q; Q.push(rt); for (int u; !Q.empty(); ) { u = Q.front(); Q.pop(); for (auto v : g[u]) if (dep[v] == -1) dep[v] = dep[u] + 1, Q.push(v), fa[v] = u; } return std::max_element(dep.begin(), dep.end()) - dep.begin(); }; int X = find(0); int Y = find(X); vector&lt;int&gt; a; for (int i = Y; i != -1; i = fa[i]) a.pb(i); vector&lt;pii&gt; ans; int d = a.size(); if (d &amp; 1) { int p = a[d / 2]; for (int i = 0; i &lt;= d / 2; i++) ans.pb({p, i}); } else { int p = a[d / 2], q = a[(d - 1) / 2]; for (int i = 1; i &lt;= d / 2; i += 2) ans.pb({p, i}), ans.pb({q, i}); } cout &lt;&lt; ans.size() &lt;&lt; '\\n'; for (auto [x, y] : ans) cout &lt;&lt; x + 1 &lt;&lt; ' ' &lt;&lt; y &lt;&lt; '\\n';}signed main(){#ifndef ONLINE_JUDGE freopen(&quot;D.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;} F1 这是问题的简单版本。两个版本的唯一区别在于对 $n$ 的限制。只有两个版本的问题都解决了，才能进行破解。 一个由 $m$ 个非负整数组成的数组 $b$ 中，如果 $b$ 中的所有元素都可以通过下面的操作使其等于 $0$ ，那么这个数组就是好数组： 选择两个不同的索引 $l$ 和 $r$ ( $1 \\leq l \\color{red}{&lt;} r \\leq m$ )，然后从所有 $b_i$ 中减去 $1$ 使得 $l \\leq i \\leq r$ . 给你两个正整数 $n$ ， $k$ 和一个质数 $p$ 。 在所有长度为 $n$ 的所有 $(k+1)^n$ 数组中，对于所有 $1 \\leq i \\leq n$ ，长度为 $0 \\leq a_i \\leq k$ 的数组有多少个？ 由于这个数字可能太大，所以只要求求出取模 $p$ 的个数。 观察性质题又没找到性质哈哈 每次对 i 的操作必然包含了 i - 1 或 i + 1, 所以 i 能减到 0 的必要条件是 a[i] &lt;= a[i - 1] + a[i + 1] 那么这是否是充分的呢？官方 editorial 里面有归纳法的证明。 不妨感性理解一下（） 设相邻的三个数为 abc，那么要满足 b &lt;= a + c, 也就是 c &gt;= b - a f[a][b] 表示最后两个数分别是 a, b 的个数 那么 f[b][c] 就等于所有 b - a &lt;= c 的 f[a][b] 之和 [Codeforces 1944F1] Counting Is Fun (Easy Version).cpp >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longusing pii = std::pair&lt;int, int&gt;;using tuu = std::tuple&lt;int, int, int&gt;;#define pb push_backusing std::cin, std::cout, std::string, std::vector;int read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 1e6 + 5;// const int INF = 1e18;int n, k, p;void solve(){ n = read(), k = read(), p = read(); vector&lt;vector&lt;int&gt;&gt; f(k + 1, vector&lt;int&gt;(k + 1, 0)); f[0][0] = 1; for (int i = 1; i &lt;= n; i++) { vector&lt;vector&lt;int&gt;&gt; g(k + 1, vector&lt;int&gt;(k + 1, 0)); // g 先存恰好 c = b - a 的，最后再求和 for (int b = 0; b &lt;= k; b++) { for (int a = 0; a &lt;= k; a++) { int c = std::max(0LL, b - a); g[b][c] += f[a][b], g[b][c] %= p; } for (int j = 1; j &lt;= k; j++) g[b][j] += g[b][j - 1], g[b][j] %= p; } f.swap(g); } int ans = 0; for (int a = 0; a &lt;= k; a++) for (int b = 0; b &lt;= a; b++) ans += f[a][b], ans %= p; cout &lt;&lt; ans &lt;&lt; '\\n';}signed main(){#ifndef ONLINE_JUDGE freopen(&quot;D.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;}","link":"/codeforces-round-934-div-2/"},{"title":"Codeforces Round 956 (Div. 2) and ByteRace 2024","text":"印度 Round = 拉马努金 Round 要做出题需要一点灵感，但是在某些方面还挺有启发性的。 比赛链接 Problems AC A. Array Divisibility ○ B. Corner Twist ○ C. Have Your Cake and Eat It Too ○ D. Swap Dilemma ○ E. I Love Balls ⊕ F. array-value ⊕ G. Your Loss A 如果满足以下条件，则整数数组 $a _ 1,a _ 2,\\cdots,a _ n$ 是整数 $k$ 的优美对象： $a _ {j}$ 与所有 $j$ 之和，使得 $j$ 是 $k$ 的倍数，而 $1 \\le j \\le n $ 本身是 $k$ 的倍数。 更正式地说，如果对于所有 $1 \\le j \\le n$ ， $\\sum _ {k | j} a _ {j}$ 都能被 $k$ 整除，则数组 $a$ 是对于 $k$ beautiful。这里，符号 ${k|j}$ 表示 $k$ 能整除 $j$ ，也就是说， $j$ 是 $k$ 的倍数。 给定 $n$ ，找到一个正非零整数数组，每个元素都小于或等于 $10^5$ ，并且对于所有 $1 \\le k \\le n$ beautiful。 可以证明答案总是存在的。 输出 1 到 n 即可。 Code B 您将获得两个数字网格 $a$ 和 $b$ ，行数为 $n$ ，列数为 $m$ 。网格中的所有值均为 $0$ 、 $1$ 或 $2$ 。 您可以对 $a$ 执行任意次以下操作： 在网格中选取任意子矩形，其长度和宽度为 $\\ge 2$ 。您可以选择整个网格作为子矩形。 子矩形有四个角。取所选子矩形的任意对角，并将 $1$ 添加到它们的值中，以 $3$ 为模。 对于未选中的角对，将 $2$ 添加到它们的值中，以 $3$ 为模。 请注意，此操作仅更改所选子矩形的角的值。 是否可以通过多次(可能是零次)应用上述操作将网格 $a$ 转换为网格 $b$ ？ 一个显然的性质是，所有的操作都可以被分解成若干个 2 * 2 的操作 Code C Alice、Bob 和 Charlie 想要分享一块切成 $n$ 块的矩形蛋糕。每个人认为每块蛋糕的价值都不同。Alice 认为第 $i$ 块蛋糕的价值为 $a_i$ ，Bob 认为是 $b_i$ ，Charlie 认为是 $c_i$ 。 所有 $a_i$ 、所有 $b_i$ 和所有 $c_i$ 的总和相同，等于 $tot$ 。 鉴于每个人每块蛋糕的价值，您需要给每个人一块连续的蛋糕。换句话说，这些子数组左端和右端的索引（分配给每个人的切片）可以分别表示为 Alice、Bob 和 Charlie 的 $(l_a, r_a)$ 、 $(l_b, r_b)$ 和 $(l_c, r_c)$ 。除法需要满足以下约束： 没有一块分配给超过一个人，即 $[l_a,\\ldots,r_a]$ 、 $[l_b, \\ldots, r_b]$ 和 $[l_c, \\ldots, r_c]$ 之间的任何两个子数组都不相交。 $ \\sum_{i = l_a}^{r_a} a_i, \\sum_{i = l_b}^{r_b} b_i, \\sum_{i = l_c}^{r_c} c_i \\geq \\lceil \\frac{tot}{3} \\rceil$ 。 直接枚举 Code D 逆序对、树状数组 给定两个不同的正整数数组 $a$ 和 $b$ ，长度为 $n$ ，我们希望使这两个数组相同。如果对于所有 $1 \\le i \\le k$ ，都是 $x_i = y_i$ ，则两个长度为 $k$ 的数组 $x$ 和 $y$ 相同。 现在，您只需一步，即可在 $a$ ( $l \\le r$ ) 中选择某个索引 $l$ 和 $r$ 并交换 $a_l$ 和 $a_r$ ，然后在 $b$ 中选择某个索引 $p$ 和 $q$ ( $p \\le q$ )，使得 $r-l=q-p$ 并交换 $b_p$ 和 $b_q$ 。 是否可以使两个数组相同？ 可以每次都用长度为 2 的进行交换，那相当于上下同时进行冒泡排序 只要排序次数相同，即逆序对数相同，就能同时到达有序的状态 upd: 赛后发现普通清空树状数组容易被卡，需要用时间戳清空 Code E 期望、组合数学 Alice 和 Bob 正在玩游戏。有 $n$ 个球，其中 $k$ 个是特殊的。每个球都有一个与之关联的值。 玩家轮流玩游戏。在每个回合中，玩家随机挑选一个球并将球的值添加到他们的分数中，游戏开始时的分数为 $0$ 。选定的球将从游戏中移除。如果球是特殊的，则同一玩家在至少剩余一个球的情况下进行下一轮。如果挑选的球不是特殊的，则下一个玩家轮到他们。 他们玩这个游戏，直到游戏中没有剩余的球。Alice 先玩。 求出游戏结束时两位玩家的预期分数，模数为 $10^9+7$ 。 正式地，设 $M = 10^9+7$ 。可以证明答案可以表示为不可约分数 $\\frac{p}{q}$ ，其中 $p$ 和 $q$ 为整数和 $q \\not \\equiv 0 \\pmod{M}$ 。输出等于 $p \\cdot q^{-1} \\bmod M$ 的整数。换句话说，输出这样一个整数 $x$ ，即 $0 \\le x &lt; M$ 和 $x \\cdot q \\equiv p \\pmod{M}$ 。 神笔题，这场感觉都是脑筋急转弯。 整个过程相当于先选完普通的球，然后把特殊的球放进去插空。 那么现在我们先来考虑普通的球，假如 $n$ 个都是普通球 Alice 先选的话，他能选到 $\\lfloor\\frac{n + 1}{2}\\rfloor$ 个球，每个球的价值平均下来是 $\\frac{\\sum v_i}{n}$。所以他的期望收益是 $\\lfloor\\frac{n + 1}{2}\\rfloor \\cdot \\frac{\\sum v_i}{n}$ 现在考虑有特殊球的情况，相当于 $n - k$ 个普通球的序列有 $n - k + 1$ 个空，每个特殊球随机插空。 假如先拿普通球，Alice 期望拿 $\\lfloor\\frac{n - k}{2}\\rfloor$ 个球，那么 Alice 期望有 $\\lfloor\\frac{n - k}{2}\\rfloor + 1$ 个空。 总共是 $k$ 个特殊球，一共是 $n - k + 1$ 个空，那么每个空期望有 $\\frac{k}{n - k + 1}$ 个特殊球。 那么在 Alice 这边，期望的空的数量乘上每个空期望的特殊球数量，就是 Alice 一共期望遇到的特殊球数量：$(\\lfloor\\frac{n - k}{2}\\rfloor + 1) \\cdot \\frac{k}{n - k + 1}$ 所以 Alice 的期望收益是： $$\\frac{(\\lfloor\\frac{n - k}{2}\\rfloor + 1) \\cdot k}{n - k + 1} \\cdot \\frac{\\sum_{i = 1}^{k}v_i}{k} + \\lfloor\\frac{n - k + 1}{2}\\rfloor \\cdot \\frac{\\sum_{i = k + 1}^{n}v_i}{n - k}$$ Code F 二分、Trie 您有一个非负整数数组 $a_1, a_2, \\ldots, a_n$ 。 长度 $\\ge 2$ 的子数组的值, $a[l, r] = [a_l, a_{l+1}, \\ldots, a_r]$ 是 $a_i \\oplus a_j$ 的最小值，使得 $l \\le i &lt; j \\le r$ ，其中 $\\oplus$ 是异或 (排他或) 运算符。 您必须在所有长度为 $\\ge 2$ 的子数组中找到 $k$ -th 最小的值。 有一个观察是这个东西是随着区间变大单调不增的，也就是说我们可以固定一端，通过某个方式查询另一个端点的位置。 首先二分答案，这样你要查的值就确定了。从左往右对于每个数，在 Trie 上面贪心找答案，然后加入 Trie。 Implemention 有细节，具体看代码。 总结：Trie 可以类似线段树维护信息，因为不好维护区间信息，常常是搭配动态加入使用 Code","link":"/codeforces-round-956-div-2-and-byterace-2024/"},{"title":"Codeforces Round 955 (Div. 2, with prizes from NEAR!)","text":"重生之我是 Jumping 比赛链接 Problems AC A. Soccer ○ B. Collatz Conjecture ○ C. Boring Day ○ D. Beauty of the mountains ○ E. Number of k-good subarrays ⊕ F. Sorting Problem Again ⊕ ACode BCode C DPCode D 裴蜀定理 地图是一张表格，包含 $n$ 行和 $m$ 列，每个单元格包含一个非负整数，代表山脉的高度。 他还注意到山脉有两种类型： 有雪山。 没有雪山。 Nikita 希望有雪山的山脉高度总和等于没有雪山的山脉高度总和。 Nikita 可以对大小为 $k \\times k$ 的子矩阵执行如下变换：他可以将一个整数常数 $c$ 添加到此区域内的山脉高度，但山脉类型保持不变。Nikita 可以为每个变换独立选择常数 $c$ 。请注意， $c$ 可以为负数。 在进行变换之前，Nikita 会要求您找出是否有可能实现总和相等，或者是否不可能。即使山脉变成峡谷并且高度为负数，代价也无关紧要。 如果地图上仅显示一种类型的山脉，则另一种类型的山脉的高度总和将被视为零。 $1 \\le n, m \\le 500, 1 \\le k \\le min(n, m)$ 对于每个子矩阵，其实收益相当于 这个子矩阵里面两种元素的个数差 那么问题转化为有大约 $n^2$ 个非负整数，每个可以任选无限多个，能否将最后的和凑成 $X$ 裴蜀定理的多元推广，算 GCD 即可 Code E 数位 DP 令 $bit(x)$ 表示非负整数 $x$ 的二进制表示中 1 的数量。 如果数组的子数组仅由二进制表示中 1 不超过 $k$ 个数字组成，则称该子数组为 $k$-good，即，如果对于任何 $i$ 都满足 $l \\le i \\le r$ 条件 $bit(a _ {i}) \\le k$ ，则数组 $a$ 的子数组 $(l, r)$ 为 good。 给定一个长度为 $n$ 的数组 $a$ ，由从 $0$ 开始的连续非负整数组成，即，对于 $0 \\le i \\le n - 1$ (以 $0$ 为基础的索引)，其值为 $a _ {i} = i$ 。您需要计算此数组中 $k$-good 的数量。 由于答案可能非常大，请将其以 $10^{9} + 7$ 为模输出。 $1 \\le n \\le 10^{18}, 1 \\le k \\le 60$ 参考自 cup-pyy 可以看出合法的区间是成段的 假设不存在 n 的限制，每个区间都可以被一组左闭右开的端点表示。假若右端点是 xxxx101111 有 k + 1 个 1，那么左端点就是 xxxx100000，因为再减 1 的话变成 xxxx011111，也会有 k + 1 个 1 所以只要 最后一个 0 的位置被确定了，那么最后一段 1 的数量也就确定了，区间的长度也就确定了。用数位 dp 的方式去搜索右端点来实现。 注意到还有 n 的限制，因为我们是搜索右端点的，所以有些左端点小于等于 n 右端点 大于 n 的区间被忽略了，我们最后需要补上这一部分区间。 Code F 你有一个包含 $ n $ 个元素的数组 $ a $。该数组将进行 $ q $ 次修改。在每次修改之前和之后，你需要确定以下内容： 找到一个需要排序成非递减顺序的最短子数组，使整个数组 $ a $ 变为非递减顺序。 更具体地，你需要选择一个数组的子数组 $(l, r)$ ，使得 $ r - l + 1 $ 的值最小。然后，你会对子数组 $ a_{l}, a_{l + 1}, \\ldots, a_{r} $ 进行排序，并希望满足条件 $ a_{i} \\le a_{i + 1} $ 对于所有 $ 1 \\le i &lt; n $ 成立。如果数组已经是非递减顺序的，那么 $ l $ 和 $ r $ 应该被视为等于 $-1$。 注意，找到这样的 $(l, r)$ 并不会改变数组的任何元素。修改本身的形式为：对给定的位置 $ pos $ 和值 $ x $，进行赋值 $ a[pos] = x $。 Hint: 如果您维护一组这样的索引 $i$ : $a_{i} &lt;a_{i - 1}$ ，那么这能有什么帮助吗？ 这样维护后序列变成了形如 0001010111000 的样子。 注意到，从开头到第一个 1，和最后一个 1 到结尾这两个区间都是本身就有序的，中间一段不可名状物体。对于中间这一段是一定要全部排序的，那么序列变成了三段有序的（拼在一起不一定有序）。为了使得拼在一起有序，需要知道中间那一段的 min 和 max，然后在前面一段查 min 的位置，后面一段查 max 的位置 代码实现用 multiset + 二分 可以比较优雅。 Code","link":"/codeforces-round-955-div-2-with-prizes-from-near/"},{"title":"Codeforces Round 958 (Div. 2)","text":"最自闭的一集。 tbh 赛前一整天心理状态都不太好，压力也很大。稍微甩个锅吧。 出题人：I failed to find a Div2-A level proof. If you have a simpler proof please share it in the comments. 比赛链接 Problems AC A. Split the Multiset ○ B. Make Majority ○ C. Increasing Sequence with Fixed OR ○ D. The Omnipotent Monster Killer ⊕ E. Range Minimum Sum ⊕ F. Heartbeat A 你有一个 multiset $S$，初始时集合中只包含一个正整数 $n$，即 $S={n}$。另外，给定一个正整数 $k$。 在每次操作中，你可以选择 $S$ 中的任意一个正整数 $u$，从 $S$ 中移除一个 $u$，然后向 $S$ 中插入至多 $k$ 个正整数，使得插入的所有整数之和等于 $u$。 找到使得 $S$ 包含 $n$ 个 $1$ 的最小操作次数。 想象一下，把一开始那个 $n$ 看成是 $n$ 个 $1$ 构成的一条链，有 $n - 1$ 条边。 你每次操作相当于是断开 $k - 1$ 条边。 所以答案自然是 $$\\lceil \\frac{n-1}{k-1}\\rceil$$ Code BCode C 二进制 给定一个正整数 $n$。找到满足以下条件的最长正整数序列 $a=[a_1,a_2,\\ldots,a_k]$，并打印这个序列： 对于所有 $1 \\leq i \\leq k$，满足 $a_i \\leq n$。 序列 $a$ 是严格递增的，即对于所有 $2 \\leq i \\leq k$，有 $a_i &gt; a_{i-1}$。 对于所有 $2 \\leq i \\leq k$，满足 $a_i ,|, a_{i-1} = n$，其中 $|$ 表示按位或运算。 做到 C 题的时候已经是究极降至了，构造题 spj 输出和样例不一样想了半天为什么。。。。 首先，我们把 n 用二进制表示，例如 23 是 10111。 对于 n 里面 0 的那些位，是不用管的，因为那些位肯定一直都是 0。 假设 n 在二进制下最高位是 k。那么 $a_1$ 的第 k 位肯定是 0，且后面的数的第 k 位肯定是 1。那么问题就变成了一个子问题。 Code D 树形 DP 你，作为怪物杀手，想要消灭一组生活在一棵有 $n$ 个顶点的树上的怪物。第 $i$ 个顶点上有一个攻击力为 $a_i$ 的怪物。你打算进行 $10^{100}$ 轮战斗。 每一轮战斗的流程如下： 所有存活的怪物都会攻击你。你的健康值会减少等于所有存活怪物攻击力之和的量。 你可以选择一些（可能是全部或者一些）怪物来杀死。一旦被杀死，这些怪物将不会在未来的战斗中再次攻击。 有一个限制：在一轮战斗中，你不能同时杀死两个直接相连的怪物。 如果你以最优方式选择要攻击的怪物，那么在所有轮战斗结束后，你可以达到的健康值减少的最小值是多少？ 有一个想法是这个轮数不会很多，大概是 log 量级的。 Why？参考下官方题解的证明，你可以这样想。设每个点的轮数是 $b_i$。 首先对于每个点来说，他的 $b_i$ 一定是直接相邻点的 mex 对吧。 那么假如 点 u 的 $b_u = x$ 是所有节点里面最大的，我们将 u 看作一棵树的根。他必须要有下家 1 ~ x - 1。令 $f(x)$ 表示能满足这个条件所需的最少节点数，那么有 $ f(1)=1,\\ f(x)\\ge 1+\\sum_{1\\le i&lt;x}f(i)\\to f(x)\\ge 2^{x-1}$ 也就是 $n \\ge 2^{x - 1}$，即最大的数不超过 logn + 1。 剩下的问题其实相当于一个填数问题，每个点不能和相邻的点填一样的。 $$f_{u, i} = i\\times a_{u} + \\sum_{v\\in \\operatorname{son}(u)} \\min_{j\\not= i} f_{v, j}$$ 可以前后缀最值做到 $O(nm)$，但是本题直接转移 $O(nm^2)$ 已经足够通过。 Code E 单调栈 对于长度为 $n$ 的数组 $[a_1, a_2, \\ldots, a_n]$，定义 $f(a)$ 为所有子段中最小元素的和。具体地， $$f(a) = \\sum_{l=1}^n \\sum_{r=l}^n \\min_{l \\leq i \\leq r} a_i.$$ 给定一个排列 $[a_1, a_2, \\ldots, a_n]$。对于每个 $i$，独立解决以下问题： 从数组 $a$ 中删除 $a_i$，得到剩余的数组 $b = [a_1, a_2, \\ldots, a_{i-1}, a_{i+1}, \\ldots, a_n]$。 计算 $f(b)$。 假如不带删除操作的话是个典题，用单调栈可以 O(n) 求出每个 i 之前和之后第一个 &lt; a[i] 的位置 l[i], r[i]。那么答案就是 $\\sum{a_i \\times (i - l_i) \\times (r_i - i)}$ 那么你想，对于一个 i 来说，假如我们现在要删掉 a[j]： 假如 1 &lt;= j &lt; l[i] or r[i] &lt; j &lt;= n，那么 a[i] 的贡献还是没变。 假如 l[i] &lt; j &lt; i，那么 a[i] 的贡献变成了 $a_i \\times (i - l_i - 1) \\times (r_i - i)$，因为左边可取的少了一个。对于 i &lt; j &lt; r[i]，类似。 假如 j = l[i] or j = r[i] 呢，那么就需要用到次小值，这个次小值其实在单调栈过程中是可以一起求出来的。 Code","link":"/codeforces-round-958-div-2/"},{"title":"Codeforces Round 954 (Div. 3)","text":"发现自己的小号已经 unrated for div3 了 这什么神笔场，F 不会求割边和点双被卡科技了，G1 G2 赛时想出正解但是以为自己的复杂度是错的就没写。。。 比赛链接 Problems AC A. X Axis ○ B. Matrix Stabilization ○ C. Update Queries ○ D. Mathematical Problem ○ E. Beautiful Array ○ F. Non-academic Problem ⊕ G1. Permutation Problem (Simple Version) ⊕ G2. Permutation Problem (Hard Version) ⊕ ACode BCode CCode DCode E 给定一个整数数组 $a_1, a_2, \\ldots, a_n$ 和一个整数 $k$。你需要通过最少的操作次数使这个数组变得美丽。 在应用操作之前，你可以随意打乱数组的元素。每次操作你可以执行以下步骤： 选择一个索引 $1 \\leq i \\leq n$， 将 $a_i$ 的值增加 $k$，即 $a_i = a_i + k$。 如果数组 $b_1, b_2, \\ldots, b_n$ 满足 $b_i = b_{n - i + 1}$ 对于所有 $1 \\leq i \\leq n$ 成立，那么数组就是美丽的。 找到使数组美丽所需的最少操作次数，或者报告这是不可能的。 按剩余系分组，然后把是奇数的那一组挑出来，枚举让哪个成为特殊的就行了 Code F 桥，点双，割边，tarjan 你有一个连通的无向图，其顶点编号为从 $1$ 到 $n$ 的整数。你的任务是最小化图中存在路径的顶点对 $1 \\leq u &lt; v \\leq n$ 的数量。为此，你可以从图中恰好移除一条边。 找到使得存在路径的顶点对数量最小的情况！ 不是哥们.jpg，这是 CF 还是 AT 啊，怎么搞个这种纯知识点板子题，一点思维含量都没有。 （关键是我还没学过点双和边双（（（（（（ 赛后学习了下 jls 的板子 Code G 给定一个长度为 $ n $ 的排列 $ p $。计算满足 $ p_i \\cdot p_j $ 可以被 $ i \\cdot j $ 整除的索引对 $ 1 \\leq i &lt; j \\leq n $ 的数量。 $ n \\leq 5 \\cdot 10^5 $ 对于一组 $(a[i], i)$，他们的 $gcd$ 是不重要的。同时先把 $gcd$ 除掉，记 $(a[i] / gcd, i / gcd)$ 为 $(x, y)$ $x$ 是多出来，$y$ 是缺少的。要想合法的话必须找到另外一组 $(u, v)$，使得 $u$ 能补上 $y$ 缺的，$x$ 能补上 $v$ 缺的，即 $u$ 是 $y$ 的倍数，$x$ 是 $v$ 的倍数 具体实现上，用两个 vector pos1, pos2。pos1[y].pb(x)，pos2[x].pb(y) 枚举 $y$，然后枚举 $y$ 的倍数 $u$。对于每个 $u$ 对应的一大堆 $v$，把这些 $v$ 对应的计数器加上 cnt[v]++。然后把 $y$ 所对应的 $x$ 的因子都找出来。因为这些因子是 $x$ 可能补上的 $v$。 记得要减去自己和自己配对的情况（y == 1），以及顺序颠倒算重的部分 Code","link":"/codeforces-round-954-div-3/"},{"title":"Codeforces Round 961 (Div. 2)","text":"C：log 推柿子D：正难则反，dp 补集比赛链接 Problems AC A. Diagonals ○ B1. Bouquet (Easy Version) ○ B2. Bouquet (Hard Version) ○ C. Squaring ⊕ D. Cases ⊕ E1. Let Me Teach You a Lesson (Easy Version) E2. Let Me Teach You a Lesson (Hard Version) B2 这是问题的困难版本。唯一的区别是，在这个版本中，不是列出每朵花的花瓣数量，而是为所有类型的鲜花设置了花瓣数量和商店中的鲜花数量。 一个女孩正在准备她的生日，想要买一束最美丽的花束。商店里共有 $n$ 种不同类型的鲜花，每种鲜花的特征是花瓣数量和该类型鲜花的数量。一朵有 $k$ 片花瓣的花需要 $k$ 个金币。女孩决定，她用来装饰蛋糕的任何两朵花之间的花瓣数量差异不应超过一朵。与此同时，女孩想要组装一束花瓣数量尽可能多的花束。不幸的是，她只有 $m$ 币，她不能花更多的钱。她最多可以在花束中组装多少片花瓣？ 这个 B2 主要的难点是，每个物品的数量可以有多个。这其实变成了一个类似于背包的问题。但是因为题目里面有个限制，你最多只需要同时考虑两个物品。 现在问题转化为，你有两种物品，价值分别是 a 和 a + 1，分别有 x 和 y 个，你需要在价值不超过 k 的情况下尽可能多拿。 那我们的策略就是先把能拿的 a 都拿了，剩下还有钱的话把 a + 1 都拿了。如果还有剩的话，可以把 a 替换成 a + 1。 这种策略显然正确，但是赛时又脑瘫代码出小问题了。。。。。。 C ikrpprpp 找到一个由整数组成的数组 $a$ 。他喜欢正义，所以他想让 $a$ 公平——也就是说，让它不减。为此，他可以对数组的索引 $1 \\le i \\le n$ 执行正义行动，将 $a_i$ 替换为 $a_i ^ 2$ （位置 $i$ 处的元素及其平方）。例如，如果 $a = [2,4,3,3,5,3]$ 和 ikrpprpp 选择对 $i = 4$ 执行正义行动，则 $a$ 会变为 $[2,4,3,9,5,3]$ 。 最少需要多少次正义行为才能使数组不减？ $1 \\le n \\le 2 \\cdot 10 ^5$ $1 \\le a_i \\le 10 ^ 6$ 这什么屑题啊。。。。。首先你是知道怎么操作的，唯一的问题就是会爆 ll。那么你知道的，我们肯定是开 log。 假如 $a[i]$ 被操作了 $c[i]$ 次。我们需要满足 $${a_i}^{2^{c_i}} \\le {a_{i+1}}^{2^{c_{i+1}}}$$ $$2^{c_i} \\ln a_i \\le 2^{c_{i+1}} \\ln a_{i+1} $$ $$2^{c_{i+1}} \\ge 2^{c_i} \\frac{\\ln a_i}{\\ln a_{i+1}}$$ $$\\displaystyle c_{i+1} \\ge c_i + \\log_2 \\frac{\\ln a_i}{\\ln a_{i+1}}$$ D 每组数据给定 $n, c, k$ 三个数和一个长度为 $n$ 、包含 $c$ 个不同字母的字符串 $s$, 要求将 $s$ 拆成若干个长度不超过 $k$ 的子串，使所有子串的末尾字符种类数最小，并输出最小数量。 $1 \\le k \\le n \\le 2^{18}$, $1 \\le c \\le 18$ 题目给定的限制相当于：选出一个字符集合 $S$，原字符串中每个长度为 $k$ 的区间至少有一个字符 $\\in S$，且原串的最后一个字符一定 $\\in S$。并使得 $\\left| S \\right|$ 最小。 相当于，对于任何一个合法的 $S$，与每一个子区间的字符集都有交。 因为不合法的 $S$ 的子集一定也是不合法的，所以我们考虑 dp 不合法的 $S$。也就是合法的 $S$ 的补集。 $f[S]$ 表示 $S$ 中的字符都不存在是否会使得答案非法。 初始我们令： 每个长度为 $k$ 的区间构成的字符集合 $s$，$f[s] = true$。 仅包含最后一个字符的状态 $s$，$f[s] = true$。 除此之外的其他状态都为 $false$。 转移就是 $\\forall 1&lt;s &lt; 2^c, f[s]=\\operatorname{AND}_{2^i \\in s}{f[s-2^i]}$ 复杂度 $O(cn + c \\times 2 ^ c)$","link":"/codeforces-round-961-div-2/"},{"title":"Codeforces Round 960 (Div. 2)","text":"比赛链接 Problems AC A. Submission Bait ○ B. Array Craft ○ C. Mad MAD Sum ○ D. Grid Puzzle ⊕ E1. Catch the Mole(Easy Version) E2. Catch the Mole(Hard Version) F. Polygonal Segments C题目 Mad MAD Sum 是否是做两次的暗示呢（） D实际上是个简单 dp 讨论题","link":"/codeforces-round-960-div-2/"},{"title":"Codeforces Round 963 (Div. 2)","text":"比赛链接 Problems AC A. Question Marks ○ B. Parity and Sum ○ C. Light Switches ○ D. Med-imize ⊕ E. Xor-Grid Problem 待补 F1. Dyn-scripted Robot (Easy Version) ⊕ F2. Dyn-scripted Robot (Hard Version) ⊕ B 给定一个包含 $n$ 个正整数的数组 $a$ 。 在一次操作中，您可以选择任何一对索引 $(i, j)$ ，使得 $a_i$ 和 $a_j$ 具有不同的奇偶校验，然后将较小的一个替换为它们的总和。更正式地： 如果是 $a_i &lt; a_j$ ，则将 $a_i$ 替换为 $a_i + a_j$ ； 否则，将 $a_j$ 替换为 $a_i + a_j$ 。 找到使数组的所有元素具有相同奇偶校验所需的最少操作数。 按奇偶性分组然后 sort，从小到大扫偶数。如果小于当前最大的奇数，就把奇数加上他。 C 有一套公寓，由 $n$ 个房间组成，每个房间的灯最初都是关闭的。 为了控制这些房间的灯光，公寓的主人决定在房间里安装芯片，以便每个房间都只有一个芯片，并且芯片的安装时间不同。具体来说，这些时间由数组 $a_1, a_2, \\ldots, a_n$ 表示，其中 $a_i$ 是在第 $i$ 个房间安装芯片的时间（以分钟为单位）。 安装芯片后，它会每 $k$ 分钟更改一次房间的灯光状态 - 它会打开灯 $k$ 分钟，然后关闭灯 $k$ 分钟，然后重新打开灯 $k$ 分钟，依此类推。换句话说，芯片在第 $a_i$ 、 $a_i + k$ 、 $a_i + 2k$ 、 $a_i + 3k$ 、 $\\ldots$ 分钟为第 $i$ 个房间更改灯光状态。 公寓中所有房间的灯最早什么时候亮？ $2k$ 是一个周期，每个灯的区间都是 $[(a[i] \\mod 2k), (a[i] \\mod 2k) + k - 1]$。直接 $t = max(a[i])$ 开始，扫每一个灯，如果不在开灯周期里面就后移到下个开灯周期的起点，这样可以保证最小。最后再扫一遍检查是否合法。 D 给定两个正整数 $n$ 和 $k$ ，以及另一个包含 $n$ 个整数的数组 $a$ 。 在一个操作中，您可以选择 $a$ 中大小为 $k$ 的任意子数组，然后将其从数组中删除而不更改其他元素的顺序。更正式地，让 $(l, r)$ 成为子数组 $a _ l, a _ {l+1}, \\ldots, a _ r$ 上的操作，使得 $r-l+1=k$ ，则执行此操作意味着将 $a$ 替换为 $[a _ 1, \\ldots, a _ {l-1}, a _ {r+1}, \\ldots, a _ n]$ 。 例如，如果是 $a=[1,2,3,4,5]$ ，并且我们在此数组上执行操作 $(3,5)$ ，它将变为 $a=[1,2]$ 。此外，操作 $(2, 4)$ 的结果为 $a=[1,5]$ ，操作 $(1,3)$ 的结果为 $a=[4,5]$ 。 您必须在 $a$ 的长度大于 $k$ (即 $|a| \\gt k$ )时重复该操作。经过此过程后，数组 $a$ 中所有剩余元素的最大可能中位数是多少？ 假如不存在删除操作，询问数列的中位数，就是二分答案，$O(n)$ 扫一遍，记录下 $&gt;=$ 他的数量和 $&lt;$ 他的数量。如果前者大于后者，就往更大的搜。 假如带上删除操作呢？首先最后剩下的数的数量是固定的 $m = (n - 1) % k + 1$。假如剩下的 $m$ 个数里面的第 $i$ 个数在原数组下标是 $j$，那 $i + 1$ 的下标只有可能是 $j + k + 1, j + 2k + 1 ……$ 也就是说，剩下来这 $m$ 个数 (在原数组里的下标 - 1) mod k + 1 以后就是 1 ~ m。所以就可以 dp 了。 dp[j] = max(dp[j], dp[j - 1] + (a[i] &gt;= x ? 1 : -1)) E 给定一个大小为 $n \\times m$ 的矩阵 $a$ ，其每个单元格包含一个非负整数。位于矩阵 $i$ 行和 $j$ 列交点处的整数称为 $a_{i,j}$ 。 我们将 $f(i)$ 和 $g(j)$ 分别定义为 $i$ 行和 $j$ 列中所有整数的 XOR。在一次操作中，您可以： 选择任意行 $i$ ，然后为每个 $1 \\le j \\le m$ 分配 $a_{i,j} := g(j)$； 或选择任意列 $j$ ，然后为每个 $1 \\le i \\le n$ 分配 $a_{i,j} := f(i)$ 。 对矩阵的列 $2$ 应用操作的示例。 在此示例中，当我们对列 $2$ 应用操作时，此列中的所有元素都会更改： $a_{1,2} := f(1) = a_{1,1} \\oplus a_{1,2} \\oplus a_{1,3} \\oplus a_{1,4} = 1 \\oplus 1 \\oplus 1 \\oplus 1 = 0$ $a_{2,2} := f(2) = a_{2,1} \\oplus a_{2,2} \\oplus a_{2,3} \\oplus a_{2,4} = 2 \\oplus 3 \\oplus 5 \\oplus 7 = 3$ $a_{3,2} := f(3) = a_{3,1} \\oplus a_{3,2} \\oplus a_{3,3} \\oplus a_{3,4} = 2 \\oplus 0 \\oplus 3 \\oplus 0 = 1$ $a_{4,2} := f(4) = a_{4,1} \\oplus a_{4,2} \\oplus a_{4,3} \\oplus a_{4,4} = 10 \\oplus 11 \\oplus 12 \\oplus 16 = 29$ 您可以多次应用这些操作。然后，我们通过对所有相邻单元格对之间的绝对差求和来计算最终矩阵的 $\\textit{beauty}$ 。 更正式地说，对于所有单元格 $(x, y)$ ，其结果为 $\\textit{beauty}(a) = \\sum|a_{x,y} - a_{r,c}|$ ；如果单元格相邻，则结果为 $(r, c)$ 。如果两个单元格共用一条边，则认为它们是相邻的。 在所有可获得的矩阵中找出最小值 $\\textit{beauty}$ 。 由异或的自反性，可以很容易的将问题转化成：在一个 $(n + 1) \\times (m + 1)$ 的矩阵中删除一行和一列，使得美丽值最小 F1 + F2 这是问题的简单版本。唯一的区别是此版本为 $k \\le n$ 。只有解决了两个版本的问题后，您才能进行 hack。 给定一个 $Oxy$ 平面上的 $w \\times h$ 矩形，其中点 $(0, 0)$ 位于矩形的左下角，点 $(w, h)$ 位于矩形的右上角。 您最初在点 $(0, 0)$ 处有一个机器人，脚本 $s$ 包含 $n$ 个字符。每个字符要么是 L、R、U 或 D，分别指示机器人向左、向右、向上或向下移动。 机器人只能在矩形内移动；否则，它将更改脚本 $s$ ，如下所示： 如果它尝试移动到垂直边界之外，它会将所有 L 字符更改为 R（反之亦然，所有 R 更改为 L）。 如果它尝试移动到水平边界之外，它会将所有 U 字符更改为 D（反之亦然，所有 D 更改为 U）。 然后，它将从无法执行的字符开始执行更改后的脚本。 脚本 $s$ 将连续执行 $k$ 次。对字符串 $s$ 的所有更改即使重复也会保留。在此过程中，机器人总共会移动到点 $(0, 0)$ 多少次？请注意，初始位置不计算在内。 学到了，在这类反射问题上，有一个套路是不改变操作本身，改变坐标系。例如在光线反射的时候直接让光线穿过去。 这题同理，让机器人直接穿过去，这样相当于在一个 (mod 2w, mod 2h) 的矩形里运动 设操作完一次序列会偏移到 dx, dy 对于 esay 版本，直接枚举操作次数，每次操作以后 会偏移 dx, dy，所以每次操作前 (-dx, -dy) 会对答案有贡献，map 统计即可。 对于 hard 版本，k 很大不能枚举操作，但是可以枚举初始的位置 x, y。 设进行一整轮后会偏移 dx, dy。进行到第 i 次偏移到 x, y。 则我们需要统计满足 $x + t \\times dx \\equiv 0(\\bmod 2 w)$, $y + t \\times dy \\equiv 0(\\bmod 2 h)$，且 $0 \\leq t &lt; k$ 的 $t$ 的数量 根据基础数论知识，假如有方程 $a x + b \\equiv 0(\\bmod c)$，我们可以在 $d=\\operatorname{gcd}(a, c) \\mid b$ 时转化为 $x \\equiv$ $-\\frac{b}{d}\\left(\\frac{a}{d}\\right)^{-1}\\left(\\bmod \\frac{c}{d}\\right)$ 于是问题转化为 $t \\equiv x^{\\prime}\\left(\\bmod M_x\\right)$, $t \\equiv y^{\\prime}\\left(\\bmod M_y\\right)$ 使用 exCRT 合并：设 $t=p M_x+x^{\\prime}$ ，则 $p M_x+x^{\\prime} \\equiv y^{\\prime}\\left(\\bmod M_y\\right)$","link":"/codeforces-round-963-div-2/"},{"title":"Codeforces Round 994 (Div. 2)","text":"比赛链接 Problems AC Note A. MEX Destruction ○ B. pspspsps ○ C. MEX Cycle ○ 构造 D. Shift + Esc ○ DP E. Broken Queries ⊕ 交互、二分 F. MEX OR Mania ⊕ 启发式合并 ACode >folded123456789101112131415161718192021222324252627void solve() { int n = read(); vector&lt;int&gt; a(n + 1); for (int i = 1; i &lt;= n; i++) { a[i] = read(); } int ans = 2; int l = 0; while (l + 1 &lt;= n and a[l + 1] == 0) l++; int r = n + 1; while (r - 1 &gt;= 1 and a[r - 1] == 0) r--; bool f = 1; for (int i = l + 1; i &lt; r; i++) { if (a[i] == 0) { f = 0; break; } } if (f) ans = 1; else ans = 2; if (l == n and r == 1) ans = 0; cout &lt;&lt; ans &lt;&lt; '\\n';} BCode >folded1234567891011121314151617void solve() { int n = read(); string s; cin &gt;&gt; s; bool ans = 1; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { if (s[i] == 's' and i != 0 and s[j] == 'p' and j != n - 1) { ans = 0; break; } } } cout &lt;&lt; (ans ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; '\\n';} CCode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081int getmex(const vector&lt;int&gt;&amp; a) { std::unordered_set&lt;int&gt; s(a.begin(), a.end()); int mex = 0; while (s.find(mex) != s.end()) { mex++; } return mex;}void solve() { int n = read(); int x = read(), y = read(); vector&lt;vector&lt;int&gt;&gt; g(n + 1); for (int i = 1; i &lt;= n; i++) { int prev = (i == 1) ? n : i - 1; int next = (i == n) ? 1 : i + 1; g[i].eb(prev); g[i].eb(next); } bool f = false; for (auto v : g[x]) { if(v == y) { f = true; break; } } if (!f) g[x].eb(y), g[y].eb(x); vector&lt;int&gt; a(n + 1); std::queue&lt;int&gt; q; vector&lt;bool&gt; inq(n + 1, 0); for (int i = 1; i &lt;= n; i++) { q.ep(i); inq[i] = true; } while (!q.empty()) { int u = q.front(); q.pop(); inq[u] = 0; vector&lt;int&gt; t; for (auto v : g[u]) { t.push_back(a[v]); } int mex = getmex(t); if (a[u] != mex) { a[u] = mex; for (auto v : g[u]) { if (!inq[v]) { q.push(v); inq[v] = 1; } } } } f = 1; for (int i = 1; i &lt;= n; i++) { vector&lt;int&gt; t; for(auto v : g[i]) { t.push_back(a[v]); } int mex = getmex(t); if (a[i] != mex){ f = 0; break; } } if (!f) { cout &lt;&lt; &quot;NO\\n&quot;; return; } for (int i = 1; i &lt;= n; i++) { cout &lt;&lt; a[i] &lt;&lt; &quot; \\n&quot;[i == n]; } } DCode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263void solve() { int n = read(); int m = read(); int k = read(); vector&lt;vector&lt;int&gt;&gt; a(n, vector&lt;int&gt;(m)); for (int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; m; j++) { a[i][j] = read(); } } vector dp(m, vector&lt;int&gt;(m, INF)); for (int s = 0; s &lt; m; s++) { dp[0][s] = k * s + a[0][s % m]; } for (int j = 1; j &lt; m; j++) { for (int s = 0; s &lt; m; s++) { if (dp[j - 1][s] + a[0][(j + s) % m] &lt; dp[j][s]) { dp[j][s] = dp[j - 1][s] + a[0][(j + s) % m]; } } } for (int i = 1; i &lt; n; i++) { vector ndp(m, vector&lt;int&gt;(m, INF)); vector pre(m, INF); for (int j = 0; j &lt; m; j++) { for (int s = 0; s &lt; m; s++) { if (dp[j][s] &lt; pre[j]) { pre[j] = dp[j][s]; } } } for (int s = 0; s &lt; m; s++) { for (int j = 0; j &lt; m; j++) { int val = a[i][(j + s) % m]; if (j == 0) { ndp[j][s] = min(ndp[j][s], pre[j] + k * s + val); } else { ndp[j][s] = min({ ndp[j][s], pre[j] + k * s + val, ndp[j - 1][s] + val }); } } } dp = std::move(ndp); } int ans = INF; for (int s = 0; s &lt; m; s++) { ans = min(ans, dp[m - 1][s]); } cout &lt;&lt; ans &lt;&lt; '\\n';} ECode1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768void solve() { int n; cin &gt;&gt; n; fflush(stdout); auto ask = [&amp;](int l, int r) { cout &lt;&lt; &quot;? &quot; &lt;&lt; l &lt;&lt; &quot; &quot; &lt;&lt; r &lt;&lt; &quot;\\n&quot;; fflush(stdout); int res; cin &gt;&gt; res; fflush(stdout); return res; }; int ans = 0; if (ask(1, n / 4) != ask(n / 4 + 1, n / 2)) { // 1 in [1, n / 2] // sum[1, n / 2] = 1 // sum(n / 2, n] = 0 if (ask(1, n / 2) == 1) { // k &gt; n / 2 for (int l = n / 2 + 1, r = n - 1; l &lt;= r; ) { int mid = l + r &gt;&gt; 1; if (ask(1, mid) == 0) { ans = mid, r = mid - 1; } else { l = mid + 1; } } } else { // k &lt;= n / 2 for (int l = 2, r = n / 2; l &lt;= r; ) { int mid = l + r &gt;&gt; 1; if (ask(n / 2 + 1, n / 2 + mid) == 1) { ans = mid, r = mid - 1; } else { l = mid + 1; } } } } else { // 1 in (n / 2, n] // sum[1, n / 2] = 0 // sum(n / 2, n] = 1 if (ask(1, n / 2) == 0) { // k &gt; n / 2 for (int l = n / 2 + 1, r = n - 1; l &lt;= r; ) { int mid = l + r &gt;&gt; 1; if (ask(n - mid + 1, n) == 0) { ans = mid, r = mid - 1; } else { l = mid + 1; } } } else { // k &lt;= n / 2 for (int l = 2, r = n / 2; l &lt;= r; ) { int mid = l + r &gt;&gt; 1; if (ask(1, mid) == 1) { ans = mid, r = mid - 1; } else { l = mid + 1; } } } } cout &lt;&lt; &quot;! &quot; &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; fflush(stdout);} F 如果整数序列 $b_1, b_2, \\ldots, b_n$ 为 $\\operatorname{mex}(b_1, b_2, \\ldots, b_n) - (b_1 | b_2 | \\ldots | b_n) = 1$ ，则该序列为有效序列。此处， $\\operatorname{mex(c)}$ 表示集合 $c$ 的 MEX $^{\\text{∗}}$ ，而 $|$ 是 按位或 运算符。 Shohag 有一个整数序列 $a_1, a_2, \\ldots, a_n$ 。他将对 $a$ 执行以下 $q$ 更新： $i$ $x$ — 将 $a_i$ 增加 $x$ 。 每次更新后，帮助他找到 $a$ 中最长的好子数组 $^{\\text{†}}$ 的长度。 $1 \\le n, q \\le 10^5$ $0 \\le a_i \\le n$ $1 \\le i, x \\le n$ 两个性质 $\\operatorname{mex}(S) \\le \\max(S) + 1$ $\\max(S) \\le \\operatorname{or}(S)$ $ \\operatorname{mex}(S) = \\max(S) + 1 $ $ \\max(S) = \\operatorname{or}(S) $ 可以枚举 $k$，限制转化为 $[0, 2^k)$ 每个数刚好出现一次。 题目的操作是只增不减，那么断点会变得越来越多。启发式分裂好像有点麻烦，直接离线反着操作，变成启发式合并，维护下信息。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103struct DSU { std::vector&lt;int&gt; f; DSU() {} DSU(int n) { init(n); } void init(int n) { f.resize(n), std::iota(f.begin(), f.end(), 0); } int find(int x) { return f[x] != x ? f[x] = find(f[x]) : x; }};// mex(S) = or(S) + 1// mex(S) &lt;= max(S) + 1// max(S) &lt;= or(S) = mex(S) - 1// max(S) + 1 &lt;= mex(S)// mex(S) = max(S) + 1// max(S) = or(S)void solve() { int n = read(); int m = read(); vector&lt;int&gt; a(n); vector&lt;std::array&lt;int, 2&gt;&gt; qry(m); for (auto &amp;x : a) x = read(); for (auto &amp;[i, x] : qry) i = read() - 1, x = read(); // for (auto [i, x] : qry) a[i] += x; DSU dsu(n); vector&lt;int&gt; L(n), R(n); vector&lt;int&gt; ans(m); for (int k = 0; k &lt;= 30; k++) { int tar = 1LL &lt;&lt; k; int lim = (1LL &lt;&lt; k) - 1; for (auto [i, x] : qry) a[i] += x; dsu.init(n); std::iota(L.begin(), L.end(), 0); std::iota(R.begin(), R.end(), 0); vector&lt;std::map&lt;int, int&gt;&gt; mp(n); std::multiset&lt;int&gt; s; s.ep(0); auto myMerge = [&amp;](int x, int y) -&gt; bool { x = dsu.find(x), y = dsu.find(y); if (x == y) return false; if (mp[x].size() &lt; mp[y].size()) swap(x, y); if (mp[x].size() == tar) s.erase(s.find(R[x] - L[x] + 1)); if (mp[y].size() == tar) s.erase(s.find(R[y] - L[y] + 1)); dsu.f[y] = x; for (auto [num, cnt] : mp[y]) { mp[x][num] += cnt; // cerr &lt;&lt; &quot;!&quot;; } mp[y].clear(); L[x] = min(L[x], L[y]); R[x] = max(R[x], R[y]); if (mp[x].size() == tar) s.ep(R[x] - L[x] + 1); return true; }; for (int i = 0; i &lt; n; i++) { if (a[i] &gt; lim) continue; if (!k) s.ep(1); mp[i][a[i]] = 1; if (i &gt; 0 and a[i - 1] &lt;= lim) myMerge(i - 1, i); } for (int i = m - 1; i &gt;= 0; i--) { ans[i] = max(ans[i], *--s.end()); auto [p, x] = qry[i]; auto &amp;val = a[p]; val -= x; if (i == 0 or val &gt; lim) continue; int fp = dsu.find(p); if (val + x &lt;= lim) { if (!--mp[fp][val + x]) { if (mp[fp].size() == tar) { s.erase(s.find(R[fp] - L[fp] + 1)); } mp[fp].erase(val + x); } } mp[fp][val]++; if (mp[fp].size() == tar and mp[fp][val] == 1) { s.ep(R[fp] - L[fp] + 1); } if (p - 1 &gt;= 0 and a[p - 1] &lt;= lim) myMerge(p - 1, p); if (p + 1 &lt; n and a[p + 1] &lt;= lim) myMerge(p + 1, p); } } for (auto x : ans) printf(&quot;%d\\n&quot;, x);}","link":"/codeforces-round-994-div-2/"},{"title":"Codeforces Round 989 (Div. 1 + Div. 2)","text":"构造 Round Rayan Programming Contest 2024 - Selection (Codeforces Round 989, Div. 1 + Div. 2) Problems AC A. King Keykhosrow’s Mystery ○ B. Rakhsh’s Revival ○ C. Trapped in the Witch’s Labyrinth ○ D. Darius’ Wisdom ⊕ E. Permutations Harmony ⊕ F1. Khayyam’s Royal Decree (Easy Version) F2. Khayyam’s Royal Decree (Hard Version) G1. Simurgh’s Watch (Easy Version) G2. Simurgh’s Watch (Hard Version) H. Rayan vs. Rayaneh A听说有人暴力枚举被叉了，乐 Code >folded12345void solve() { int a = read(); int b = read(); cout &lt;&lt; a * b / std::__gcd(a, b) &lt;&lt; '\\n';} BCode >folded12345678910111213141516171819202122232425262728293031void solve() { int n = read(); int m = read(); int k = read(); string s; cin &gt;&gt; s; int ans = 0; for (int i = 0; i &lt; n; ) { if (s[i] == '1') { i++; continue; } int j = i; int cnt = 0; while (s[j] == '0' and j &lt; n) { cnt++; if (cnt == m) { cnt = 0; j += k; ans++; break; } j++; } i = (j == i) ? i + 1 : j; // cout &lt;&lt; i &lt;&lt; '\\n'; } cout &lt;&lt; ans &lt;&lt; '\\n';} CCode >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374void solve() { int n = read(); int m = read(); vector&lt;string&gt; s(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; s[i]; } vector bad(n, vector&lt;int&gt;(m)); std::queue&lt;pii&gt; q; for (int i = 0; i &lt; n; i++) { if (s[i][0] == 'L') { bad[i][0] = 1; q.ep(i, 0); } if (s[i][m - 1] == 'R') { bad[i][m - 1] = 1; q.ep(i, m - 1); } } for (int i = 0; i &lt; m; i++) { if (s[0][i] == 'U') { bad[0][i] = 1; q.ep(0, i); } if (s[n - 1][i] == 'D') { bad[n - 1][i] = 1; q.ep(n - 1, i); } } while (!q.empty()) { auto [x, y] = q.front(); q.pop(); if (x &gt; 0 and !bad[x - 1][y] and s[x - 1][y] == 'D') { bad[x - 1][y] = 1; q.ep(x - 1, y); } if (x &lt; n - 1 and !bad[x + 1][y] and s[x + 1][y] == 'U') { bad[x + 1][y] = 1; q.ep(x + 1, y); } if (y &gt; 0 and !bad[x][y - 1] and s[x][y - 1] == 'R') { bad[x][y - 1] = 1; q.ep(x, y - 1); } if (y &lt; m - 1 and !bad[x][y + 1] and s[x][y + 1] == 'L') { bad[x][y + 1] = 1; q.ep(x, y + 1); } } int ans = 0; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { if (!bad[i][j] and s[i][j] != '?') ans++; else if (!bad[i][j]) { bool f = 1; if (i &gt; 0) f &amp;= bad[i - 1][j]; if (i &lt; n - 1) f &amp;= bad[i + 1][j]; if (j &gt; 0) f &amp;= bad[i][j - 1]; if (j &lt; m - 1) f &amp;= bad[i][j + 1]; if (!f) ans++; } } } cout &lt;&lt; ans &lt;&lt; '\\n';} D重写了一遍就过了，，，，做法是从右往左确定位置，次数容易证明是正确的。 Code >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475void solve() { int n = read(); vector&lt;int&gt; a(n + 1); vector&lt;int&gt; cnt(3); std::set&lt;int&gt; s[3]; for (int i = 1; i &lt;= n; i++) { a[i] = read(); s[a[i]].ep(i); } int p1 = s[0].size(), p2 = s[0].size() + s[1].size(); vector&lt;pii&gt; ans; for (int i = n; i &gt; p2; i--) { if (a[i] == 2) continue; if (a[i] == 0) { int j = *s[1].begin(); ans.eb(i, j); swap(a[i], a[j]); s[0].erase(i); s[1].erase(j); s[0].ep(j); s[1].ep(i); } if (a[i] == 1) { int j = *s[2].begin(); ans.eb(i, j); swap(a[i], a[j]); s[1].erase(i); s[2].erase(j); s[1].ep(j); s[2].ep(i); } } for (int i = p2; i &gt; p1; i--) { if (a[i] == 1) continue; if (a[i] == 0) { int j = *s[1].begin(); ans.eb(i, j); swap(a[i], a[j]); s[0].erase(i); s[1].erase(j); s[0].ep(j); s[1].ep(i); } } bool flag = 1; for (int i = 1; i &lt; n; i++) { if (a[i] &gt; a[i + 1]) { flag = 0; break; } } assert(flag); assert(ans.size() &lt;= n); cout &lt;&lt; ans.size() &lt;&lt; '\\n'; for (auto [i, j] : ans) { cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; '\\n'; }} E总和是 $(1 + n) * n / 2 * k$ 一列是 $(1 + n) * k / 2$ 因此 $(n + 1)$ 和 $k$ 同时是奇数时是无解的。 平均到每个 $k$ 就是 $(1 + n) / 2$。 因此有个想法是让两个排列配对，使得这两个排列每一列加起来是 $n + 1$。 发现这样能构造出最多的方案。前提是 $n$ 是偶数。 假如 $n$ 是奇数呢？考虑构造一个 3 行的，然后转化成偶数，用 2 行去凑。 发现其中一种构造是 1231 2 3 4 53 4 5 1 25 3 1 4 2 1231 2 3 4 5 6 74 5 6 7 1 2 3(n + 1) * 3 / 2 - a[i] - b[i] 思路和代码实现是学习的 这个视频。 Code >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485void solve() { int n = read(); int k = read(); // n 0 k 1 vector&lt;vector&lt;int&gt;&gt; ans; auto fill = [&amp;](std::set&lt;vector&lt;int&gt;&gt; forbid) { vector&lt;int&gt; p(n), q(n); std::iota(p.begin(), p.end(), 1); while (ans.size() &lt; k) { for (int i = 0; i &lt; n; i++) { q[i] = n + 1 - p[i]; } if (p &gt;= q) { break; } if (forbid.contains(p) or forbid.contains(q)) { // continue; } else { ans.eb(p); ans.eb(q); } std::next_permutation(p.begin(), p.end()); } }; auto go = [&amp;]() -&gt; bool { if ((n + 1) % 2 and k % 2) { return 0; } if (n == 1) { if (k == 1) { ans.eb(vector&lt;int&gt;(1, 1)); return 1; } return 0; } if (k % 2 == 0) { fill({}); return ans.size() == k; } // k is odd if (k == 1) { return 0; } vector&lt;int&gt; a(n); vector&lt;int&gt; b(n); vector&lt;int&gt; c(n); for (int i = 0; i &lt; n; i++) { a[i] = i + 1; b[i] = (i + n / 2) % n + 1; c[i] = (n + 1) * 3 / 2 - a[i] - b[i]; } std::set&lt;vector&lt;int&gt;&gt; forbid; forbid.ep(a); forbid.ep(b); forbid.ep(c); ans.eb(a); ans.eb(b); ans.eb(c); fill(forbid); return ans.size() == k; }; if (go()) { cout &lt;&lt; &quot;YES\\n&quot;; for (auto x : ans) { for (auto y : x) { cout &lt;&lt; y &lt;&lt; &quot; &quot;; } cout &lt;&lt; &quot;\\n&quot;; } } else { cout &lt;&lt; &quot;NO\\n&quot;; }}","link":"/codeforces-round-989-div-1-div-2/"},{"title":"Codeforces Round 969 (Div. 2)","text":"比赛链接 Problems AC A. Dora’s Set ○ B. Index and Maximum Value ○ C. Dora and C++ ○ D. Iris and Game on the Tree ○ E. Iris and the Tree ○ F. Eri and Expanded Sets C 给定一个序列，你可以任意次单点 $+A$ 或 $+B$ ，最小化极差。 单点 $+A$ 或 $+B$ 等价于单点 $\\pm \\operatorname{gcd}(A, B)$ 。 设 $g=\\operatorname{gcd}(a, b)$ ，在 $\\bmod g$ 意义下考虑 D 给定一棵树, 点权为 01 。定义一个叶子的权值为: 考虑从根到叶子的这条路径的点权组成的字符串，权值为其中 01 作为连续子串出现次数减去 10 作为连续子串出现次数。定义树的价值为：权值非零的叶子个数。现在一些点权变成?，博弈的两人分别填充，分别最大化和最小化树的价值。求最终树的价值。 观察发现，一条路径计入答案当且仅当叶子和根权值不同。所以只和根和叶子的权值有关。 若根的权值确定，则策略是唯一的。 如果根的权值不确定，则此时可以消耗非叶子结点的 ? 来转换先后手。策略也是显然的 E 给定一棵 dfs 序标号的树。每条边有不确定的非负整数边权，但你只知道边权和。定义 $f_i$ 为所有安排边权的情况下， $i$ 与 $(i \\bmod n)+1$ 的距离的最大值。每次告诉你—条边的边权，求此时所有 $f_i$之和。 树按 dfs 序标号，所以最终的 $n$ 条路径中，每条边恰好被经过两次。 一条路径的权值可能是：已经全部确定，那就确定了；没有全部确定，权值是边权和减去路径外知道的边的权值和。 用全局加的 tag 维护即可。","link":"/codeforces-round-969-div-2/"},{"title":"Codeforces Round 992 (Div. 2)","text":"比赛链接 Problems AC A. Game of Division ○ B. Paint a Strip ○ C. Ordered Permutations ○ D. Non Prime Tree ⊕ E. Control of Randomness ⊕ F. Number of Cubes ACode >folded123456789101112131415161718192021void solve() { int n = read(); int k = read(); vector&lt;int&gt; a(n + 1); vector&lt;vector&lt;int&gt;&gt; cnt(k); for (int i = 1; i &lt;= n; i++) { a[i] = read(); cnt[a[i] % k].eb(i); } for (int i = 0; i &lt; k; i++) { if (cnt[i].size() == 1) { puts(&quot;YES&quot;); cout &lt;&lt; cnt[i][0] &lt;&lt; '\\n'; return; } } puts(&quot;NO&quot;);} BCode >folded1234567891011void solve() { int n = read(); int ans = 1; int now = 1; while (now &lt; n) { ans++; now = (now + 1) * 2LL; } cout &lt;&lt; ans &lt;&lt; '\\n';} CCode >folded12345678910111213141516171819202122232425void solve() { int n = read(); int k = read() - 1; if (n &lt;= 60 and k &gt;= (1LL &lt;&lt; (n - 1))) { cout &lt;&lt; &quot;-1\\n&quot;; return; } vector&lt;int&gt; p(n); int l = 0, r = n - 1; for (int i = 1; i &lt; n; i++) { if (n - 1 - i &gt; 60 or k &lt; (1LL &lt;&lt; (n - 1 - i))) { p[l++] = i; } else { p[r--] = i; k -= 1LL &lt;&lt; (n - 1 - i); } } p[l] = n; // cout &lt;&lt; p &lt;&lt; '\\n'; for (int i = 0; i &lt; n; i++) { cout &lt;&lt; p[i] &lt;&lt; &quot; \\n&quot;[i == n - 1]; }} D 给定一棵有 $n$ 个顶点的树。 您需要构造一个长度为 $n$ 的数组 $a _ 1, a _ 2, \\ldots, a _ n$ ，该数组由从 $1$ 到 $2 \\cdot n$ 的唯一整数组成，并且对于树的每个边 $u _ i \\leftrightarrow v _ i$ ，值 $|a _ {u _ i} - a _ {v _ i}|$ 都不是素数。 查找满足这些条件的任何数组，或报告不存在这样的数组。 注意到，$1$ 和 $4$ 是质数。 一种构造方法是，先选择一条主链，全部填上差值为 $1$ 的，然后对于这条链上点 $u$ 分出来的其他链，分解成类似的子问题，只需要保证链的开头和 $a_u$ 相差至少是 $4$ 即可。 还有一种方法是黑白染色，按层数放偶数。 Code1234567891011121314151617181920212223242526272829303132333435363738394041void solve() { int n = read(); vector&lt;vector&lt;int&gt;&gt; g(n + 1); for (int i = 1; i &lt; n; i++) { int u = read(); int v = read(); g[u].eb(v), g[v].eb(u); } vector&lt;int&gt; a(n + 1); int t = 1; auto dfs = [&amp;](auto&amp;&amp; self, int u, int fa) -&gt; void { a[u] = t; bool first = 1; for (auto v : g[u]) { if (v == fa) continue; if (first) { first = 0; t++; self(self, v, u); t++; } else { t += 2; self(self, v, u); } } }; dfs(dfs, 1, 0); for (int i = 1; i &lt;= n; i++) { cout &lt;&lt; a[i] &lt;&lt; &quot; \\n&quot;[i == n]; }} E 给你一棵有 $n$ 个顶点的树。 让我们将机器人放置在某个顶点 $v \\ne 1$ 处，假设我们最初有 $p$ 枚硬币。考虑以下过程，其中在第 $i$ 步(从 $i = 1$ 开始)： 如果 $i$ 为奇数，机器人将移动到顶点 $1$ 方向上的相邻顶点； 否则， $i$ 为偶数。你可以支付一枚硬币(如果还剩下一些)，然后机器人移动到顶点 $1$ 方向上的相邻顶点，或者不支付，然后机器人移动到随机均匀选择的相邻顶点。 一旦机器人到达顶点 $1$ ，该过程就会停止。如果我们以最佳方式花费硬币，则让 $f(v, p)$ 成为上述过程中可能所需的最小步数。 回答 $q$ 个查询，其中的 $i$ 个查询必须找到 $f(v _ i, p _ i)$ 的值，模数为 $^{\\text{∗}}$ $998\\,244\\,353$ 。 谔谔赛时降智严重，没看出来是那个网络赛就被秒了的模型，我说我柿子怎么那么混乱。 网络赛那个是手动设立一个阈值，在阈值之前免费但概率收益，在阈值之后花费金币稳定收益。 类似的，在这个题中，开始花费金币了，就会一直用金币了。 设一个点的度数为 $d$，两种选择分别可以看作： 花费 $1$ 金币，步数 $+2$，向上走 $2$ 格。 花费 $0$ 金币，那么有 $\\frac{1}{d}$ 的概率向上走 $2$ 格，也就是期望 $d$ 次后向上走两个。即花费 $0$ 金币，步数 $+2d$，向上走 $2$ 格。 令 $v$ 是 $u$ 的下家，$fa$ 是 $u$ 的父亲： $$dp[v][p] = \\min\\lbrace dp[fa][p] + 2d, dp[fa][p - 1] + 2 \\rbrace$$ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546void solve() { int n = read(); int q = read(); vector&lt;vector&lt;int&gt;&gt; g(n + 1); for (int i = 1; i &lt; n; i++) { int u = read(); int v = read(); g[u].eb(v), g[v].eb(u); } vector dp(n + 1, vector(n + 1, inf)); auto dfs = [&amp;](auto&amp;&amp; self, int u, int fa) -&gt; void { int d = g[u].size(); for (auto v : g[u]) { if (v == fa) continue; if (u == 1) { fill(dp[v].begin(), dp[v].end(), 1); } else { for (int p = 0; p &lt;= n; p++) { dp[v][p] = dp[fa][p] + 2 * d; if (p) { dp[v][p] = min(dp[v][p], dp[fa][p - 1] + 2); } } } self(self, v, u); } // cerr &lt;&lt; dp[u] &lt;&lt; '\\n'; }; fill(dp[1].begin(), dp[1].end(), 0); dfs(dfs, 1, 0); while (q--) { int u = read(); int k = read(); cout &lt;&lt; dp[u][k] &lt;&lt; '\\n'; }}","link":"/codeforces-round-992-div-2/"},{"title":"Codeforces Round 968 (Div. 2)","text":"比赛链接 Problems AC A. Turtle and Good Strings ○ B. Turtle and Piggy Are Playing a Game 2 ○ C. Turtle and Good Pairs ○ D1. Turtle and a MEX Problem (Easy Version) ○ D2. Turtle and a MEX Problem (Hard Version) ⊕ E1. Turtle and Inversions (Easy Version) ⊕ E2. Turtle and Inversions (Hard Version) ⊕ F. Turtle and Three Sequences C 题意： $(i, j)$ 是好的当且仅当 $i&lt;j$ 且存在 $k \\in[i, j)$, 满足 $s_k \\neq s_{k+1}$ 且 $s_i \\neq s_k \\vee s_j \\neq s_{k+1}$ 。将 $s$ 重新排序, 最大化好的数对个数。 把字符串分为若干极长连续颜色段 $\\left[l_i, r_i\\right]$ （如 $a a a b b c c=[a a a][b b][c c]$）。 容易发现 $(i, j)$ 是好的的充要条件为 $i, j$ 所在颜色段不相邻。 令 $a_i=r_i-l_i+1$ ，那么好的数对个数等于 $\\frac{n(n-1)}{2}-\\sum a_i a_{i+1}$ 。 目标转化为最小化 $\\sum a_i a_{i+1}$ 。 当字符集大小不为 1 时，可以证明 $\\sum a_i a_{i+1} \\geq n-1$ 并且这个下界是可以达到的。 如果存在 $a_k=1$ :$$\\sum_{i=1}^{m-1} a_i a_{i+1} \\geq \\sum_{i=1}^{k-1} a_i+\\sum_{i=k}^{m-1} a_{i+1} = n-a_k = n - 1$$ 如果 $\\forall a_k \\geq 2, a_i a_{i+1} \\geq a_i+a_{i+1}$ :$$\\sum_{i=1}^{m-1} a_i a_{i+1} \\geq \\sum_{i=1}^{m-1} a_i+\\sum_{i=2}^m a_i&gt;n$$ 我们让前面所有 $a_i=1$ ，最后一个连续段放多出来的相同字母（如 $a a a b b c c=a b a b a c c$ ），显然有 $\\sum a_i a_{i+1}=n-1$ 。 时间复杂度 $O(26 n)$ 。 D1 题意：给定 $n$ 个序列 $\\left[a_i\\right], f(x)$ 定义为 $x$ 经过若干次操作（可能不操作）达到的最大值。 一次操作定义为: 选定一个序列 $\\left[a_i\\right], x \\leftarrow \\operatorname{mex}\\left(x \\cup\\left[a_i\\right]\\right)$ 。 在简单版中, 一个序列可以被重复选择。 给定 $m \\leq 10^9$, 求 $\\sum_{x=0}^m f(x)$ 。 定义 $u_i=\\operatorname{mex}\\left[a_i\\right], v_i=\\operatorname{mex}\\left(\\left[a_i\\right] \\cup u_i\\right) 。$ 我们发现不管是什么 $x$, 不管对 $\\left[a_i\\right]$ 操作几次, 能够达到且一定能达到的只有 $v_i$ 和 $u_i$ 。 因此 $f(x)=\\max \\left(x, \\max v_i\\right)$。 D2多了的限制是每个序列只能用一次。 这意味着假如你在 $u_i$，向 $v_i$ 走了以后就不能回头。 考虑一次操作，相当于是在图上走一条边 $(x, y)$，并断掉 $y$ 的一个出边 在图上倒着 dp 可以求出每个点能到达的最大点的坐标 $f$。 考虑如何统计答案： 对于一个 $x$，他至少是 $f_x$ 和 $\\max{u_i}$ 对于一个 $i$，如果出边数量 $ &gt; 1$，那么 $\\forall x$ 可以走到 $f_i$ 记 $k = \\max{v_i}$，小于等于 k 的枚举；对于大于 k 的 $x$，一定不会再操作了， i.e. $f(x) = x$。 E1nb 题 题意：给定 $m$ 个限制 $\\left[l_i, r_i\\right]$, 表示存在 $k \\in\\left[l_i, r_i\\right]$, 记 $a_i=\\max _{j=l}^k p_j, b_i=\\min _{j=k+1}^r p_j$, 使得 $\\max a_i&lt;\\min b_i$ 。 求长度为 $n \\leq 5 \\times 10^3$ 的符合限制的排列的最大逆序对数。简单版保证限制互不相交。 把所有数分为两类：小数 ($0$) 和大数 ($1$) ，满足 $\\max{0} &lt; \\min{1}$。 条件 $i$ 被满足当且仅当 $[l, r]$ 内所有 $0$ 都在 $1$ 前面, 且 $0$,$1$ 都至少出现一次。 如果最后的排列有 $x$ 个 $0$, $y$ 个 $1$ , 贪心的使所有 $0$ 从大到小排, $1$ 从大到小排。 设有 $z$ 个逆序对形如 $(1,0)$, 称之 $10$ 对, 那么最后的总逆序对数等于 $\\frac{x(x-1)}{2}+\\frac{y(y-1)}{2}+z$ 。 设 $f(i, j)$ 表示填完前 $i$ 个数，其中 $j$ 个是 $1$ 的最大 $10$ 对数。 如果 $i$ 是某个限制的右端点, 枚举 $[l, r]$ 之间有多少个 $1$ 。 否则讨论 $i$ 填 $0$ 还是 $1$ 。 最后答案是 $\\max f(n, i)+\\frac{i(i-1)}{2}+\\frac{(n-i)(n-i-1)}{2}$ 。 暴力转移看似是 $n^2$ 的, 但由于区间不相交, 第一种转移也是均摊 $O(n)$ 的。时间复杂度 $O\\left(n^2\\right)$ 。 E2和 E1 相比多了区间相交的情况。 考虑对于一对相交的区间 $\\left[l_1, r_1\\right],\\left[l_2, r_2\\right]$ （不妨设 $l_1 \\leq l_2$ ）， $\\left[l_1, l_2-1\\right]$ 一定全是 $0 ，\\left[r_1+1, r_2\\right]$ 一定全是 1。 然后可以删掉 $\\left[l_1, r_1\\right],\\left[l_2, r_2\\right]$，添加一个新区间 $\\left[l_2, r_1\\right]$ ，并记下有哪些数一定是 0，哪些数一定是 1 。 这样处理完后区间一定互不相交，就变成了E1。 时间复杂度：每个测试用例 $O\\left(n^2+m \\log m\\right)$ 。","link":"/codeforces-round-968-div-2/"},{"title":"Educational Codeforces Round 162 (Rated for Div. 2)","text":"比赛链接 A[Codeforces 1923A] Moving Chips.cpp >folded123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;// #define int long long#define pb push_backusing std::cin, std::cout, std::string;int read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 1e6 + 5;const int INF = 1 &lt;&lt; 30;// const long long INF = 1LL &lt;&lt; 60;int a[N];void solve(){ int n = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(); int p = 1, q = n, ans = 0; while (p &lt;= n and a[p] != 1) p++; while (q &gt;= 1 and a[q] != 1) q--; for (int i = p; i &lt;= q; i++) ans += a[i] == 0; cout &lt;&lt; ans &lt;&lt; '\\n';}signed main(){#ifndef ONLINE_JUDGE freopen(&quot;A.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;} B[Codeforces 1923B] Monsters Attack!.cpp >folded123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;#define int long long#define pb push_backusing std::cin, std::cout, std::string;int read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 1e6 + 5;const int INF = 1 &lt;&lt; 30;// const long long INF = 1LL &lt;&lt; 60;struct Node{ int a, x; bool friend operator &lt; (Node a, Node b) { return a.x == b.x ? a.a &lt; b.a : a.x &lt; b.x; }} a[N];void solve(){ int n = read(), k = read(); for (int i = 1; i &lt;= n; i++) a[i].a = read(); for (int i = 1; i &lt;= n; i++) a[i].x = abs(read()); std::sort(a + 1, a + 1 + n); int flag = 1; for (int i = 1, j = 1, tot = 0; i &lt;= n; i++) { tot += k; for (; j &lt;= n and a[j].x == i; j++) tot -= a[j].a; if (tot &lt; 0) { flag = 0; break; } } puts(flag ? &quot;YES&quot; : &quot;NO&quot;);}signed main(){#ifndef ONLINE_JUDGE freopen(&quot;B.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;} C赛时的时候乱想想到一个构造 全部填 mex，发现不够的话就随便挑几个补上就行了 一开始思维混乱不会做，然后直觉想出来可以这样，感性理解一下显然正确（ [Codeforces 1923C] Find B.cpp >folded123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;#define int long long#define pb push_backusing std::cin, std::cout, std::string;int read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 1e6 + 5;const int INF = 1 &lt;&lt; 30;// const long long INF = 1LL &lt;&lt; 60;int n, a[N], q, b[N], c[N];void solve(){ n = read(), q = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(); for (int i = 1; i &lt;= n; i++) b[i] = b[i - 1] + (a[i] == 1); for (int i = 1; i &lt;= n; i++) c[i] = c[i - 1] + a[i]; for (int l, r; q--; ) { l = read(), r = read(); if (l == r) { puts(&quot;NO&quot;); continue; } int sum = c[r] - c[l - 1]; int num = b[r] - b[l - 1]; int cost = num * 2 + (r - l + 1 - num); puts(cost &lt;= sum ? &quot;YES&quot; : &quot;NO&quot;); }}signed main(){#ifndef ONLINE_JUDGE freopen(&quot;C.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;} D赛时降智了只想着固定往一个方向吃。其实如果任意方向吃的话，一段如果不是一样的话，最大的那个必然可以左吃右吃吃出来。这样的话只要区间和够大就行了，二分这个位置即可 [Codeforces 1923D] Slimes.cpp >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;#define int long long#define pb push_back#define mid ((L + R) &gt;&gt; 1)using std::cin, std::cout, std::string, std::vector;int read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 1e6 + 5;const int INF = 1 &lt;&lt; 30;int n, a[N];int las[N], sum[N];vector&lt;int&gt; work(){ vector&lt;int&gt; ans(n, n); for (int i = 1; i &lt;= n; i++) { las[i] = a[i] == a[i - 1] ? las[i - 1] : i; sum[i] = sum[i - 1] + a[i]; if (a[i - 1] &gt; a[i]) { ans[i - 1] = 1; continue; } for (int L = 1, R = i - 1; L &lt;= R; ) if (sum[i - 1] - sum[mid - 1] &gt; a[i] and las[i - 1] &gt; mid) ans[i - 1] = i - mid, L = mid + 1; else R = mid - 1; } return ans;}void solve(){ n = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(); auto l = work(); std::reverse(a + 1, a + 1 + n); auto r = work(); for (int i = 0; i &lt; n; i++) { int now = std::min(l[i], r[n - 1 - i]); printf(&quot;%lld &quot;, now == n ? -1 : now); } puts(&quot;&quot;);}signed main(){#ifndef ONLINE_JUDGE freopen(&quot;D.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;} E[Codeforces 1923E] Count Paths.cpp >folded1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;#define int long long#define pb push_backusing std::cin, std::cout, std::string;int read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 1e6 + 5;const int INF = 1 &lt;&lt; 30;// const long long INF = 1LL &lt;&lt; 60;int n, a[N], cnt[N], ans;std::vector&lt;int&gt; g[N];void dfs(int u, int fa){ ans += cnt[a[u]]; int tmp = cnt[a[u]]; for (auto v : g[u]) if (v ^ fa) cnt[a[u]] = 1, dfs(v, u); cnt[a[u]] = tmp + 1;}void solve(){ n = read(), ans = 0; for (int i = 1; i &lt;= n; i++) a[i] = read(), g[i].clear(), cnt[i] = 0; for (int i = 1, u, v; i &lt; n; i++) u = read(), v = read(), g[u].pb(v), g[v].pb(u); dfs(1, 0); cout &lt;&lt; ans &lt;&lt; '\\n';}signed main(){#ifndef ONLINE_JUDGE freopen(&quot;D.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;}","link":"/educational-codeforces-round-162-rated-for-div-2/"},{"title":"Educational Codeforces Round 169 (Rated for Div. 2)","text":"比赛链接 Problems AC A. Closest Point ○ B. Game with Doors ○ C. Splitting Items ○ D. Colored Portals ○ E. Not a Nim Problem ⊕ F. Make a Palindrome G. Substring Compression A只能是 2 个点的情况，且得有空隙插 B分类讨论区间包含情况即可 C策略是唯一的 1234567891011121314151617181920void solve() { int n = read(), k = read(); vector&lt;int&gt; a(n); for (int i = 0; i &lt; n; i++) a[i] = read(); std::sort(a.rbegin(), a.rend()); int ans = 0; for (int i = 1; i &lt; n; i += 2) { int t = min(k, a[i - 1] - a[i]); k -= t, a[i] += t; } for (int i = 0; i &lt; n; i++) { if (i % 2 == 0) ans += a[i]; else ans -= a[i]; } cout &lt;&lt; ans &lt;&lt; '\\n';} D要么是可以直接跳，要么是向左或者向右各找一个最近的跳看看哪个小。如果不是最近的话肯定劣于最近的。预处理一下即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const std::string color = &quot;BGRY&quot;;int id(int x, int y) { if (x &gt; y) swap(x, y); return y * (y - 1) / 2 + x;}void solve() { int n = read(), q = read(); vector&lt;std::array&lt;int, 2&gt;&gt; c(n + 2); for (int i = 1; i &lt;= n; i++) { string s; cin &gt;&gt; s; for (int j = 0; j &lt; 2; j++) { c[i][j] = color.find(s[j]); } } vector&lt;std::array&lt;int, 6&gt;&gt; pre(n + 1), nxt(n + 1); for (int i = 1; i &lt;= n; i++) { if (i == 1) pre[i].fill(0); else pre[i] = pre[i - 1]; pre[i][id(c[i][0], c[i][1])] = i; } for (int i = n; i &gt;= 1; i--) { if (i == n) nxt[i].fill(n + 1); else nxt[i] = nxt[i + 1]; nxt[i][id(c[i][0], c[i][1])] = i; } for (int i = 0; i &lt; q; i++) { int x = read(), y = read(); int ans = 1e9; if (x &gt; y) swap(x, y); for (auto a : c[x]) { for (auto b : c[y]) { if (a == b) ans = y - x; else { int w = id(a, b); for (auto z : {nxt[x][w], pre[y][w]}) { if (1 &lt;= z and z &lt;= n) { ans = min(ans, abs(x - z) + abs(y - z)); } } } } } cout &lt;&lt; (ans == 1e9 ? -1 : ans) &lt;&lt; &quot;\\n&quot;; }} E 博弈论 给定 $n$ 堆石子，第 $i$ 堆有 $a_i$ 个。对于每次操作，玩家可以选择任意一堆石子，设其还剩 $x$ 个，若玩家可以从中取走 $y$ 个，当且仅当 $\\gcd(x,y) = 1$。不能取石子的人输，问先手是否必胜。 发现每堆游戏是相对独立的，可以计算每堆的 SG 函数 值，然后将这些值进行异或运算，以判断当前状态是否为必胜（即结果是否为 $0$） 首先可以观察到 $SG(0) = 0, SG(1) = 1, SG(2) = 0$ 进一步地，打表发现：质数的 $SG$ 值是连续的（$2$ 除外）；且合数的 $SG$ 值等于其最小质因子的 $SG$ 值。 用数学归纳法不难证明。 实现时可以考虑用线性筛，因为线性筛时每个合数会被其最小的质因数筛到。 123456789101112131415161718192021222324252627282930std::vector&lt;int&gt; minp, primes, sg;void sieve(int n) { minp.assign(n + 1, 0), primes.clear(); sg.assign(n + 1, 0); sg[1] = 1; for (int i = 2; i &lt;= n; i++) { if (minp[i] == 0) { minp[i] = i, primes.push_back(i); sg[i] = primes.size(); } sg[2] = 0; for (auto p : primes) { if (i * p &gt; n) break; minp[i * p] = p; sg[i * p] = sg[p]; if (p == minp[i]) break; } }}void solve() { int n = read(); int ans = 0; for (int i = 0; i &lt; n; i++) { ans ^= sg[read()]; } puts(ans ? &quot;Alice&quot; : &quot;Bob&quot;);}","link":"/educational-codeforces-round-169-rated-for-div-2/"},{"title":"EPIC Institute of Technology Round Summer 2024 (Div. 1 + Div. 2)","text":"比赛链接 Problems AC A. Upload More RAM ○ B. K-Sort ○ C. Basil’s Garden ○ D. World is Mine ○ E. Wonderful Tree! ○ F1. Interesting Problem (Easy Version) ⊕ F2. Interesting Problem (Hard Version) ⊕ G1. Spinning Round (Easy Version) G2. Spinning Round (Hard Version) H. Fumo Temple ACode B 给定一个长度为 $ n $ 的整数数组 $ a $。 你可以进行以下操作任意次（可以为零次）： 首先，选择一个整数 $ k $，使得 $ 1 \\le k \\le n $，并支付 $ k + 1 $ 个硬币。 然后，选择恰好 $ k $ 个索引，使得 $ 1 \\le i_1 &lt; i_2 &lt; \\ldots &lt; i_k \\le n $。 然后，对于从 $ 1 $ 到 $ k $ 的每个 $ x $，将 $ a_{i_x} $ 增加 1。 找出使数组 $ a $ 非递减（即 $ a_1 \\le a_2 \\le \\ldots \\le a_n $）所需的最少硬币数。 呃呃呃，这个题实现的时候脑瘫了，改来改去花了半个小时才过。导致后面心态一度很崩 Code C 有 $ n $ 朵花排成一行，第 $ i $ 朵花的初始高度为 $ h_i $ 米。 每秒钟，风会从左边吹过来，导致一些花的高度降低。 具体来说，每秒钟，对于从 $ 1 $ 到 $ n $ 的每个 $ i $，按以下顺序发生： 如果 $ i = n $ 或 $ h_i &gt; h_{i+1} $，则 $ h_i $ 的值变为 $ \\max(0, h_i - 1) $。 第一次所有花的高度 $ h_i = 0 $（对于所有 $ 1 \\le i \\le n $）需要经过多少秒？ 感觉是究极无敌脑电波题 a[n] 变成 0 的时间是 a[n]。a[n - 1] 变成 0 的时间取决于 a[n]。 如果 a[n - 1] &gt;= a[n] 的话，那么至少需要 a[n - 1] 的时间 如果 a[n - 1] &lt; a[n] 的话，先要等 a[n] 变到 a[n - 1] 的大小，然后转化为上面那种情况。一共是 a[n] + 1 的时间。 Code D Alice 和 Bob 正在玩游戏。最初，有 $n$ 个蛋糕，其中第 $i$ 个蛋糕的美味值为 $a_i$ 。 Alice 和 Bob 轮流吃蛋糕，Alice 先吃： 轮到 Alice 选择并吃掉任何剩余的蛋糕，其美味度严格大于她之前吃过的任何蛋糕的最大美味度。请注意，在第一轮，她可以选择任何蛋糕。 轮到 Bob 选择并吃掉任何剩余的蛋糕。 当当前玩家吃不到合适的蛋糕时，游戏结束。让 $x$ 为 Alice 吃的蛋糕数量。然后，Alice 想要最大化 $x$ ，而 Bob 想要最小化 $x$ 。 如果两个玩家都发挥最佳水平，找出 Alice 会吃多少蛋糕。 想一下你会发现，Alice 是没有决策可言的，每次吃最小的一定是最优的。Bob 要拿一个数的话就要在 Alice 拿到这个数之前全部拿干净。 f[i][j] 表示 Bob 在前 i 种数里选完了 j 种的时候需要进行的操作次数 如果不取第 i 种的话， f[i][j] = f[i - 1][j] 如果要取第 i 种，需要满足 dp[i - 1][j - 1] + 第 i 种数字的个数 &lt;= i - j，不等式右边的是 Alice 的操作次数，不等式左边是 Bob 的操作次数，Alice 的操作次数应当 &gt;= Bob 的操作次数。dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + 第 i 种数字的个数 Code E 给定一棵树，有 $n$ 个顶点，根节点为 $1$ 。第 $i$ 个顶点上写有一个整数 $a_i$ 。 让 $L$ 成为 $v$ 的所有直接子节点的集合。如果对于所有 $L$ 不为空的顶点 $v$ ，满足： $$ a_v \\le \\sum_{u \\in L}{a_u}$$ 则称一棵树为 wonderful。 在一个操作中，您可以选择任意顶点 $v$ 并将 $a_v$ 增加 $1$ 。 找到使给定的树变得 wonderful 所需的最少操作数！($2 \\le n \\le 5000$) 算是一个实现题吧，思维难度其实不大。一开始以为是一个直接的贪心，写了一发发现错了。想了一下自己错的原因是向上合并子树信息的时候没有考虑到特定代价下的操作次数是有限的，换句话说是代价是会变的。 具体实现方面，维护 f[i][j] 表示 当前在 i 点，深度为 j 的剩余可操作次数。因为代价是和深度挂钩的，是 j - dep[i]，即两点的深度差。 Code F1 $1 \\le n \\le 100$ 您将获得一个长度为 $n$ 的整数数组 $a$ 。 在一个操作中，您将执行以下两步过程： 选择一个索引 $i$ ，使得 $1 \\le i &lt; |a|$ 和 $a_i = i$ 。 从数组中删除 $a_i$ 和 $a_{i+1}$ ，并连接剩余部分。 找出您可以执行上述操作的最大次数。 如果希望 $a_i$ 最终被删掉，需要满足以下条件： $a_i \\le i$，显然 $a_i$ 应该在的位置必须不在当前位置的后方。 $a_i$ 和 $i$ 奇偶性相同，因为每次操作都是删 2 个，不改变奇偶性。 需要在 $[1, i - 1]$ 中恰好删去 $\\frac{i - a_i}{2}$ 个数，使得 $a_i = i$。 所以我们可以设计出一个区间 dp：设 $g_{l, r}$ 表示要将 $[l, r]$ 删干净，最少要在 $[1, l - 1]$ 操作的次数。","link":"/epic-institute-of-technology-round-summer-2024-div-1-div-2/"},{"title":"Educational Codeforces Round 171 (Rated for Div. 2)","text":"比赛链接 Problems AC A. Perpendicular Segments ○ B. Black Cells ○ C. Action Figures ○ D. Sums of Segments ○ E. Best Subsequence ○ F. Bermart Ice Cream C最有意思的一个题。由于所有的东西都要买，转化为最多能用多少优惠。 12345678910111213141516171819202122232425262728293031void solve() { int n = read(); string s; cin &gt;&gt; s; s = '#' + s; int ans = 0; std::queue&lt;int&gt; q; for (int i = n; i &gt;= 1; i--) { if (s[i] == '0') { ans += i; if (!q.empty()) { q.pop(); } } else { q.ep(i); } } int m = q.size() / 2; while (m--) q.pop(); while (!q.empty()) { ans += q.front(); q.pop(); } cout &lt;&lt; ans &lt;&lt; '\\n';} D分块前缀和套前缀和，算算算算就过了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960void solve() { int n = read(); vector&lt;int&gt; a(n + 1); for (int i = 1; i &lt;= n; i++) { a[i] = read(); // siz[i] = n - i + 1; } vector&lt;int&gt; suma(n + 1); for (int i = 1; i &lt;= n; i++) { suma[i] = suma[i - 1] + a[i]; } vector&lt;int&gt; sum2a(n + 1); for (int i = 1; i &lt;= n; i++) { sum2a[i] = sum2a[i - 1] + suma[i]; } vector&lt;int&gt; block_sum(n + 1); block_sum[1] = sum2a[n]; for (int i = 2; i &lt;= n; i++) { block_sum[i] = block_sum[i - 1] - a[i - 1]; block_sum[i] -= (n - i + 1) * (a[i - 1]); } // for (int i = 1; i &lt;= n; i++) { // cout &lt;&lt; block_sum[i] &lt;&lt; '\\n'; // } for (int i = 1; i &lt;= n; i++) { block_sum[i] += block_sum[i - 1]; } auto get = [&amp;](int x) { int res = 0; int p = 0; for (int l = 1, r = n; l &lt;= r; ) { int mid = l + r &gt;&gt; 1; if ((n + n - mid + 1) * mid / 2 &lt; x) { p = mid; l = mid + 1; } else { r = mid - 1; } } res += block_sum[p]; x -= (n + n - p + 1) * p / 2; res += sum2a[x + p] - sum2a[p] - suma[p] * x; return res; }; for (int q = read(); q--; ) { int l = read(), r = read(); cout &lt;&lt; get(r) - get(l - 1) &lt;&lt; '\\n'; // cout &lt;&lt; get(r) &lt;&lt; '\\n'; }} E最大权闭合子图。 从 s 向 1…n 连 1 1…n 向 1…60 中对应的 bit 位连 inf。 1…60 向 t 连 1。 经典结论之：最大权闭合子图的权值等于所有正权点（与 s 直接相连的点集）权值之和减去最小割 12345678910111213141516171819202122232425void solve() { int n = read(); MaxFlow&lt;int&gt; g(n + 1 + 60 + 2); int node = n + 60; int s = ++node; int t = ++node; for (int i = 1; i &lt;= 60; i++) { g.addEdge(n + i, t, 1); } for (int i = 1; i &lt;= n; i++) { int x = read(); g.addEdge(s, i, 1); for (int j = 0; j &lt; 60; j++) { if (x &gt;&gt; j &amp; 1) { g.addEdge(i, n + j + 1, inf); } } } cout &lt;&lt; n - g.flow(s, t) &lt;&lt; '\\n';}","link":"/educational-codeforces-round-171-rated-for-div-2/"},{"title":"Educational Codeforces Round 161 (Rated for Div. 2)","text":"比赛链接 A定义 s 和 t 匹配，当且仅当对于所有 $s_i$ ： 若为小写字母，则 $t_i = s_i$ 若为大写字母，则 $t_i \\neq lower(s_i)$ 给你字符串 a, b, c, 询问是否存在字符串与 a, b 都匹配且与 c 不匹配 两个字符串如果想匹配上的话，得要每个位置都匹配上。 显然如果只匹配 a, b 的话是一定可以匹配上的，2 个字符串的限制太少了 假如匹配失败的话，只要有一个位置不匹配就行了。 所以只要判断是否存在一个位置匹配不上 c 且能匹配上 a, b 就行了 [Codeforces 1922A] Tricky template.cpp >folded12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;int read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 1e6 + 5;int n, a[N];void solve(){ std::string a, b, c; int n = read(); std::cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; bool flag = 0; for (int i = 0; i &lt; n; i++) if (a[i] != b[i]) flag |= (a[i] != c[i] &amp;&amp; b[i] != c[i]); else flag |= (a[i] != c[i]); puts(flag ? &quot;YES&quot; : &quot;NO&quot;);}int main(){#ifndef ONLINE_JUDGE freopen(&quot;A.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;} B一个二次幂的性质加简单组合数学 [Codeforces 1922B] Forming Triangles.cpp >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#define int long longint read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 3e5 + 5;int n, a[N];int b[N];void solve(){ n = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(); for (int i = 0; i &lt;= n; i++) b[i] = 0; for (int i = 1; i &lt;= n; i++) b[a[i]]++; long long ans = 0, cnt = 0; for (int i = 0; i &lt;= n; i++) { if (b[i] == 2) ans += cnt; if (b[i] &gt; 2) ans += b[i] * (b[i] - 1) / 2 * cnt + b[i] * (b[i] - 1) * (b[i] - 2) / 6; cnt += b[i]; } printf(&quot;%lld\\n&quot;, ans);}signed main(){#ifndef ONLINE_JUDGE freopen(&quot;A.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;} C数轴上 n 个点，一个点跳到另外一个点的代价是 数轴上的距离 但是可以花费 1 的代价跳到最近的点 多次询问从某个点到另一个点的最小代价 正着反着预处理下即可 [Codeforces 1922C] Closest Cities.cpp >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;int read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 1e5 + 5;int n, m, a[N], b[N];int c[N], d[N];void solve(){ n = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(); b[1] = 2, b[n] = 1; for (int i = 2; i &lt; n; i++) b[i] = a[i] - a[i - 1] &gt; a[i + 1] - a[i] ? 2 : 1; c[1] = a[1]; for (int i = 1; i &lt; n; i++) c[i + 1] = b[i] == 1 ? c[i] + a[i + 1] - a[i] : c[i] + 1; d[n] = a[n]; for (int i = n; i &gt;= 2; i--) d[i - 1] = b[i] == 1 ? d[i] - 1 : d[i] - a[i] + a[i - 1]; for (int q = read(); q--; ) { int x = read(), y = read(); printf(&quot;%d\\n&quot;, x &gt; y ? d[x] - d[y] : c[y] - c[x]); }}int main(){#ifndef ONLINE_JUDGE freopen(&quot;A.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;} D非常有启发性的一道题 如果在这一轮中这个怪没死，而且他的两个邻居也没死，那下一轮就不用检查这个怪了。 这个性质有什么用呢？ 维护一个集合：下一轮可能会死亡的怪物。 如何维护？ 每一轮处理时如果一个怪物死了就把他的邻居加入集合 集合的复杂度？ 第一轮集合大小为 n。一轮中，杀死一个怪物最多让集合大小 +2，最多就是 n + 2n = 3n。和 n 同阶。 再想个办法维护每个怪物的邻居即可，这里有多种实现方式。e.g. dsu, set. [Codeforces 1922D] Berserk Monsters.cpp >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;#define ins insertint read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 3e5 + 5;int n, a[N], d[N];void solve(){ n = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(); for (int i = 1; i &lt;= n; i++) d[i] = read(); d[0] = d[n + 1] = INT32_MAX, a[0] = a[n + 1] = 0; std::set&lt;int&gt; lft, cur; for (int i = 0; i &lt;= n + 1; i++) lft.ins(i), cur.ins(i); for (; n--; ) { std::set&lt;int&gt; del, ncur; for (int i : cur) { auto it = lft.find(i); if (it == lft.end()) continue; int L = *std::prev(it); int R = *std::next(it); if (a[L] + a[R] &gt; d[i]) del.ins(i), ncur.ins(L), ncur.ins(R); } std::cout &lt;&lt; del.size() &lt;&lt; ' '; for (auto it : del) lft.erase(it); cur = ncur; } puts(&quot;&quot;);}int main(){#ifndef ONLINE_JUDGE freopen(&quot;D.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;} E逆天 cf 放了个 apio2022 原题削弱版 给定 m，要求你构造一个长度在 200 以内的序列，满足刚好有 m 个上升子序列 m &lt;= 10 ^ 18 首先，1, 2, 3, 4, …. n - 1, n 这样的序列可以产生 2 ^ n 的贡献 赛时在想用若干个这样的东西凑，然后爆长度了。 其实不需要。 例如，[1…..10] 后面添加一个 3，就会多产生 2 ^ (3 - 1) 的贡献，二进制拆分即可 或者，在 [min…….max] 后面加上一个 min 可以 +1，加上一个 max 可以 *2，递归即可 cf 上 tutorial 的 implement 很简洁 [Codeforces 1922E] Increasing Subsequences.cpp >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#define int long longint read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}std::vector&lt;int&gt; go(int x){ std::vector&lt;int&gt; res; if (x == 2) res.push_back(0); else if (x &amp; 1) res = go(x - 1), res.push_back(*std::min_element(res.begin(), res.end()) - 1); else res = go(x / 2), res.push_back(*std::max_element(res.begin(), res.end()) + 1); return res;}void solve(){ auto ans = go(read()); std::cout &lt;&lt; ans.size() &lt;&lt; '\\n'; for (auto x : ans) std::cout &lt;&lt; x &lt;&lt; ' '; puts(&quot;&quot;);}signed main(){#ifndef ONLINE_JUDGE freopen(&quot;A.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;}","link":"/educational-codeforces-round-161-rated-for-div-2/"},{"title":"Good Bye 2024: 2025 is NEAR","text":"比赛链接 Problems AC Note A. Tender Carpenter ○ B. Outstanding Impressionist ○ C. Bewitching Stargazer ○ D. Refined Product Optimality ⊕ 交换 E. Resourceful Caterpillar Sequence ⊕ game、树上计数 F. Earnest Matrix Complement G. Naive String Splits H. Delicate Anti-monotonous Operations I1. Affectionate Arrays (Easy Version) I2. Affectionate Arrays (Hard Version) ACode >folded12345678910111213141516void solve() { int n = read(); vector&lt;int&gt; a(n + 1); for (int i = 1; i &lt;= n; i++) a[i] = read(); for (int i = 1; i + 1 &lt;= n; i++) { int x = a[i]; int y = a[i + 1]; if (x &lt; y) swap(x, y); if (x + x &gt; y and y + y &gt; x) { puts(&quot;YES&quot;); return; } } puts(&quot;NO&quot;);} BCode >folded1234567891011121314151617181920212223242526272829303132void solve() { int n = read(); vector&lt;pii&gt; a(n + 1); for (int i = 1; i &lt;= n; i++) { a[i].fi = read(); a[i].se = read(); } vector&lt;int&gt; buk(2 * n + 1); vector&lt;int&gt; cnt(2 * n + 1); for (int i = 1; i &lt;= n; i++) { auto [l, r] = a[i]; if (l != r) { continue; } buk[l] = 1; cnt[l] ++; } for (int i = 1; i &lt;= 2 * n; i++) { buk[i] += buk[i - 1]; } for (int i = 1; i &lt;= n; i++) { auto [l, r] = a[i]; if ((l == r and cnt[l] == 1) or buk[r] - buk[l - 1] != r - l + 1) putchar('1'); else putchar('0'); } puts(&quot;&quot;);} C 天空中有 $n$ 颗星星，排成一排。Iris 有一架望远镜，她用它来看星星。 最初，Iris 观察线段 $[1, n]$ 中的星星，她的幸运值为 $0$ 。Iris 想要寻找她观察到的每个线段 $[l, r]$ 中间位置的星星。因此使用以下递归程序： 首先，她将计算 $m = \\left\\lfloor \\frac{l+r}{2} \\right\\rfloor$ 。 如果线段长度（即 $r - l + 1$ ）为偶数，Iris 会将其分成两个等长的线段 $[l, m]$ 和 $[m+1, r]$ ，以便进一步观察。 否则，Iris 会将望远镜对准恒星 $m$ ，她的幸运值将增加 $m$ ；随后，如果为 $l \\neq r$ ，Iris 将继续观察两个线段 $[l, m-1]$ 和 $[m+1, r]$ 。 Iris 有点懒。她用整数 $k$ 来定义她的懒惰程度：随着观察的进行，她不会继续观察任何长度严格小于 $k$ 的线段 $[l, r]$ 。在这种情况下，请预测她的最终幸运值。 $1 \\leq k \\leq n \\leq 2\\cdot 10^9$ 注意到左子树和右子树是对称的，且差的只和当前这一层的中点以及数量有关。维护下即可 Code12345678910111213141516171819202122void solve() { int n = read(); int k = read(); auto dfs = [&amp;](this auto&amp;&amp; self, int l, int r) -&gt; pii { int len = r - l + 1; if (len &lt; k) return {0, 0}; if (len == 1) return {l, 1}; int m = l + r &gt;&gt; 1; if (len % 2 == 0) { auto [sum, cnt] = self(l, m); return {2 * sum + cnt * m, cnt * 2}; } else { auto [sum, cnt] = self(l, m - 1); return {m + 2 * sum + cnt * m, cnt * 2 + 1}; } }; auto [ans, _] = dfs(1, n); cout &lt;&lt; ans &lt;&lt; '\\n';} D Chris 得到两个数组 $a$ 和 $b$ ，均由 $n$ 个整数组成。 Iris 感兴趣的是，在对 $b$ 进行任意重新排列后， $P = \\prod\\limits_{i=1}^n \\min(a_i, b_i)$ 的最大可能值。请注意，她只想知道 $P$ 的最大值，并且不会对 $b$ 进行任何实际的重新排列。 将有 $q$ 次修改。每次修改都可以用两个整数 $o$ 和 $x$ 表示（ $o$ 是 $1$ 或 $2$ ， $1 \\leq x \\leq n$ ）。如果是 $o = 1$ ，那么 Iris 会将 $a_x$ 增加 $1$ ；否则，她会将 $b_x$ 增加 $1$ 。 Iris 向 Chris 询问 $P$ 的最大值，共询问了 $q + 1$ 次：一次是在修改之前，另一次是在每次修改之后。 由于 $P$ 可能很大，Chris 只需要计算它对 $998,244,353$ 的模数。 显然的观察是两个数组分别排序最优。而且观察到每次变化不超过 $1$，随便维护下位置就做完了。 注意不要一个一个交换，复杂度是错的。 Code123456789101112131415161718192021222324252627282930313233343536373839404142void solve() { int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; a(n), b(n); for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; for (int i = 0; i &lt; n; i++) cin &gt;&gt; b[i]; auto c = a; auto d = b; std::ranges::sort(c); std::ranges::sort(d); Z ans = 1; for (int i = 0; i &lt; n; i++) { ans *= min(c[i], d[i]); } cout &lt;&lt; ans &lt;&lt; ' '; while (m--) { // int opt = read(), pos = read() - 1; int opt, x; cin &gt;&gt; opt &gt;&gt; x; x--; if (opt == 1) { a[x]++; int i = std::lower_bound(c.begin(), c.end(), a[x]) - c.begin() - 1; ans /= std::min(c[i], d[i]); c[i]++; ans *= std::min(c[i], d[i]); } if (opt == 2) { b[x]++; int i = std::lower_bound(d.begin(), d.end(), b[x]) - d.begin() - 1; ans /= std::min(c[i], d[i]); d[i]++; ans *= std::min(c[i], d[i]); } cout &lt;&lt; ans &lt;&lt; &quot; \\n&quot;[m == 0]; }} E 给定一棵树和一条毛毛虫 $(p, q)$ （一条树上路径），每次 N 和 A 交替移动，N 把毛毛虫的 p 端移动一步（身体也跟着动），类似地 A 把毛毛虫的 q 端移动一步，p 到叶子则 N 赢，q 到叶子则 A 赢。对满足 A 有必胜策略的初始毛毛虫计数。 Code >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051void solve() { int n = read(); vector&lt;vector&lt;int&gt;&gt; g(n); for (int i = 1; i &lt; n; i++) { int u = read() - 1, v = read() - 1; g[u].eb(v), g[v].eb(u); } if (n == 2) { puts(&quot;0&quot;); return; } int cnt = 0; int rt = 0; vector&lt;int&gt; leaf(n), sp(n); for (int i = 0; i &lt; n; i++) { if (g[i].size() != 1) { rt = i; continue; } cnt++; leaf[i] = sp[i] = 1; for (auto j : g[i]) sp[j] = 1; } int ans = cnt * (n - cnt); vector&lt;int&gt; fa(n), sum(n), siz(n); auto dfs = [&amp;](this auto&amp;&amp; self, int u, int f) -&gt; void { fa[u] = f; sum[u] = sp[u], siz[u] = 1; for (auto v : g[u]) { if (v == f) continue; self(v, u); sum[u] += sum[v], siz[u] += siz[v]; } }; dfs(rt, -1); for (int i = 0; i &lt; n; i++) { if (leaf[i]) continue; if (i != rt and sp[fa[i]] and !leaf[fa[i]]) { ans += (n - siz[i]) - (sum[rt] - sum[i]); } for (auto j : g[i]) { if (j == fa[i]) continue; if (sp[j] and !leaf[j]) ans += siz[j] - sum[j]; } } cout &lt;&lt; ans &lt;&lt; '\\n';}","link":"/good-bye-2024-2025-is-near/"},{"title":"Pinely Round 4 (Div. 1 + Div. 2)","text":"《i didnt know i needed a plush tree until now》 比赛链接 Problems AC A. Maximize the Last Element ○ B. AND Reconstruction ○ C. Absolute Zero ○ D. Prime XOR Coloring ○ E. Coloring Game ⊕ F. Triangle Formation G. Grid Reset H. Prime Split Game I. Grid Game Code Repo A 给定一个包含 $n$ 个整数的数组 $a$ ，其中 $n$ 为奇数。 在一次操作中，您将从数组 $a$ 中删除两个相邻元素，然后连接数组的剩余部分。例如，给定数组 $[4,7,4,2,9]$ ，我们可以分别通过操作 $[\\underline{4,7}, 4,2,9] \\to [4,2,9]$ 和 $[4,7,\\underline{4,2},9] \\to [4,7,9]$ 获得数组 $[4,2,9]$ 和 $[4,7,9]$ 。但是，我们无法获得数组 $[7,2,9]$ ，因为它需要删除不相邻的元素 $[\\underline{4},7,\\underline{4},2,9]$ 。 您将重复执行此操作，直到 $a$ 中只剩下一个元素。 找出 $a$ 中剩余元素的最大可能值。 B 给定一个包含 $n - 1$ 个整数的数组 $b$ 。 如果包含 $n$ 个整数的数组 $a$ 为 $b_i = a_i$ &amp; $a_{i + 1}$ （其中 $1 \\le i \\le n-1$ 为 &amp; 表示 按位与运算符，则该数组为好数组。 构造一个好数组，否则报告不存在好数组。 C 您将获得一个包含 $n$ 个整数的数组 $a$ 。 在一次操作中，您将执行以下两步移动： 选择一个整数 $x$ ( $0 \\le x \\le 10^{9}$ )。 将每个 $a_i$ 替换为 $|a_i - x|$ ，其中 $|v|$ 表示 $v$ 的 绝对值。 例如，通过选择 $x = 8$ ，数组 $[5, 7, 10]$ 将更改为 $[|5-8|, |7-8|, |10-8|] = [3,1,2]$ 。 构造一个操作序列，使 $a$ 的所有元素在最多 $40$ 次操作中等于 $0$ ，或者确定这是不可能的。您无需最小化操作次数。 D 给定一个无向图，其中有 $n$ 个顶点，编号从 $1$ 到 $n$ 。当且仅当 $u \\oplus v$ 为 素数 时，顶点 $u$ 和 $v$ 之间有一条边，其中 $\\oplus$ 表示 按位 XOR 运算符。 使用最少的颜色数为图中的所有顶点着色，使得没有两个通过边直接连接的顶点具有相同的颜色。 $1 \\le n \\le 2 \\cdot 10^5$ 这道题本质上和昆明邀请赛的一个题相似，都用了异或 和 4 相关的性质。那道题赛时队友打表找规律过了。 你发现首先有这样一个事情，考虑二进制下的最后一位，偶数 xor 偶数 和 奇数 xor 奇数 结果都是偶数。那么偶数集内部不会有边，奇数集也是。 只有奇数 xor 偶数才是奇数，才有可能是质数，那你奇数全用一个颜色，偶数用另外一个颜色即可。 但是注意有个特殊的质数是 2，所以考虑 xor 出来是 2 的情况，也就是最后两位 xor 出来是 10。这样的数是 4 个一循环的，所以你用 4 个颜色即可。 E 这是一个交互式问题。 考虑一个由 $n$ 个顶点和 $m$ 个边组成的无向连通图。每个顶点可以用以下三种颜色之一着色： $1$ 、 $2$ 或 $3$ 。最初，所有顶点都是未着色的。 Alice 和 Bob 正在玩一个由 $n$ 轮组成的游戏。在每一轮中，都会发生以下两步过程： Alice 选择两种不同的颜色。 Bob 选择一个未着色的顶点，并用 Alice 选择的两种颜色之一为其着色。 如果存在一条连接相同颜色的两个顶点的边，则 Alice 获胜。否则，Bob 获胜。 您将获得该图。您的任务是决定您希望扮演哪个玩家并赢得游戏。 你首先判断下是不是二分图。 如果不是二分图的话，那 Alice 肯定赢了，他只用 1 和 2 就行了。 如果是二分图，则是 Bob 赢，因为只用 1 和 2 都卡不了 Bob 的话，算上 3 就更没可能了。 现在的问题是，如果 Bob 赢的话，怎么确定方案。因为他可能 1 2 3 的数量和黑点白点数量不一样。 那其实如果数量出现了偏差的话，就是 1 2 变成了 1 3 或者类似的情况。 那我们的策略就是，Alice 给了 1 就涂白点，给了 2 就涂黑点。如果都不满足肯定是某种点涂完了，而且有 3，用 3 涂剩下的。 赛后群友说这是个原题","link":"/pinely-round-4-div-1-div-2/"},{"title":"2024“钉耙编程”中国大学生算法设计超级联赛（1）","text":"比赛链接 补题链接 Problems AC 1001. 循环位移 ○ 1002. 星星 ○ 1003. 树 ⊕ 1004. 传送 待补 1005. 博弈 ⊕ 1006. 序列立方 ⊕ 1007. 三元环 三维偏序 弃疗 1008. 位运算 ○ 1009. 数位的关系 1010. 众数 1011. 树上的 mex 1012. 并 待补 1001 循环位移 hash 定义字符串 $S=S_0+\\cdots+S_{n-1}$ 循环位移 $k$ 次为 $S(k)=S_{k \\bmod n}+\\cdots+S_{n-1}+$ $S_0+\\cdots+S_{(k-1) \\bmod n \\circ}$ 定义 $[A]={A(k), k \\in \\mathbb{N}}$.给出 $T$ 组串 $A, B$, 询问 $B$ 有多少个子串在 $[A]$ 中。 倍长一遍，然后把 n 个同构的 hash 值预处理出来丢进 map。 Code B队友写了 Code 1003 树 线段树合并 / DSU on Tree 给一棵根为 1 的有根树, 点 $i$ 具有一个权值 $A_i$ 。定义一个点对的值 $f(u, v)=\\max \\left(A_u, A_v\\right) \\times\\left|A_u-A_v\\right|$ 。你需要对于每个节点 $i$, 计算 $a n s_i=\\sum_{u \\in \\text { subtree }(i), v \\in \\text { subtree }(i)} f(u, v)$, 其中 subtree $(i)$表示 $i$ 的子树。 请你输出 $\\oplus\\left(a n s_i \\bmod 2^{64}\\right)$, 其中 $\\oplus$ 表示 XOR。 这个 f 函数其实就是 max * max - max * min。 假如你现在在一棵值域线段树上面，你知道左儿子和右儿子的信息。那么对于你这个节点，多出来的就是跨越你这个点的信息。这实际上就是 右边的平方和 * 左边的个数 - 右边的和 * 左边的和。线段树合并一下，做完了。 Code 1005 博弈 小马给出了一个可重小写字符集合 $S$ 。 Alice 初始时有空串 $A$, Bob 初始时有空串 $B$ 。 两人轮流等概率取出集合 $S$ 中的一个字符 $c$, 将它拼接到自己的字符串的后面, 直至 $S$为空, 每个字符只能被取一次, Alice 先手。 如果最终 $A$ 的字典序严格大于 $B$, 则 Alice 胜利, 求其获胜的概率, 答案对 998244353 取模。 其实，只要算下平局的概率就好了，由于对称性，减去平局的概率再除 2 就是答案。 如果出现次数为奇数的字符个数大于等于 2 的时候，必然无法平局。答案就是 1/2。 如果只有 1 个的话，算出去掉一个那个字符后平局的概率， 1006 序列立方 思维 / DP 给定长度为 $N$ 的序列 $a$ 一个序列有很多个子序列，每个子序列在序列中出现了若干次。 小马想请你输出序列 $a$ 每个非空子序列出现次数的立方值的和，答案对 998244353​ 取模。 $1 \\le a_i, N \\le 250$ 巧妙的转化 Trick，出现次数的三次方 = 同样的序列出现三次。 设 f[i][j][k] 代表现在选了三个序列，最后一位分别是 a[i], a[j], a[k]。需要满足 a[i] = a[j] = a[k]。 朴素的转移就是枚举上一个状态，可以用高维前缀和优化。 Code","link":"/2024%E2%80%9C%E9%92%89%E8%80%99%E7%BC%96%E7%A8%8B%E2%80%9D%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E8%B6%85%E7%BA%A7%E8%81%94%E8%B5%9B%EF%BC%881%EF%BC%89/"},{"title":"2024 杭电多校 10","text":"唉这场在高铁上，勉强打打。 头铁冲 hash，原来 hash 真能被卡啊（）血泪教训，能用 kmp 就一定要 kmp Problems AC 1001. LIS 1002. scenery ⊕ 1003. 败北 1004. 轰炸 1005. 套娃 1006. DuelForSun 1007. SunBoYi 1008. SunBian ○ 1009. 不基本子串结构 ⊕ 1010. A+B Problem 1011. NOI2024 ○ 1012. 花环 1002显然可选区间单调不变小这个性质会比较有用，这意味着我们每次肯定是贪心地放着区间两侧会比较优。 有一个比较巧妙的状态设计是这样的：对于一个 $j$，我们设 $[j, dp[j]]$ 这段时间是没被选择过的。 那么对于每一个 $i$，你枚举一个 $j$。然后更新即可 1008容易发现，除非特定情况下，一坨都会被 split 成两坨。随后在两坨上可以镜像操作。 所以先判断不能将一坨 split 成两坨的情况 (i.e. k == 1 or k == n) 否则 B 会 split 成两坨，这样 B 在 A 对面的那一坨上面镜像操作即可。 1009kmp 结束以后那个 j 的作用","link":"/2024-%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1-10/"},{"title":"2024“钉耙编程”中国大学生算法设计超级联赛（4）","text":"Claris Round, Random Round 我不敢苟同你的观点，我个人认为这个BOSS的血条就应该有很多层，因为这个矩阵的周期，它很容易会直接影响到最优K子段，你知道吧。你往里砸的时候，一瞬间它就会产生大量的魔法卡牌，俗称找环，会严重影响寻找宝藏，甚至对这个序列以及更新都会造成一定的核污染，你知道吧，啊？再者说，根据这个勾股定理，你可以很容易地推断出人工饲养的​黑白边游戏它是可以捕获野生的超维攻坚的，所以说这个这个这个这个，你不管昵称检索的切面是否具有放射性啊，分组的n次方是否含有沉淀物，都不影响这个P跟E会延时操控汇合。 Problems AC 7469. 超维攻坚 7470. 黑白边游戏 7471. 最优 K 子段 ⊕ 7472. 分组 7473. 多层血条 ○ 7474. 延时操控 ⊕ 7475. 序列更新 ⊕ 7476. 魔法卡牌 7477. 昵称检索 ○ 7478. 矩阵的周期 7479. 找环 7480. 寻找宝藏 待补 1003二分答案，问题转化为判断能否划分出 k 个不相交子段使得每段长度都是质数且权值和至少为 mid。 从左往右贪心划分，维护一个 set，不断把前面的 {sum[j], j} 加入 set。假设当前在 i，如果此时 set 里面存在一个 j 满足 sum[i] - sum[j] &gt;= mid &amp;&amp; isPrime[i - j]，那么说明可以划出一个子段，清空 set。重复这个过程即可。 如何判断是否存在？按 sum[j] 从小到大遍历 set，在前若干个里面遇到一个 i - j 是质数就停了。根据质数的密度这样不会太多，是 log 级别的。总复杂度 O(n logn log ans) 1005签到 1006关键转化：由于己方和敌方之间不会互相成为障碍，可以 将 m - k，转化为一个两个人一起走路的问题，最后再让自己游走 k 步。 那么可以考虑一个 DP。需要记录的状态有 当前轮次，双方坐标，对方血量。 这样的话状态数是 n^4 * m * hp 的。无法通过。 这时候有个性质，因为双方是一起移动的，所以位置差不会改变。除非撞墙了，撞墙会让坐标差 +-1。 因此对方的坐标只要存因为撞墙产生的差值即可。m * n ^ 2 * hp ^ 3 1007随机数据题，根号分治。 设 lim 为 b 中第 x 大元素，对于每次操作，考虑以下两种维护手法: 找到 a 中所有值小于等于 lim 的下标 i，用 b 更新 找到在 b 中所有大于 lim 的下标 i，用它更新 a。复杂度 O(x) 由于更新的复杂度是 O(1) 的，对于操作二而言，有 x 个需要更新的，所以是 O(x)。 那么对于操作 1 我们的复杂度是多少呢？由于数据随机，考虑计算 a 中一个位置期望需要经历多少次第一类操作，它的值才会大于 lim。假设经历了 i 次操作仍然小于等于 lim，那么就是说 i + 1 个随机数均不超过 lim，概率就是 (1 - x/n)^(i + 1)。所以期望操作次数就是: $$\\sum_{i \\geq 0}\\left(1-\\frac{x}{n}\\right)^{i+1} \\approx \\frac{1}{\\frac{x}{n}}=\\frac{n}{x}$$ 所以期望的时间复杂度就是 $O(q(\\frac{n}{x} + x))$，其中 $\\frac{n}{x} + x \\ge 2\\sqrt{n}$，当 $x = \\sqrt{n}$ 时取得边界。 1009 字符串稍微有点实现细节的签到。","link":"/2024%E2%80%9C%E9%92%89%E8%80%99%E7%BC%96%E7%A8%8B%E2%80%9D%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E8%B6%85%E7%BA%A7%E8%81%94%E8%B5%9B%EF%BC%884%EF%BC%89/"},{"title":"2024“钉耙编程”中国大学生算法设计超级联赛（2）","text":"比赛链接 Code Repo 我的代码都扔 Code Repo 里面了 Problems AC 1001. 鸡爪 ○ 1002. 梦中的地牢战斗 待补 1003. 绝对不模拟的简单魔方 ⊕ 1004. a*b problem 1005. 小塔的养成游戏之梦 1006. 传奇勇士小凯 ○ 1007. URL划分 ○ 1008. 成长，生命，幸福 ⊕ 1009. 强攻计策 1010. 女神的睿智 ○ 1011. 在 A 里面找有 C 的 B ○ 1012. 图计算 ⊕ 1001 鸡爪队友写了 1003 魔方 小T最近有些疲惫，想找一些能够放松自己的事情去做，正好想起上次被队友用三阶魔方暴杀的经历，就想苦练一下魔方技术，好在下次的对战中击败他的队友。 于是他在网上下单了一个魔方，让小C帮他去取快递。 可是小C有些调皮，私自拆开了快递，随意的扭了这个魔方不超过三次（扭的是侧面，不是中间层，且扭的角度固定为90度），还弄掉了同一个角上的两片贴纸。 小C的记性不太好，不太记得两片贴纸正确的位置了，所以随意的将两片贴纸贴了回去，并将这件事告诉了小T。 但小T作为一个还在学习如何还原底层十字的小萌新，面对被小C打乱过的魔方很是束手无策。 所以他向你寻求帮助，希望你告诉他小C有没有将两片贴纸正确的贴回去，如果没有的话，是哪一个角的贴纸贴错了呢。 逆天题，不超过三次的条件是为了骗你去爆搜，实际上直接看每个角的情况就行了。 1006 传奇勇士小凯 树形 DP分数类 + 树形 DP。 丁真题，直接转移。 1007 URL 划分 模拟逆天题，题面写不清楚。要定义了变量（带等号）的才输出。 1008 成长，生命，幸福 树的直径德鲁伊题。 最后几十分钟会了，没写出来。 首先一个性质是，成长一次后每个点度数有三种情况：1/2/3 对于度数为 2 的，下一次会分裂出 2 个 度数 2 的。 对于度数为 3 的，下一次会分裂出 2 个 度数 2 的 和 1 个 度数 3 的。 对于度数为 d 的，下一次会分裂出 2 个 度数 2 的 和 d - 2 个 度数 3 的。 那么对于一开始度数为 d 的点，(2, d - 2) -&gt; ((d - 2) * 2 + 2 * 2, d - 2) -&gt; ((d - 2) * 4 + (d - 2) * 2 + 2 * 2 * 2, d - 2)…… 归纳一下就是 $2 ^ m + (d - 2) * (2 ^ m - 1) = (d - 1) * 2 ^ m - d + 2$ 直接对这个权值求树的直径就是答案。但是，求直径的时候不是要两个点取 max 吗，直接算是会爆 long long 的，也不能取模。发现 2 ^ m 这一项是非常大的，也就说是你 2 ^ m 比 - d + 2 大出一个数量级的时候 比较 $(d_i - 1, -d_i + 2)$ 和 $(d_j - 1, -d_j + 2)$ 可以变为比较两个关键字的大小。 1010 女神的睿智 模拟签到题 1011 在 A 里面找有 C 的 BAC 自动机 + KMP 板子双拼的签到题。。。。。 1012 图计算逆天原题 洛谷 P8026 [ONTAK2015] Bajtocja 给定 $d$ 张 $n$ 个点的图和 $m$ 次加边操作 (每次只在某个图上加边), 求每次操作后在 $d$ 张图上都连通的点对个数, $d \\leq 200, n \\leq 5 \\times 10^3, m \\leq 10^6$ 。 首先你知道一张图的情况是很简单的并查集对吧。如果两个点在并查集的上的父亲都相同的话，那么他们就是相互连通的。 你拓展到 $d$ 个并查集的情况，那么把一个点在 $d$ 个并查集上的祖先 hash 下来。如果一个 hash 值出现了 $k$ 次的话，就对答案有 $k^2$ 的贡献。","link":"/2024%E2%80%9C%E9%92%89%E8%80%99%E7%BC%96%E7%A8%8B%E2%80%9D%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E8%B6%85%E7%BA%A7%E8%81%94%E8%B5%9B%EF%BC%882%EF%BC%89/"},{"title":"2024“钉耙编程”中国大学生算法设计超级联赛（3）","text":"HDU 逆天系统，赛时显示的不是过题队伍数量而是 AC 数。有个队最后 1h 狂交 1003。 Code Repo Problems AC 7457 深度自同构 ○ 7458 旅行 ⊕ 7459 游走 待补 7460 游戏 7461 数论 7462 字符串 7463 单峰数列 ○ 7464 比特跳跃 ○ 7465 圣芙蕾雅 7466 绘世之卷 7467 抓拍 ○ 7468 死亡之组 ○ 1001 深度自同构 DP 对于由若干有根树构成的森林，定义该森林是深度自同构的，当且仅当森林中任意两个深度相同的节点都有相同的度。 请计数有多少个深度自同构的无编号有根树森林，使得其恰好由 n 个节点构成，答案对 998244353 取模。 我们先考虑 由 n 个节点的合法的树的个数。转化一下条件，任意深度相同的节点有相同的度数，这其实意味着深度相同节点的子树形态是完全一样的。（度数其实是对树的形态的限制） 这个东西是可以递推的，令 $f_i$ 表示有 i 个点的合法的树的个数。拿出一个点作为根节点，剩下 $n - 1$ 个点我们枚举因数转移 $f_i=\\sum_{d \\mid(i-1)} f_d$。 那么对于森林的个数，其实就类似了，只不过不用多拿出一个点来作为根节点。$ans_i=\\sum_{d \\mid i} f_d$ 1002 旅行 线段树合并 本题要求树上一些不相交的链使得权值和最大，每个链要求起始点和 终止点颜色相同，权值为起点和终点的权值和。 第一场刚学了个树上的 DSU on Tree / 线段树合并 这类的问题，赛时尝试过往这方面去想，还是不会，正好多学学。 先来波感性理解，假如我们在树上 DP，我们在 LCA 处枚举经过这个点的链。如果这个点不被经过的话，就是把所有孩子节点的 dp 值加起来；如果被 (u, v) 经过的话，我们就要 (u, v) 的贡献以及 u 下面子树的贡献，v 下面子树的贡献，和这条链上其他点的其他孩子的 dp 值。 那么我们令 颜色 作为线段树的下标，维护 dp 值的 max。 dp[u][0] 存不经过的值，dp[u][1] 则是算上了经过的值 先遍历一遍子树，算出 dp[u][0]。然后遍历儿子，把每个儿子的线段树减去 dp[v][1] 后 merge，在 merge 的时候，如果递归到了叶子节点，就维护 dp[u][1]。 1007 单峰数列 线段树典题。可以直接线段树大力维护。事实上，维护差分数组可以更简单。 1008 比特跳跃 建图 给你一张图 和 k。点 x 可以花 k * (x or y) 的代价跳到点 y。求点 1 到各个点的最短路。 1011 抓拍 三分原题，弱化版。 1012 死亡之组签到。","link":"/2024%E2%80%9C%E9%92%89%E8%80%99%E7%BC%96%E7%A8%8B%E2%80%9D%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E8%B6%85%E7%BA%A7%E8%81%94%E8%B5%9B%EF%BC%883%EF%BC%89/"},{"title":"2024“钉耙编程”中国大学生算法设计超级联赛（6）","text":"Problems AC 7494. 造花（简单版） ○ 7495. 造花（困难版） ⊕ 7496. 飞车狂飙 ○ 7497. 不醒人室 ○ 7498. 交通管控 ⊕ 7499. 解方程 格基归约，弃疗 7500. 树上 MEX 问题 ⊕ 7501. 树形 DNA 待补 7502. 数字加减 大模拟，弃疗 7503. Rikka 与子集 IV 多项式，弃疗 7504. 天天爱跑步 待补 1001 造花（简单版）1007 树上 MEX 问题MEX，数数 给定一棵 n 个点的树，每个点有点权，点权是 0 到 n - 1 的排列，求所有连通块(连通导出子图)的 MEX 之和。 $1 \\le n \\le 10^5$ 好题，学到了 直接的统计答案是 枚举 i，对 i * 恰好 mex = i 的子图数量 求和。这样的话答案是很难算的。 众所周知在这类问题上有个常见的 trick 是在 钦定 和 恰好之间转换。 假如我们钦定[0, i - 1] 这 i 个点选的话，剩下随意，那么 mex 只能是 &gt;= i 的。这个数量我们其实是更方便求一点的。 换言之，假设我们求出了 mex &gt;= i 的子图数量 $num_i$ 。那么恰好 mex = i 的子图数量就是 $num_i - num_{i + 1}$ $$ans = \\sum_{i = 1}^{n}{i \\times (num_i - num_{i + 1})}= \\sum_{i = 1}^{n}{i \\times num_i} - \\sum_{i = 2}^{n + 1}{(i - 1) \\times num_i}= num_1 + \\sum_{i = 2}^{n}{num_i} - n \\times num_{n + 1}= \\sum_{i = 1}^{n}{num_i}$$ 接下来考虑如何计数 $num_i$。 跑一个 $dp_u = \\prod_{v \\in son(u)} (dp_v + 1)$ 表示 u 这个点必选，u 和 u 的子树能构成的联通子图数量。 将 0 作为树的 rt。那么 [0, i] 这些点以及路径上的其他点都是必选的，我们把这看成一个集合 S。剩下的点都是可选可不选。$num_i$ 就等于所有和 S 这坨东西直接相连且不在 S 里面的点的 (dp_v + 1) 的乘积 那么在 S 集合新加进来一个点的时候，只需要不断往上跳，大力维护：原来是可选可不选的 (dp_v + 1)，现在是必须要选的 (dp_v)。 因为每个点最多只会被加入到 S 一次，所以是对的。 1011 天天爱跑步基环树 给一棵基环树，对每个点 i 求过 i 的最长简单路径。 $1 \\le n \\le 10^5$ 假如不是基环树，是一棵树，那么答案是好求的，一个点无非是两条往下或者一条往下一条往上的拼起来，这个东西是很好 dp 的。 如果是基环树，一个环挂着很多树。一个点 i 往下走的最长路径是 $mxd_i$，那么每个 i 就是要找个 j 配对，构成一个 $mxd_i + mxd_j + 环上路径$","link":"/2024%E2%80%9C%E9%92%89%E8%80%99%E7%BC%96%E7%A8%8B%E2%80%9D%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E8%B6%85%E7%BA%A7%E8%81%94%E8%B5%9B%EF%BC%886%EF%BC%89/"},{"title":"2024“钉耙编程”中国大学生算法设计超级联赛（7）","text":"Problems AC 1001. 纠缠点对 1002. 生产机器 ⊕ 1003. 自动人偶 KMP 自动机，弃疗 1004. 战争游戏 ○ 1005. Hold’em Shark 大模拟，弃疗 1006. 怯战蜥蜴 II 多项式，弃疗 1007. 创作乐曲 ⊕ 1008. 循环图 ⊕ 1009. 关于 agKc 实在不喜欢自动化于是啥都自己合成这件事 ○ 1010. 故障机器人想活下去 ○ 1011. 蛋糕上的草莓是蛋糕的灵魂 ○ 1012. 华丽牧场 1002. 生产机器 某型号的作业机器人可以生产蓝色和黄色两种充能球。根据接下来 $n$ 小时的工作计划, 该机器人在第 $i$ 小时可以生产至多 $l_i$ 个黄色充能球和 $f_i$ 个蓝色充能球, 也可以不生产任何一个充能球。 在接下来 $n$ 个小时的工作结束之后, 该机器人生产的充能球将按其被生产的顺序依次装入集装箱。具体而言, 每小时内生产的充能球的顺序可以由机器人任意确定, 而前一小时生产的所有充能球都排在后一小时生产的充能球之前。 现在, 请你计算, 最终集装箱中装入的充能球所构成的序列共有多少种可能。两个序列不同当且仅当其包含的充能球总数不同, 或者存在一个 $i$, 使得两个序列中生产的第 $i$ 个充能球颜色不同。由于答案可能很大, 你只需要输出答案对 $10^9+7$ 取模的结果。 思维 + 组合数学 如何避免重复？在组合数学中一个常见的思想：钦定！ 假如我们现在想要一个序列。我们这样操作：从前往后，每个时段需要尽可能多出球，直到需要的颜色这个时段没有为止，再换下一个时段 or 在这个时段结束。 这样的话能保证序列是不重的。 于是我们基于此设计 dp(i, j) 表示到第 i 个时段，这一个时段生产的第一个小球颜色为 j，对应的合法方案数。 我们需要枚举下一个时段的 dp(i + 1, k) 进行更新。根据前面的设计，k 这个颜色需要在 i 时段全部用完；另一种颜色则随意。 假如第 i 个时段，填上第一个球以后，两种球分别还剩 x 和 y 个。假如这个时段这 x 个球是要全部被用完的话，方案数我们有： $$\\sum_{i=0}^y\\binom{i+x}{x}=\\binom{x+y+1}{x+1}$$ 这个式子是怎么从左边到右边的？x + y + 1 个物品，选其中的 x + 1 个，相当于，钦定在 x + i + 1 个位置选到了 x + 1 个，然后在前 x + i 个里面选 x 个 假如在当前时段结束选球，那么就是： $$\\sum_{i=0}^x \\sum_{j=0}^y\\binom{i+j}{i}=\\sum_{i=0}^x \\binom{i+y+1}{i+1}=\\sum_{i=1}^{x+1} \\binom{i+y}{i}=\\binom{x+y+2}{x+1} - 1$$ 复杂度 $O(n + w)$ 1007. 创作乐曲通过发现性质，减少决策点！ 1008. 循环图 坎格鲁斯普雷被困在了一张循环图里，这张循环图有无数个节点，初始时坎格鲁斯普雷在 1 号节点。 循环图是边存在着一定循环关系的图，循环图里面的边可以用循环周期 $n$ 和 $m$ 对三元组 $\\left(u_i, v_i, w_i\\right)\\left(1 \\leq u_i \\leq n, u_i+1 \\leq v_i \\leq 2 \\times n, 1 \\leq w_i \\leq 10^9\\right)$ 表示。每对三元组 $\\left(u_i, v_i, w_i\\right)$ 表示，对于循环图内所有的满足 $s=u_i+k \\times n, t=v_i+k \\times n(k \\in N)$ 的点对 $(s, t)$ ，都存在有 $w_i$ 条从点 $s$ 通往点 $t$ 的边。 现在，坎格鲁斯普雷知道了这张循环图的第 $L$ 个节点到第 $R$ 个节点各存在着一个出口，坎格鲁斯普雷需要到达这些节点中的任意一个才能逃出循环图（到达有出口存在的节点后不一定要立刻逃出）。坎格鲁斯普雷想请你帮他算算，他有多少种逃出这张循环图的方式。由于答案可能很大，你需要输出答案对 $10^9+7$ 取模后的结果。 设 calc(i) 为走到 [1, i] 节点的方案数只和，ans = calc(R) - calc(L - 1) 设 f(i) 为走到 i 节点的方案数之和，这个东西是很好 dp 的。那我们直接先求出 f(1), f(2) … f(n) 然后搞出我们的转移矩阵。这里有一个技巧是，我们直接搞出一个大转移矩阵，这个转移矩阵相当于步长是 n，这样我们 pow 的指数就变成了 x / n，最后边角 O(x % n) 扫一下即可。 1011. 蛋糕上的草莓是蛋糕的灵魂","link":"/2024%E2%80%9C%E9%92%89%E8%80%99%E7%BC%96%E7%A8%8B%E2%80%9D%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E8%B6%85%E7%BA%A7%E8%81%94%E8%B5%9B%EF%BC%887%EF%BC%89/"},{"title":"2024“钉耙编程”中国大学生算法设计超级联赛（8）","text":"Problems AC 1001. cats 的快乐 CF 刷题 1002. cats 的随机原神 1003. cats 的飞机坠毁 1004. cats 的重力拼图 ○ 1005. cats 的二分答案 ⊕ 1006. cats 的最小生成树 ⊕ 1007. cats 的 k-xor ○ 1008. cats 的数据结构 ⊕ 1009. cats 的凸包计算 1010. cats 的集合 1 ⊕ 1011. cats 的集合 2 1012. cats 的电脑中毒 ○ 1006 cats 有一个有 n 个点，m 个边的可能有重边的无向图。边有边权，其中第 i 条边的边权为 i。 在一次操作中，cats 会找出这个图的最小生成树，然后将图中所有属于最小生成树的边移除。cats 会不断重复以上操作直到图不连通为止。 现在，你需要告诉 cats 图中的每一条边是在第几次操作中被移除的。若一条边在操作结束时未被移除，你需要输出 −1。 可以证明在以上条件下，cats 每次选择的最小生成树一定是唯一的。 注：一个有 n 个点的图的最小生成树即为这个图的所有的包含全部 n 个点和刚好 n−1 条边的连通子图中使子图所有边的边权总和最小的子图。 有启发性的一道题。 解法一朴素的想法就是按题意模拟 m / (n - 1) 轮 Kruscal，这样的话耗时 O(m / (n - 1) * m)","link":"/2024%E2%80%9C%E9%92%89%E8%80%99%E7%BC%96%E7%A8%8B%E2%80%9D%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E8%B6%85%E7%BA%A7%E8%81%94%E8%B5%9B%EF%BC%888%EF%BC%89/"},{"title":"2024“钉耙编程”中国大学生算法设计超级联赛（5）","text":"我草真唐氏了啊，红温下机。。。 你说的对，但是我在世末农庄里找到了一块数表上面有树论一和树论二我只能用心感受三同时开关灯之后有猫咪军团在猫咪们狂欢它们在玩猫罐头游戏送了我一个Array-Gift里面有一个捆绑魔方但我想吃串串，但这就是飞行棋。 Problems AC 7481. 数表（二） 7482. Array-Gift ⊕ 7483. 捆绑魔方 大模拟，弃疗 7484. 树论（一） ⊕ 7485. 树论（二） ⊕ 7486. 猫罐头游戏 ○ 7487. 猫咪军团 7488. 猫咪们狂欢 ⊕ 7489. 用心感受（三） 杜教筛 弃疗 7490. 世末农庄 待补 7491. 开关灯 ○ 7492. 串串 sam 弃疗 7493. 飞行棋 ○ Code Repo 1002 Array-Gift红温罪魁祸首。操作肯定就是 n, n - 1, n + 1 三种。 写代码的时候对于 n 那种情况，枚举 ai mod aj，忘记判断 aj mod x 也要等于 0 了，糖丸了。。。。。。。。。。。。 1004 树论（一）树，LCA，猜结论，数据结构 Fun Fact: std 的 LCA 写假了，但是数据满足儿子节点编号大于父亲，所以 ans 是对的 赛时不会做，以为又是什么 DSU on Tree / 线段树合并。。。不会。 看起来可能是个经典 trick 了，（至少看起来就很典的样子 $$\\sum_{i=1}^n \\sum_{j=1}^n[\\operatorname{lcm}(i, j) \\leq n]=O\\left(n \\log ^2 n\\right)$$ 也就是说，这个点对数量其实是有限的，n = 1e5 的时候大概是 2e6 对。 这时候就醍醐灌顶了。。。。。。。。。。。 你把这些点对预处理出来，按照 lcm 排序。然后把询问离线下来。用双指针把 点对的贡献打到 lca 上面。单点修改区间查询，树状数组做完了。 1005 树论（二）树，数据结构，并查集，数论，调和级数 感觉很秒的一个题 赛时一直在想删边分成两个点集到底怎么搞。其实这就相当于，对于两个点，把他们的 gcd 赋给路径上的边。 求最大就是每条边把所有能赋给他的值里面取 max。暴力的想法就是枚举一个 d，然后把 d 的倍数这些点取出来，建个虚树，然后路径赋值 max 对吧。那你想，你可以改变枚举顺序，从大到小枚举 d，这样一条边只会被赋值 1 次。对于那些已经赋值过的边，我们就不用管了，我们每次就是在一个集合里面找一些边，然后赋值，然后扔到另外一个不用管的集合里面，这个过程是可以用并查集实现的！ 1006 猫罐头游戏最终的局面必然是 1 1 1。 直觉会发现这是个和奇偶性有关的游戏。 接下来用 0 表示偶数，1 表示奇数。 一个 1 只能被分成 1 和 0，一个 0 可以被分成 1 和 1 or 0 和 0 （除非这个 0 是 2 的话只能分成 1 1） 0 1 1 或者 1 0 0 都可以转移到 1 1 1，但是 1 1 1 只能转移到 1 1 0。 所以 1 1 1 是个必败态。0 1 1 和 1 1 0 都是必胜态。 那么 0 0 0 呢？0 0 0 只能转移到 0 0 0 或者 0 1 1。但是 0 1 1 必胜，所以双方会一直转移到 0 0 0，直到转移不下去，必须转移到 0 1 1 了（也就是出现 2 了）。 1008 猫咪们狂欢网络流 哈哈，又是不会 Flow 的一天。警钟敲烂 首先 Flow 的内容忘的差不多了。之前学的时候也没做什么题让大脑 over-fit 到 Flow。 这是个 最大权闭合子图 模型，详见 P1361 小M的作物。 这个题相当于是说，给你 n 个物品，有 m 个 rule (u_i, v_i)。对于一个 rule，如果你将 u 和 v 同时放入第一个集合可以获得 w1 的价值，同时放入第二个集合则可以获得 w2 的价值。求最大价值。 我们要做的就是划分这 n 个点成两个集合 我们这样建图： 对于第 i 个限制 $(u_i, v_i)$，建立虚拟点 $i_1$ $i_2$ 分别代表放入第一/第二个集合 $S$ 向 $i_1$ 连边，容量为 $w_1$；$i_2$ 向 $T$ 连边，容量为 $w_2$ $i_1$ 向 $u_i$, $v_i$ 连边，容量 $inf$；$u_i$, $v_i$ 向 $i_2$ 连边，容量 $inf$ 在这个图上面跑最小割，容量为 inf 的边不会被割掉。如果 (S, i1) 被 cut 了，相当于放到第一个集合里面。如果 (i2, T) 被 cut 了，相当于放到第二个集合里面。 1011 开关灯打表。证明详见题解 1013 飞行棋当你在 0 的时候，直接到终点的概率是 $\\frac{1}{n}$，否则，你会有 $\\frac{n - 1}{n}$ 的概率进入 [1, n - 1] 这个区间。 进入这个区间以后，每花费 1 代价，你要么是直接进入终点 $\\frac{1}{n}$，要么是 roll 到 n 了，用赠送的机会进入终点 $\\frac{1}{n} \\times \\frac{1}{n - 1}$。$\\frac{1}{n} + \\frac{1}{n} \\times \\frac{1}{n - 1} = \\frac{1}{n - 1}$。不然的话其实你还是必然留在这个区间里面。那么这里期望花费的代价就是 n - 1。 所以答案就是 $$\\frac{1}{n} \\times 1 + \\frac{n - 1}{n} \\times (1 + (n - 1)) = \\frac{1}{n} + n - 1$$","link":"/2024%E2%80%9C%E9%92%89%E8%80%99%E7%BC%96%E7%A8%8B%E2%80%9D%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E8%B6%85%E7%BA%A7%E8%81%94%E8%B5%9B%EF%BC%885%EF%BC%89/"},{"title":"2024 杭电多校 9","text":"Problems AC 1001. 树异或价值 ⊕ 1002. 树上询问 ⊕ 1003. 黑洞合并 ○ 1004. 亡语 1005. 怪物猎人 ○ 1006. 融合矿石 1007. 小猫钓鱼 ○ 1008. 最佳选手 1009. 长期素食 1010. 收集签名 1011. 地牢谜题：更高还是更低 1012. 地牢谜题：三个怪人 1001 树异或价值学到了拆 dep，算 dep 次相当于从这个点往上每个点算一次 $$\\sum_{i=1}^n \\sum_{j=1}^n\\left(a_i \\oplus a_j\\right) \\times \\operatorname{dep}_{L C A(i, j)}$$ $$=\\sum_{i=1}^n \\sum_{j=1}^n\\left(a_i \\oplus a_j\\right) \\sum_{x=1}^n[i \\in \\operatorname{subtree}(x)][j \\in \\operatorname{subtree}(x)]$$ $$=\\sum_{x=1}^n \\sum_{i \\in \\text { subtree }(x)} \\sum_{j \\in \\text { subtree( } x)}\\left(a_i \\oplus a_j\\right)$$ 1005 怪物猎人我草，赛时乱冲了 10 发，然后发现 read 没开 long long 1007 小猫钓鱼我草，赛后才发现每个数最多才出现两次 赛时读错题了，写了个 plus 版本，但是过了","link":"/2024-%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1-9/"},{"title":"BNUZH 2024 暑期邀请赛","text":"AK + Rank1 魅力手速时刻.jpg 比赛链接 Problems AC A. Arithmetic Sequence Sum ○ B. Sort ○ C. 好价钱 ○ D. 刷最合适的题 ○ E. Reverse and Truth ○ F. Forest Sum ○ G. 火车出行 ○ H. 小 Q 的游戏 ○ 总体难度不高，适合萌新联系基础和手速。 我自己的 AC 代码放 Github 了，点击查看","link":"/bnuzh-2024-%E6%9A%91%E6%9C%9F%E9%82%80%E8%AF%B7%E8%B5%9B/"},{"title":"UIC-ACM 新春挑战赛","text":"比赛链接 ASource: HDU 4767 Bell 打了个暴力发现输出不对，发现这个模数不是一个质数 50 分做法就是直接的结合杨辉三角暴力 O(n^2) 递推 听讲题发现 linux 下面有个很赛艇的 prompt 可以直接分解质因数：factor 95041567 然后你就会发现 95041567 = 31 * 37 * 41 * 43 * 47 然后题目里面给了一个公式 B[p + n] = B[n] + B[n + 1] (mod p and p is a prime) 类似于 Fibonacci 数列的递推，常系数齐次线性递推 构造转移矩阵。这样就可以对于单个质因数推出答案。 现在的问题是对于多个质因数的答案如何合并？中国剩余定理。 >folded1 B>folded1 C>folded1 D>folded1","link":"/uic-acm-%E6%96%B0%E6%98%A5%E6%8C%91%E6%88%98%E8%B5%9B/"},{"title":"UIC-ACM 月赛·February","text":"比赛链接 A[UIC 1030] 选择题.cpp >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;#define int long long#define pb push_backusing std::cin, std::cout, std::string;int read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 1e4 + 5;const int INF = 1 &lt;&lt; 30;// const long long INF = 1LL &lt;&lt; 60;int n;string inp[N];int buk[4], ans;void solve(){ string s, t; cin &gt;&gt; s &gt;&gt; t; buk[0] = buk[1] = buk[2] = buk[3] = 0; for (auto ch : t) buk[ch - 'A'] = 1; int cnt = 0; for (auto ch : s) { if (buk[ch - 'A'] != 1) { cnt = 5; break; } else cnt++; } if (cnt == 5) return; else if (cnt == t.size() and t.size() == 1) ans += 3; else if (cnt == t.size()) ans += 5; else ans += 2;}signed main(){#ifndef ONLINE_JUDGE freopen(&quot;A.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); cout &lt;&lt; ans; return 0;} B[UIC 1031] 统计.cpp >folded1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;#define int long long#define pb push_backusing std::cin, std::cout, std::string;int read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 2e5 + 5;const int INF = 1 &lt;&lt; 30;// const long long INF = 1LL &lt;&lt; 60;int n, q, a[N], lft[N], rgt[N], bel[N];void solve(){ n = read(), q = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(); for (int i = 1; i &lt;= n; i++) lft[i] = a[i] == a[i - 1] ? lft[i - 1] : i; for (int i = n; i &gt;= 1; i--) rgt[i] = a[i] == a[i + 1] ? rgt[i + 1] : i; int nodecnt = 0; for (int i = 1; i &lt;= n; i++) bel[i] = nodecnt, nodecnt += (rgt[i] == i); // for (int i = 1; i &lt;= n; i++) cout &lt;&lt; bel[i] &lt;&lt; ' '; // puts(&quot;-------&quot;); // for (int i = 1; i &lt;= n; i++) for (int l, r; q; q--) { l = read(), r = read(); cout &lt;&lt; bel[r] - bel[l] + 1 &lt;&lt; '\\n'; // cout &lt;&lt; q &lt;&lt; '\\n'; }}signed main(){#ifndef ONLINE_JUDGE freopen(&quot;B.in&quot;, &quot;r&quot;, stdin);#endif for (int T = 1; T--; solve()); return 0;} C[UIC 1032] 删除字符.cpp >folded12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;#define int long long#define pb push_backusing std::cin, std::cout, std::string;int read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 1e6 + 5;const int INF = 1 &lt;&lt; 30;// const long long INF = 1LL &lt;&lt; 60;int n, buk[27];void solve(){ string s; cin &gt;&gt; n &gt;&gt; s; for (int i = 0; i &lt; 26; i++) buk[i] = 0; int ans = 0, cnt = 0; for (auto ch : s) { if (!buk[ch - 'a']) cnt++; buk[ch - 'a']++; ans += cnt; } cout &lt;&lt; ans &lt;&lt; '\\n';}signed main(){#ifndef ONLINE_JUDGE freopen(&quot;C.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;} D贴下 sol，讲的很清晰了 不难发现，对于每一列，一定是从最大的开始选择。而且不同列之间的选择是独立的，所以可以先给每一列单独从大到小排序，然后再进行后续分析。选择的这个过程实际上可以看作是一个大小为 N × K 的窗口从左往右滑动，并且这个 窗口是一个上三角的，即对于窗口的第 i 列，最多只能选择前 i 个物品。并且如果一次 性选择了 j 个，那么这个窗口还会向右一次性滑动 j 个单位。设 f[i,j] 表示当前窗口左端点在第 i 列，且当前考虑到的是整个序列的第 j 列时收获的最大电子币之和。转移的话，只需要枚举第 j 列选择了多少个就行 [UIC 1033] 电子钱包.cpp >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;#define int long long#define pb push_backusing std::cin, std::cout, std::string;int read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int M = 1e5 + 5;const int N = 10 + 5;int n, m, k, a[N][M], sum[N][M], f[N][M];void solve(){ n = read(), m = read(), k = read(); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) a[i][j] = read(); for (int j = 1; j &lt;= m; j++) { std::vector&lt;int&gt; b(n); for (int i = 1; i &lt;= n; i++) b[i - 1] = a[i][j]; std::sort(b.rbegin(), b.rend()); for (int i = 1; i &lt;= n; i++) a[i][j] = b[i - 1]; for (int i = 1; i &lt;= n; i++) a[i][j] += a[i - 1][j]; } for (int i = 1; i + k - 1 &lt;= m; i++) for (int j = i; j &lt;= i + k - 1; j++) { int len = j - i + 1; for (int c = 0; c &lt;= len and i + k - 1 + c &lt;= m + 1; c++) f[len - c + 1][i + c] = std::max(f[len - c + 1][i + c], f[len][i] + a[c][j]); } int ans = 0; for (int i = 1; i &lt;= k; i++) for (int j = 0; j &lt;= m + 1; j++) ans = std::max(ans, f[i][j]); cout &lt;&lt; ans;}signed main(){#ifndef ONLINE_JUDGE freopen(&quot;D.in&quot;, &quot;r&quot;, stdin);#endif for (int T = 1; T--; solve()); return 0;} E看成数轴上的若干条线段，sum 是这 n 条线段长度的和 手玩一下交换一条线段，发现只有两条线段不交的时候才会使答案变大 [UIC 1034] 绝对值.cpp >folded12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;#define int long long#define pb push_backusing std::cin, std::cout, std::string;int read(int x = 0, int f = 0, char ch = getchar()){ while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 1e6 + 5;// const long long INF = 1LL &lt;&lt; 60;int n, a[N], b[N];void solve(){ n = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(); for (int i = 1; i &lt;= n; i++) b[i] = read(); int ans = 0; for (int i = 1; i &lt;= n; i++) ans += abs(a[i] - b[i]); int sum = ans, p = 1, q = 1; for (int i = 1; i &lt;= n; i++) { if (std::max(a[i], b[i]) &lt; std::max(a[p], b[p])) p = i; if (std::min(a[i], b[i]) &gt; std::min(a[q], b[q])) q = i; } for (int i = 1; i &lt;= n; i++) ans = std::max(ans, sum - abs(a[i] - b[i]) - abs(a[p] - b[p]) + abs(a[i] - b[p]) + abs(a[p] - b[i])), ans = std::max(ans, sum - abs(a[i] - b[i]) - abs(a[q] - b[q]) + abs(a[i] - b[q]) + abs(a[q] - b[i])); cout &lt;&lt; ans &lt;&lt; '\\n';}signed main(){#ifndef ONLINE_JUDGE freopen(&quot;E.in&quot;, &quot;r&quot;, stdin);#endif for (int T = read(); T--; solve()); return 0;}","link":"/uic-acm-%E6%9C%88%E8%B5%9B%C2%B7february/"},{"title":"UIC–ACM 月赛 24 Nov. 官方题解","text":"比赛链接 Luke’s Score （贡献计算）30 pts暴力枚举以 $i$ 开头，以 $j$ 结尾的区间，并 $O(n)$ 求和，复杂度 $O(n^3)$。 60 pts预处理出前缀和数组 $sum[i]$，同样还是枚举区间，求和的复杂度降到了 $O(1)$，总的复杂度为 $O(n^2)$ 100 pts考虑每一个数会被多少个区间包括。 例如：$3$ 个数 $[1,2,3]$。包括 $1$ 的区间有 $[1,1], [1,2], [1,3]$，包括 $2$ 的区间有 $[1,2],[1,3],[2,2],[2,3]$ 共四个。 对于每个位置 $i$，包含 $A[i]$ 的区间，左端点可以在 $[1, i]$ 里选，右端点可以在 $[i, n]$ 里选，共有 $i \\times (n-i+1)$ 种选法，所以 $A[i]$ 被统计了 $i \\times (n-i+1)$ 次。 答案即为 $$\\sum_{i = 1}^{n} a[i] \\cdot i \\cdot (n - i + 1)$$ 用这个方法计算，时间复杂度为 $O(n)$。 1234567891011121314#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;ll n, x, ans;int main() { scanf(&quot;%lld&quot;, &amp;n); for (ll i = 1; i &lt;= n; i++) { scanf(&quot;%lld&quot;, &amp;x); ans += x * i * (n - i + 1); ans %= 1000000007; } printf(&quot;%lld&quot;, ans); return 0;} Luke’s Game （数论、GCD 的性质、xor 的性质）30 pts枚举两个数并判断，$O(n^2\\log{n})$ 60 pts根据 $xor$ 的性质，$a \\operatorname{xor} b = c$ 等价于 $a \\operatorname{xor} c = b$ 那么有 $\\operatorname{gcd}(a, b) = \\operatorname{gcd}(a, a \\operatorname{xor} c) = c$ 而其中 $c$ 是 $a$ 的约数，因此我们可以枚举 $c$，再枚举 $a = i \\times c$，由于 $\\frac{n}{1} + \\frac{n}{2} + \\frac{n}{3} + \\ldots + \\frac{n}{n} = O(n \\log n)$，再算上 $\\operatorname{gcd}$ 的一只 $\\log$，总复杂度 $O(n \\log^2 n)$ 100 pts因为 $a = b$ 是肯定无解，所以不妨设 $a &gt; b$。 根据 $\\gcd$ 的性质，我们有 $\\operatorname{gcd}(a,b) \\le a - b$。 根据 $\\operatorname{xor}$ 的性质，我们有 $a - b \\le a \\operatorname{xor} b$ 因此 $c = \\operatorname{gcd}(a,b) \\le a - b \\le a \\operatorname{xor} b = c$ 所以我们可以推出 $c = a - b$ 那么我们在 60 pts 的算法基础上，有 $\\operatorname{gcd}(a, a - c) = c$，所以我们只需判断 $a \\operatorname{xor} c = a - c$即可，复杂度 $O(n \\log{n})$ 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;void solve() { int n; std::cin &gt;&gt; n; int ans = 0; for (int i = 3; i &lt;= n; i += 2) { int k = n / i; for (int j = 1; j &lt;= k; j++) { int t = i * j; if ((t ^ (t - j)) == j) { ans++; } } } std::cout &lt;&lt; ans;}signed main() { // for (int T = read(); T--; solve()); solve(); return 0;} 速算大师小 R （数学、高精度）根据题意，易得需要计算的数为${2^P}-1$向下取整，求$1 + log_{10} ({2^P}-1)$，以及${2^P}-1$的后500位。 对于前$30%$的数据，开$long long$累乘求位数，随后用前导零补齐空缺即可。 前$70%$的数据可以采用高精度计算累乘解决，时间复杂度为$O(n^2)$。 对于最后$30%$的数据： 如果$log_{10} x$是整数，易得$x$的最后一位一定是$0$，$x-1$的最后一位一定是$9$（若$x$不为1）。 由于$log_{10}({2^P}-1)$最后一位不可能为$9$，因此$log_{10}({2^P}-1)$ 向下取整就相当于 $log_{10}({2^P})$ 向下取整。 而$log_{10}({2^P}) = P·log_{10}{2}$。 因此第一行的答案就是 1int(log10(2)*p+1) 用高精快速幂可以在$O(log_2 P)$的时间复杂度里求出后500位。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;void out(vector&lt;int&gt; a){ a[0] -= 1; for (int i = 499; i &gt;= 0; i--) { printf(&quot;%d&quot;, a[i]); if (i % 50 == 0) putchar('\\n'); } return;}vector&lt;int&gt; muti(vector&lt;int&gt; a, vector&lt;int&gt; b){ vector&lt;int&gt; rt; for (int i = 0; i &lt; 500; i++) rt.push_back(0); for (int i = 0; i &lt; 500; i++) { for (int j = 0; j &lt; 500; j++) { if (i + j &gt;= 500) continue; rt[i + j] += a[i] * b[j]; } } for (int i = 0; i &lt; 500 - 1; i++) { rt[i + 1] += rt[i] / 10; rt[i] %= 10; } rt[499] %= 10; return rt;}vector&lt;int&gt; fpow2(int p){ vector&lt;int&gt; rt; if (p == 0) { rt.push_back(1); for (int i = 1; i &lt; 500; i++) rt.push_back(0); return rt; } rt = fpow2(p / 2); rt = muti(rt, rt); vector&lt;int&gt; mutiv; mutiv.push_back(2); for (int i = 1; i &lt; 500; i++) mutiv.push_back(0); if (p % 2) rt = muti(rt, mutiv); return rt;}signed main(){ int p; scanf(&quot;%d&quot;, &amp;p); cout &lt;&lt; int(log10(2) * p + 1) &lt;&lt; endl; out(fpow2(p)); return 0;} 傻鹿尖塔（反悔贪心）对于前20分，暴力枚举使用药水的时机即可。 考虑使用反悔贪心，当遇到新的怪物时，尽可能使用药水，如果没有药水可以用，则检查之前用过药水的怪物造成伤害的最小值，若比当前怪物造成的伤害少则改为对当前怪物使用药水，血量减去被反悔的怪物的攻击力。暴力枚举时间复杂度为$O(n^2)$。 使用优先队列维护使用过药水的怪物的攻击力可以将时间复杂度压缩至$O(n log_2 n)$。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;void solve(){ long long n, x, k; scanf(&quot;%lld%lld%lld&quot;, &amp;n, &amp;x, &amp;k); priority_queue&lt;long long, vector&lt;long long&gt;, greater&lt;long long&gt;&gt; pq; int ans = -1; for (int i = 1; i &lt;= n; i++) { long long in; scanf(&quot;%lld&quot;, &amp;in); if (k) { k--; pq.push(in); } else if (pq.size() &amp;&amp; pq.top() &lt; in) { x -= pq.top(); pq.pop(); pq.push(in); } else { x -= in; } if (x &lt;= 0 &amp;&amp; ans == -1) ans = i - 1; } if (ans == -1) ans = n; printf(&quot;%d\\n&quot;, ans);}int main(){ int t; scanf(&quot;%d&quot;, &amp;t); while (t--) solve(); return 0;} 树联网（树、DFS）对于前$50%$的数据，可以对每条边两边的点分别进行一次搜索来统计点数，时间复杂度为$O(n^2)$。 随意选一个点作为根，再以这个点出发构造有根树。在进行dfs时，每搜索完一条边，可以通过树的总节点数和子树的节点数快速计算出这条边两边节点个数的差异。时间复杂度为$O(n)$。 1ans+=abs(n-2*size[to])*val; 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;struct edge{ int to; long long val;};int n;long long ans = 0;bool used[1000005];int siz[1000005];vector&lt;edge&gt; begraph[1000005];vector&lt;edge&gt; aftgraph[1000005];void maketree(){ queue&lt;int&gt; deal; deal.push(1); while (deal.size()) { int indx = deal.front(); used[1] = 1; deal.pop(); for (int i = 0; i &lt; begraph[indx].size(); i++) if (!used[begraph[indx][i].to]) { aftgraph[indx].push_back(begraph[indx][i]); used[begraph[indx][i].to] = 1; deal.push(begraph[indx][i].to); } }}int dfs(int lo){ if (!aftgraph[lo].size()) { siz[lo] = 1; return siz[lo]; } for (int i = 0; i &lt; aftgraph[lo].size(); i++) { siz[lo] += dfs(aftgraph[lo][i].to); ans += abs(n - 2 * siz[aftgraph[lo][i].to]) * aftgraph[lo][i].val; } siz[lo]++; return siz[lo];}int main(){ cin &gt;&gt; n; for (int i = 1; i &lt;= n - 1; i++) { int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); edge indx; indx.to = a; indx.val = c; begraph[b].push_back(indx); indx.to = b; begraph[a].push_back(indx); } maketree(); dfs(1); cout &lt;&lt; ans; return 0;} 山路（思维、差分）$20pts$枚举最终道路的高度，对于每个高度进行多次遍历，每次遍历统计出不连续的最低和最高段数，将这些高度$+1$/$-1$并计数。 $60pts$枚举最终道路的高度，对于每次枚举，统计相对于高度的连续高峰/低谷，每个高度只需一次遍历即可求出答案。 $100pts$考虑把初始道路的高度转化成差分数组，操作在差分数组中会变成将$0∼n+1$的任意一位$+1$，另一位$-1$。最终要让第$2∼n$位的所有数归零，最终道路的高度为差分数组中第$0$位的大小。 可知最低花费为差分数组中正数之和与负数之和绝对值的最大值，道路高度的可能数为正数之和与负数之和绝对值之差$+1$。 完整代码12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;long long num[10000005];long long cf[10000005];int main(){ int n; scanf(&quot;%d&quot;, &amp;n); long long cntz = 0, cntf = 0; for (int i = 1; i &lt;= n; i++) { scanf(&quot;%lld&quot;, &amp;num[i]); cf[i] = num[i] - num[i - 1]; if (i != 1) { if (cf[i] &gt; 0) cntz += cf[i]; if (cf[i] &lt; 0) cntf -= cf[i]; } } cout &lt;&lt; max(cntz, cntf) &lt;&lt; endl &lt;&lt; abs(cntz - cntf) + 1; return 0;}","link":"/uic%E2%80%93acm-%E6%9C%88%E8%B5%9B-24-nov-%E5%AE%98%E6%96%B9%E9%A2%98%E8%A7%A3/"},{"title":"2024 CCPC 网络预选赛 正式赛","text":"The 2024 CCPC Online Contest 警钟敲烂 Problems AC A. 军训 I 分讨，弃疗 B. 军训 II ○ C. 种树 ⊕ D. 编码器-解码器 ○ E. 随机过程 ○ F. 包子鸡蛋 III 多项式，弃疗 G. 疯狂星期四 ⊕ H. 另一个游戏 弃疗 I. 找行李 ⊕ J. 找最小 ⊕ K. 取沙子游戏 ○ L. 网络预选赛 ○ B 结论签到，队友写的。 C 贪心好聪明的设计 一次操作最多拓展 $2$ 个点。 对于一个 $siz$ 大小的子树，且只有根节点被染色了，那么一共需要 $\\lfloor \\frac{siz}{2} \\rfloor$ 次操作。 对子树根节点是否被染色讨论： 如果已经被染色了，那么这个子树对根节点的父亲的贡献有两种情况：用最少次数做完子树时，是否存在多余的、且对子树根节点的父亲有贡献的操作。 如果没有被染色，那就向上传递，直到遇到被染色的为止。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using i64 = long long;#define int i64#define pb push_back#define ep emplace#define eb emplace_backusing std::max, std::min, std::swap;using std::cin, std::cout, std::string, std::vector;int read(int x = 0, int f = 0, char ch = getchar()) { while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}void solve() { int n = read(), m = read(); vector&lt;int&gt; vis(n + 1); for (int i = 1; i &lt;= m; i++) { vis[read()] = 1; } vector&lt;vector&lt;int&gt;&gt; g(n + 1); for (int i = 1; i &lt; n; i++) { int u = read(), v = read(); g[u].pb(v), g[v].pb(u); } int ans = 0; vector&lt;int&gt; siz(n + 1); std::function&lt;void(int, int)&gt; dfs = [&amp;](int u, int fa) { for (auto v : g[u]) { if (v == fa) continue; dfs(v, u); siz[u] += siz[v]; } siz[u] += !vis[u]; if (vis[u]) { ans += (siz[u] + 1) / 2; if (siz[u] &amp; 1) vis[fa] = 1; siz[u] = 0; } }; for (int i = 1; i &lt;= n; i++) { if (vis[i]) { dfs(i, 0); break; } } cout &lt;&lt; ans &lt;&lt; '\\n';}signed main() { for (int T = read(); T--; solve()); // solve(); return 0;} D 区间 DP队伍因为这道题浪费了巨大多时间，小齐代码可读性和鲁棒性差，导致最后帮忙一起调才出了这道题 我觉得比如小齐今天那个 设边界值就很乱，会容易出错然后状态继承的时候也不明显，所以今天就漏了状态继承，我后面才发现我觉得不要写的 能省则省这样会很容易出错也不容易调 解法 1考虑一个区间 dp，$dp[i][l][r]$ 代表经过 $i$ 轮后，$t[l]…t[r]$ 的出现次数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;bits/stdc++.h&gt;using i64 = long long;#define int i64#define pb push_back#define ep emplace#define eb emplace_backusing std::max, std::min, std::swap;using std::cin, std::cout, std::string, std::vector;int read(int x = 0, int f = 0, char ch = getchar()) { while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}template &lt;class T&gt;constexpr T power(T a, i64 b) { T res {1}; for (; b; b /= 2, a *= a) if (b % 2) res *= a; return res; }constexpr i64 mul(i64 a, i64 b, i64 p) { i64 res = a * b - (i64)(1.L * a * b / p) * p; res %= p; if (res &lt; 0) res += p; return res; }template &lt;i64 P&gt;struct MInt { i64 x; constexpr MInt() : x {0} {} constexpr MInt(i64 x) : x {norm(x % getMod())} {} static i64 Mod; constexpr static i64 getMod() { return P &gt; 0 ? P : Mod; } constexpr static void setMod(i64 Mod_) { Mod = Mod_; } constexpr i64 norm(i64 x) const { if (x &lt; 0) x += getMod(); if (x &gt;= getMod()) x -= getMod(); return x; } constexpr i64 val() const { return x; } constexpr MInt operator-() const { MInt res; res.x = norm(getMod() - x); return res; } constexpr MInt inv() const { return power(*this, getMod() - 2); } constexpr MInt &amp;operator*=(MInt rhs) &amp; { if (getMod() &lt; (1ULL &lt;&lt; 31)) x = x * rhs.x % int(getMod()); else x = mul(x, rhs.x, getMod()); return *this; } constexpr MInt &amp;operator+=(MInt rhs) &amp; { x = norm(x + rhs.x); return *this; } constexpr MInt &amp;operator-=(MInt rhs) &amp; { x = norm(x - rhs.x); return *this; } constexpr MInt &amp;operator/=(MInt rhs) &amp; { return *this *= rhs.inv(); } friend constexpr MInt operator*(MInt lhs, MInt rhs) { MInt res = lhs; res *= rhs; return res; } friend constexpr MInt operator+(MInt lhs, MInt rhs) { MInt res = lhs; res += rhs; return res; } friend constexpr MInt operator-(MInt lhs, MInt rhs) { MInt res = lhs; res -= rhs; return res; } friend constexpr MInt operator/(MInt lhs, MInt rhs) { MInt res = lhs; res /= rhs; return res; } friend constexpr std::istream &amp;operator&gt;&gt;(std::istream &amp;is, MInt &amp;a) { i64 v; is &gt;&gt; v; a = MInt(v); return is; } friend constexpr std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const MInt &amp;a) { return os &lt;&lt; a.val(); } friend constexpr bool operator==(MInt lhs, MInt rhs) { return lhs.val() == rhs.val(); } friend constexpr bool operator!=(MInt lhs, MInt rhs) { return lhs.val() != rhs.val(); } friend constexpr bool operator&lt;(MInt lhs, MInt rhs) { return lhs.val() &lt; rhs.val(); }};template &lt;&gt;i64 MInt&lt;0&gt;::Mod = 998244353;constexpr int P = 998244353;using Z = MInt&lt;P&gt;;const int N = 1e2 + 5;Z dp[N][N][N];void solve() { string s, t; cin &gt;&gt; s &gt;&gt; t; int n = s.size(); int m = t.size(); s = ' ' + s; t = ' ' + t; for (int i = 0; i &lt;= n; i++) { for (int l = 1; l &lt;= m + 1; l++) { for (int r = 0; r &lt; l; r++) { dp[i][l][r] = 1; } } } for (int i = 1; i &lt;= n; i++) { for (int l = 1; l &lt;= m; l++) { for (int r = l; r &lt;= m; r++) { for (int k = l - 1; k &lt;= r; k++) { dp[i][l][r] += dp[i - 1][l][k] * dp[i - 1][k + 1][r]; } for (int k = l - 1; k &lt; r; k++) { if (s[i] == t[k + 1]) { dp[i][l][r] += dp[i - 1][l][k] * dp[i - 1][k + 2][r]; } } // cout &lt;&lt; l &lt;&lt; &quot; &quot; &lt;&lt; r &lt;&lt; &quot; &quot; &lt;&lt; dp[i][l][r] &lt;&lt; '\\n'; } } } cout &lt;&lt; dp[n][1][m];}/*aabaabaaabaaabaabacabaabacabadabacaba*/signed main() { // for (int T = read(); T--; solve()); solve(); return 0;} 解法 2看题解好像有一种很赛艇的矩阵做法！ E 期望一开始假式子确实浪费不少时间，我们沟通太烂了，经常不能互相确认做法的正确性 对于 Trie 第 i 层的某个节点，其不出现的概率是 $(1 - \\frac{1}{26^{i}})^n$ 其出现的概率就是 $1-(1 - \\frac{1}{26^{i}})^n$ 这一层总共有 $26^i$ 个点，每个点是否出现的概率都是相同的。 答案就是 $$\\sum_{i = 0}^{m}[1-(1 - \\frac{1}{26^{i}})^n]26^i$$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;using i64 = long long;#define int i64#define pb push_back#define ep emplace#define eb emplace_backusing std::max, std::min, std::swap;using std::cin, std::cout, std::string, std::vector;int read(int x = 0, int f = 0, char ch = getchar()) { while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}template &lt;class T&gt;constexpr T pow(T a, i64 b) { T res {1}; for (; b; b /= 2, a *= a) if (b % 2) res *= a; return res; }constexpr i64 mul(i64 a, i64 b, i64 p) { i64 res = a * b - (i64)(1.L * a * b / p) * p; res %= p; if (res &lt; 0) res += p; return res; }template &lt;i64 P&gt;struct MInt { i64 x; constexpr MInt() : x {0} {} constexpr MInt(i64 x) : x {norm(x % getMod())} {} static i64 Mod; constexpr static i64 getMod() { return P &gt; 0 ? P : Mod; } constexpr static void setMod(i64 Mod_) { Mod = Mod_; } constexpr i64 norm(i64 x) const { if (x &lt; 0) x += getMod(); if (x &gt;= getMod()) x -= getMod(); return x; } constexpr i64 val() const { return x; } constexpr MInt operator-() const { MInt res; res.x = norm(getMod() - x); return res; } constexpr MInt inv() const { return pow(*this, getMod() - 2); } constexpr MInt &amp;operator*=(MInt rhs) &amp; { if (getMod() &lt; (1ULL &lt;&lt; 31)) x = x * rhs.x % int(getMod()); else x = mul(x, rhs.x, getMod()); return *this; } constexpr MInt &amp;operator+=(MInt rhs) &amp; { x = norm(x + rhs.x); return *this; } constexpr MInt &amp;operator-=(MInt rhs) &amp; { x = norm(x - rhs.x); return *this; } constexpr MInt &amp;operator/=(MInt rhs) &amp; { return *this *= rhs.inv(); } friend constexpr MInt operator*(MInt lhs, MInt rhs) { MInt res = lhs; res *= rhs; return res; } friend constexpr MInt operator+(MInt lhs, MInt rhs) { MInt res = lhs; res += rhs; return res; } friend constexpr MInt operator-(MInt lhs, MInt rhs) { MInt res = lhs; res -= rhs; return res; } friend constexpr MInt operator/(MInt lhs, MInt rhs) { MInt res = lhs; res /= rhs; return res; } friend constexpr std::istream &amp;operator&gt;&gt;(std::istream &amp;is, MInt &amp;a) { i64 v; is &gt;&gt; v; a = MInt(v); return is; } friend constexpr std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const MInt &amp;a) { return os &lt;&lt; a.val(); } friend constexpr bool operator==(MInt lhs, MInt rhs) { return lhs.val() == rhs.val(); } friend constexpr bool operator!=(MInt lhs, MInt rhs) { return lhs.val() != rhs.val(); } friend constexpr bool operator&lt;(MInt lhs, MInt rhs) { return lhs.val() &lt; rhs.val(); }};template &lt;&gt;i64 MInt&lt;0&gt;::Mod = 998244353;constexpr int P = 998244353;using Z = MInt&lt;P&gt;;const Z inv26 = Z(26).inv();void solve() { int n = read(), m = read(); Z ans[2] = {1, 1}; for (int i = 1, now = 1; i &lt;= m; i++) { now = min(now * 26, n); ans[0] += now; } Z a = 26, b = inv26; for (int i = 1; i &lt;= m; i++) { ans[1] += a * (1 - pow(1 - b, n)); a *= 26, b *= inv26; } cout &lt;&lt; ans[0] &lt;&lt; ' ' &lt;&lt; ans[1];}signed main() { // for (int T = read(); T--; solve()); solve(); return 0;} G 最大流首先你可以算出来主角的最大花费 $c$，每个人最大花费就是 $\\min(a_i, c - 1)$ 问题转化为一个是否存在合法解的问题 根据以上信息跑个最大流： 源点向每个菜品连容量为菜品费用的边 菜品向食用的两个人连容量为菜品费用的边 每个人向汇点连容量为每个人最大花费的边 存在合法解当且仅当最大流等于菜品总费用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176#include &lt;bits/stdc++.h&gt;using i64 = long long;#define int i64#define pb push_back#define ep emplace#define eb emplace_backusing std::max, std::min, std::swap;using std::cin, std::cout, std::cerr, std::string, std::vector;int read(int x = 0, int f = 0, char ch = getchar()) { while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}constexpr int inf = 1E9;template&lt;class T&gt;struct MaxFlow { struct _Edge { int to; T cap; _Edge(int to, T cap) : to(to), cap(cap) {} }; int n; std::vector&lt;_Edge&gt; e; std::vector&lt;std::vector&lt;int&gt;&gt; g; std::vector&lt;int&gt; cur, h; MaxFlow() {} MaxFlow(int n) { init(n); } void init(int n) { this-&gt;n = n; e.clear(); g.assign(n, {}); cur.resize(n); h.resize(n); } bool bfs(int s, int t) { h.assign(n, -1); std::queue&lt;int&gt; que; h[s] = 0; que.push(s); while (!que.empty()) { const int u = que.front(); que.pop(); for (int i : g[u]) { auto [v, c] = e[i]; if (c &gt; 0 &amp;&amp; h[v] == -1) { h[v] = h[u] + 1; if (v == t) { return true; } que.push(v); } } } return false; } T dfs(int u, int t, T f) { if (u == t) { return f; } auto r = f; for (int &amp;i = cur[u]; i &lt; int(g[u].size()); ++i) { const int j = g[u][i]; auto [v, c] = e[j]; if (c &gt; 0 &amp;&amp; h[v] == h[u] + 1) { auto a = dfs(v, t, std::min(r, c)); e[j].cap -= a; e[j ^ 1].cap += a; r -= a; if (r == 0) { return f; } } } return f - r; } void addEdge(int u, int v, T c) { g[u].push_back(e.size()); e.emplace_back(v, c); g[v].push_back(e.size()); e.emplace_back(u, 0); } T flow(int s, int t) { T ans = 0; while (bfs(s, t)) { cur.assign(n, 0); ans += dfs(s, t, std::numeric_limits&lt;T&gt;::max()); } return ans; } std::vector&lt;bool&gt; minCut() { std::vector&lt;bool&gt; c(n); for (int i = 0; i &lt; n; i++) { c[i] = (h[i] != -1); } return c; } struct Edge { int from; int to; T cap; T flow; }; std::vector&lt;Edge&gt; edges() { std::vector&lt;Edge&gt; a; for (int i = 0; i &lt; e.size(); i += 2) { Edge x; x.from = e[i + 1].to; x.to = e[i].to; x.cap = e[i].cap + e[i + 1].cap; x.flow = e[i + 1].cap; a.push_back(x); } return a; }};void solve() { int n = read(), m = read(); int s = n + m + 1, t = s + 1; MaxFlow&lt;int&gt; g(t + 1); vector&lt;int&gt; a(n + 1), v(n + 1); for (int i = 1; i &lt;= n; i++) { a[i] = read(); v[i] = read(); } int c = 0; int tot = 0; for (int i = 1; i &lt;= m; i++) { int x = read(), y = read(), w = read(); g.addEdge(s, n + i, w); g.addEdge(n + i, x, w); g.addEdge(n + i, y, w); tot += w; if (x == 1 or y == 1) c += w; } c = min(c + v[1], a[1]); bool flag = 1; g.addEdge(1, t, c - v[1]); for (int i = 2; i &lt;= n; i++) { a[i] = min(a[i], c - 1); if (a[i] &lt; v[i]) { flag = 0; break; } g.addEdge(i, t, a[i] - v[i]); } if (!flag or g.flow(s, t) != tot) { cout &lt;&lt; &quot;NO\\n&quot;; } else { cout &lt;&lt; &quot;YES\\n&quot;; }}signed main() { // for (int T = read(); T--; solve()); solve(); return 0;} I DP赛时学弟队出了这题，短暂尝试了跟榜但是没什么想法，此时队友 E 有思路就去冲 E 了。可惜就差 1 分钟。 考虑尝试对每个可能的答案算出方案数，然后求和。发现不太好做。 常见套路：恰好转换成至少至多 设 $g(d)$ 表示答案大于等于 $d$ 的方案数，则 $ans = \\sum_{d = 0}^{500}{d \\times (g(d) - g(d + 1))}$ 将行李和人排序，枚举 $d$。 如果 $a_i + d &lt;= b_j$，那么 $a_i$ 这个行李就可以被 $b_j$ 这个人拿。且 $b_j$ 能拿的行李一定是 $b_{j + 1}$ 能拿行李的子集。 即然 $d$ 确定了，每个人可以拿的行李数量 $sum[i]$ 可以直接 $O(n^2)$ 统计出来。 $dp_{i, j}$ 表示前 $i$ 个人，拿了 $j$ 个行李的方案数。当前这个人不拿，就是 $dp_{i - 1, j}$。拿了，就是 $dp_{i - 1, j - 1}$ 乘上当前可选择的行李数量 $sum[i] - (j - 1)$ 时间复杂度 $O(n^3)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;bits/stdc++.h&gt;using i64 = long long;#define int i64#define pb push_back#define ep emplace#define eb emplace_backusing std::max, std::min, std::swap;using std::cin, std::cout, std::cerr,std::string, std::vector;int read(int x = 0, int f = 0, char ch = getchar()) { while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}template &lt;class T&gt;constexpr T power(T a, i64 b) { T res {1}; for (; b; b /= 2, a *= a) if (b % 2) res *= a; return res; }constexpr i64 mul(i64 a, i64 b, i64 p) { i64 res = a * b - (i64)(1.L * a * b / p) * p; res %= p; if (res &lt; 0) res += p; return res; }template &lt;i64 P&gt;struct MInt { i64 x; constexpr MInt() : x {0} {} constexpr MInt(i64 x) : x {norm(x % getMod())} {} static i64 Mod; constexpr static i64 getMod() { return P &gt; 0 ? P : Mod; } constexpr static void setMod(i64 Mod_) { Mod = Mod_; } constexpr i64 norm(i64 x) const { if (x &lt; 0) x += getMod(); if (x &gt;= getMod()) x -= getMod(); return x; } constexpr i64 val() const { return x; } constexpr MInt operator-() const { MInt res; res.x = norm(getMod() - x); return res; } constexpr MInt inv() const { return power(*this, getMod() - 2); } constexpr MInt &amp;operator*=(MInt rhs) &amp; { if (getMod() &lt; (1ULL &lt;&lt; 31)) x = x * rhs.x % int(getMod()); else x = mul(x, rhs.x, getMod()); return *this; } constexpr MInt &amp;operator+=(MInt rhs) &amp; { x = norm(x + rhs.x); return *this; } constexpr MInt &amp;operator-=(MInt rhs) &amp; { x = norm(x - rhs.x); return *this; } constexpr MInt &amp;operator/=(MInt rhs) &amp; { return *this *= rhs.inv(); } friend constexpr MInt operator*(MInt lhs, MInt rhs) { MInt res = lhs; res *= rhs; return res; } friend constexpr MInt operator+(MInt lhs, MInt rhs) { MInt res = lhs; res += rhs; return res; } friend constexpr MInt operator-(MInt lhs, MInt rhs) { MInt res = lhs; res -= rhs; return res; } friend constexpr MInt operator/(MInt lhs, MInt rhs) { MInt res = lhs; res /= rhs; return res; } friend constexpr std::istream &amp;operator&gt;&gt;(std::istream &amp;is, MInt &amp;a) { i64 v; is &gt;&gt; v; a = MInt(v); return is; } friend constexpr std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const MInt &amp;a) { return os &lt;&lt; a.val(); } friend constexpr bool operator==(MInt lhs, MInt rhs) { return lhs.val() == rhs.val(); } friend constexpr bool operator!=(MInt lhs, MInt rhs) { return lhs.val() != rhs.val(); } friend constexpr bool operator&lt;(MInt lhs, MInt rhs) { return lhs.val() &lt; rhs.val(); }};template &lt;&gt;i64 MInt&lt;0&gt;::Mod = 998244353;constexpr int P = 998244353;using Z = MInt&lt;P&gt;;void solve() { int n = read(), m = read(); vector&lt;int&gt; a(n + 1), b(m + 1); for (int i = 1; i &lt;= n; i++) a[i] = read(); for (int i = 1; i &lt;= m; i++) b[i] = read(); std::sort(a.begin() + 1, a.end()); std::sort(b.begin() + 1, b.end()); Z ans = 0; vector&lt;Z&gt; g(505); for (int d = 0; d &lt;= 500; d++) { vector&lt;int&gt; sum(m + 1); for (int i = 1; i &lt;= m; i++) { for (int j = 1; j &lt;= n; j++) { if (b[i] - a[j] &gt;= d) { sum[i]++; } } } vector f(m + 1, vector&lt;Z&gt;(n + 1)); f[0][0] = 1; for (int i = 1; i &lt;= m; i++) { for (int j = 0; j &lt;= min(n, sum[i]); j++) { f[i][j] += f[i - 1][j]; if (j &gt;= 1) { f[i][j] += f[i - 1][j - 1] * (sum[i] - (j - 1)); } } // for (int j = 0; j &lt;= min(n, sum[i]); j++) { // cerr &lt;&lt; i &lt;&lt; &quot;-&quot; &lt;&lt; j &lt;&lt; &quot; &quot; &lt;&lt; f[i][j] &lt;&lt; '\\n'; // } } for (int j = 0; j &lt;= n; j++) { g[d] += f[n][j]; } } for (int d = 0; d + 1 &lt;= 500; d++) ans += (g[d] - g[d + 1]) * d; cout &lt;&lt; ans &lt;&lt; '\\n';}/**/signed main() { // for (int T = read(); T--; solve()); solve(); return 0;} J 线性基3 个人 2 个完全不会线性基。我没想到要线性基，唉硬实力太烂了。 一开始还把题目读假了，以为是任意换 $a_i$ 和 $b_j$。后来发现只有 $a_i$ 和 $b_i$ 可以换。 那就很简单了，令 $c_i = a_i \\oplus b_i$，交换意味着 $fa$ 和 $fb$ 都 $\\oplus$ 上 $c_i$。 对于这 $O(n)$ 个 $c_i$，扔进线性基，然后用线性基贪心就做完了。 唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using i64 = long long;#define int i64#define pb push_back#define ep emplace#define eb emplace_backusing std::max, std::min, std::swap;using std::cin, std::cout, std::string, std::vector;int read(int x = 0, int f = 0, char ch = getchar()) { while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}struct Basis { int num_zero; std::vector&lt;int&gt; b; Basis() {} Basis(int n) { b.resize(n); std::fill(b.begin(), b.end(), 0); } bool add(int x) { for (int i = 62; i &gt;= 0; i--) { if (x &gt;&gt; i &amp; 1) { if (b[i]) { x ^= b[i]; } else { b[i] = x; return true; } } } num_zero++; return false; }};void solve() { int n = read(); Basis bas(63); int fa = 0, fb = 0; vector&lt;int&gt; a(n), b(n); for (auto &amp;x : a) x = read(), fa ^= x; for (auto &amp;x : b) x = read(), fb ^= x; for (int i = 0; i &lt; n; i++) bas.add(a[i] ^ b[i]); // cout &lt;&lt; fa &lt;&lt; &quot; &quot; &lt;&lt; fb &lt;&lt; '\\n'; for (int i = 62; i &gt;= 0; i--) { if (max(fa ^ bas.b[i], fb ^ bas.b[i]) &lt; max(fa, fb)) { fa ^= bas.b[i]; fb ^= bas.b[i]; } } cout &lt;&lt; max(fa, fb) &lt;&lt; &quot;\\n&quot;;}signed main() { for (int T = read(); T--; solve()); // solve(); return 0;} K 博弈赛时思路不够 clean，导致浪费了点时间。 首先，奇数的情况是显然的。偶数的情况呢，想要 A 必胜，是否只需要在做完第一步之后完全复刻 B 的操作就行了？ 对于一个 $n$，如果其 $lowbit \\le k$，那么 A 第一步只需要取走 $lowbit$，随后完全复刻 B 的操作即可。 如果其 $lowbit &gt; k$，那么无论 A 第一步怎么取，都会让 $lowbit$ 变成 $\\le k$ 的状态，B 拿到这个状态就必胜。 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using i64 = long long;#define int i64#define pb push_back#define ep emplace#define eb emplace_backusing std::max, std::min, std::swap;using std::cin, std::cout, std::string, std::vector;int read(int x = 0, int f = 0, char ch = getchar()) { while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}void solve() { int n = read(), k = read(); if ((n &amp; (-n)) &lt;= k) { puts(&quot;Alice&quot;); } else { puts(&quot;Bob&quot;); }}signed main() { for (int T = read(); T--; solve()); // solve(); return 0;} L 签到签到题，代码就不放了","link":"/2024-ccpc-%E7%BD%91%E7%BB%9C%E9%A2%84%E9%80%89%E8%B5%9B-%E6%AD%A3%E5%BC%8F%E8%B5%9B/"},{"title":"2024 ICPC 昆明邀请赛","text":"比赛链接 Problems AC A. Two-star Contest ○ B. Gold Medal ○ C. Stop the Castle 2 D. Generated String E. Relearn through Review ⊕ F. Collect the Coins 待补 G. Be Positive ○ H. Subarray I. Left Shifting 2 ○ J. The Quest for El Dorado ⊕ K. Permutation L. Trails ⊕ M. Italian Cuisine 待补 E gcd 的性质 给定一个长为 n 的数列 a[n], 和一个非负整数 k。可以至多一次 选择数列的一个区间 +k求最大化的序列 gcd 和 赛时盯着这道题盯了一个小时然后写了个假算法 赛时想到了 gcd 是单调不增的，也想到了 gcd 最多会减少 logX 次 一段数同时加上 k 以后，gcd 和他们的差有关 明明都知道了这三个关键的性质，还是没得出正解。 假如把整个序列写成一个柿子，答案就非常明了了 $ \\gcd(a[1]…a[n]) = $ $\\gcd(\\gcd(a[1]…a[l - 1]), \\gcd(\\left|a[l] - a[l + 1]\\right|…\\left|a[r - 1] - a[r]\\right|), a[r] + k, \\gcd(a[r + 1]…a[n])) $ 假如 r 确定，则后两项都确定了。至于前两项，都只和原数组有关。 至于原数组，结合 gcd 前缀只有 logX 个的性质，本质不同的只有 logX 个，枚举 logX 个分界点即可 note：注意 ans 的初值 123456789101112131415161718192021222324252627282930void solve() { int n = read(), k = read(); vector&lt;int&gt; a(n + 1); for (int i = 1; i &lt;= n; i++) { a[i] = read(); } vector&lt;int&gt; pre(n + 1), suf(n + 2); for (int i = 1; i &lt;= n; i++) { pre[i] = std::__gcd(pre[i - 1], a[i]); } for (int i = n; i &gt;= 1; i--) { suf[i] = std::__gcd(suf[i + 1], a[i]); } int ans = pre[n]; for (int i = 1; i &lt;= n; i++) { if (pre[i] == pre[i - 1]) continue; int g = 0; for (int j = i; j &lt;= n; j++) { g = std::__gcd(g, a[j] + k); ans = max(ans, std::__gcd(pre[i - 1], std::__gcd(g, suf[j + 1]))); } } cout &lt;&lt; ans &lt;&lt; '\\n';} J 最短路 RMQ 给一张无向图，每条边有长度和颜色。从节点 $1$ 开始一共要走 $k$ 轮，每一轮可以一次性走完颜色均为 $a_i$ 且总长不超过 $b_i$ 的边。问 $k$ 轮走完以后能走到哪些点。$n, m, k \\le 5 \\times 10^5$ 以走到了第 r 轮为第一关键字，这一轮走了距离 d 为第二关键字，作为最短路的距离。 当拓展一条边 (c, len) 时如果 $c = a_r$ 且 $d + len \\le b_r$，则可以直接转移。 否则需要在 $[r + 1, k]$ 中找一个颜色为 $c$ 的且 $b_nr \\ge len$ 的最早的一个 $nr$ 转移过去。 每个颜色开个 rmq，在 rmq 上二分即可。 复杂度 $O(m (\\log{m} + \\log{k}) + k \\log k)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697void solve() { int n = read(), m = read(), k = read(); vector g(n + 1, vector&lt;array&lt;int, 3&gt;&gt;()); for (int i = 1; i &lt;= m; i++) { int u = read(), v = read(); int c = read(), w = read(); g[u].pb({v, c, w}); g[v].pb({u, c, w}); } vector&lt;std::array&lt;int, 2&gt;&gt; tik(k + 1); vector rmq(m + 1, vector(21, vector&lt;int&gt;())); vector pos(m + 1, vector&lt;int&gt;()); for (int i = 1; i &lt;= k; i++) { tik[i][0] = read(); tik[i][1] = read(); rmq[tik[i][0]][0].eb(tik[i][1]); pos[tik[i][0]].eb(i); } for (int c = 1; c &lt;= m; c++) { for (int j = 1; j &lt;= 20; j++) { rmq[c][j].assign(rmq[c][0].size() + 1, 0); } } for (int c = 1; c &lt;= m; c++) { for (int j = 1; j &lt;= 20; j++) { for (int i = 0; i + (1 &lt;&lt; j) - 1 &lt; rmq[c][0].size(); i++) { rmq[c][j][i] = max(rmq[c][j - 1][i], rmq[c][j - 1][i + (1 &lt;&lt; (j - 1))]); } } } auto getrmq = [&amp;](int c, int l, int r) { int k = std::__lg(r - l + 1); return max(rmq[c][k][l], rmq[c][k][r - (1 &lt;&lt; k) + 1]); }; auto search = [&amp;](int l, int c, int len) { if (pos[c].empty() or pos[c].back() &lt; l) return -1; l = std::lower_bound(pos[c].begin(), pos[c].end(), l) - pos[c].begin(); int res = -1; for (int r = rmq[c][0].size() - 1; l &lt;= r; ) { int mid = l + r &gt;&gt; 1; if (getrmq(c, l, mid) &gt;= len) { res = mid, r = mid - 1; } else { l = mid + 1; } } if (res == -1) return -1; return pos[c][res]; }; vector&lt;int&gt; vis(n + 1); vector&lt;array&lt;int, 2&gt;&gt; dis(n + 1, {inf, inf}); std::priority_queue&lt;array&lt;int, 3&gt;, vector&lt;array&lt;int, 3&gt;&gt;, std::greater&lt;&gt;&gt; q; dis[1] = {1, 0}; q.push({1, 0, 1}); while (!q.empty()) { auto [r, d, u] = q.top(); q.pop(); if (vis[u]) continue; vis[u] = 1; for (auto [v, c, len] : g[u]) { if (tik[r][0] == c and tik[r][1] &gt;= d + len) { if (dis[v][0] &gt; r or dis[v][0] == r and dis[v][1] &gt; d + len) { q.push({r, d + len, v}); } continue; } int nr = search(r + 1, c, len); if (nr == -1) continue; if (dis[v][0] &gt; nr or dis[v][1] == nr and dis[v][1] &gt; len) { q.push({nr, len, v}); } } } for (int i = 1; i &lt;= n; i++) { cout &lt;&lt; vis[i]; } puts(&quot;&quot;);} L LIS 二维平面每个整点 $(x, y)$ 都有连向 $(x + 1, y)$ 和 $(x, y + 1)$ 的两条无向路径。另外还有 $n$ 条特殊的无向路径连接 $(x_i, y_i)$ 和 $(x_i + 1, y_i + 1)$。 设 $f(x, y)$ 表示从 $(0, 0)$ 走到 $(x, y)$ 需要的最少路径数。给 $p$ 和 $q$，求 $\\sum_{x = 0}^p\\sum_{y=0}^{q}f(x,y)$ 多组数据，$n \\le 10^6$，$p, q \\le 10^6$。 假如没有额外路径的话，$f(x, y) = x + y$ 那么考虑上额外小径就是减去最多经过的额外小径数量 从贡献角度考虑，一个斜线 (x0, y0) -&gt; (x0 + 1, y0 + 1) 会让 f(x &gt; x0, y &gt; y0) 这个矩形 -1。因此可以把所有斜线按 $x_i$ 为第一关键字升序，$y_i$ 为第二关键字降序排列。 这样走到 (x, y) 最多经过的斜线数量就等价于一个最长上升子序列的长度。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void solve() { int n = read(); int p = read(), q = read(); using pii = std::pair&lt;int, int&gt;; #define fi first #define se second vector&lt;pii&gt; a(n); for (auto &amp;[x, y] : a) { x = read(), y = read(); } std::sort(a.begin(), a.end(), [](pii x, pii y) { return x.fi == y.fi ? x.se &gt; y.se: x.fi &lt; y.fi; }); std::set&lt;int&gt; s; int ans = p * (p + 1) / 2 * (q + 1) + q * (q + 1) / 2 * (p + 1); int sum = 0, las = 0; for (auto [x, y] : a) { if (x &gt;= p) break; if (y &gt;= q) continue; if (las &lt;= x) { ans -= (x - las + 1) * sum; las = x + 1; } if (s.empty() or y &gt; *std::prev(s.end())) { s.insert(y); sum += q - y; } else { auto it = s.lower_bound(y); sum -= q - *it; sum += q - y; s.erase(it); s.insert(y); } } if (las &lt;= p) { ans -= (p - las + 1) * sum; } cout &lt;&lt; ans &lt;&lt; '\\n';}","link":"/2024-icpc-%E6%98%86%E6%98%8E%E9%82%80%E8%AF%B7%E8%B5%9B/"},{"title":"2024 CCPC 网络预选赛 热身赛","text":"Problems AC A. 2022 百度之星初赛第三场 字符计数 ○ B. 2024 河北省赛 - J - Iris’ Food ○ C. 2024 东北省赛 - K - Tasks ⊕ D. 2024 河北省赛 - F - 3 Split A联通块计数 原题：2022 百度之星初赛第三场 字符计数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using i64 = long long;#define int i64#define pb push_back#define ep emplace#define eb emplace_backusing std::max, std::min, std::swap;using std::cin, std::cout, std::string, std::vector;int read(int x = 0, int f = 0, char ch = getchar()) { while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int dx[] = {0, 0, -1, 1};const int dy[] = {-1, 1, 0, 0};void solve() { int n = read(), m = read(); vector&lt;string&gt; a(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i]; } vector&lt;vector&lt;int&gt;&gt; vis(n, vector&lt;int&gt;(m)); std::array&lt;int, 3&gt; ans; auto bfs = [&amp;](int sx, int sy) { int cnt = 0; std::queue&lt;std::pair&lt;int, int&gt;&gt; q; vis[sx][sy] = 1, q.push({sx, sy}); while (!q.empty()) { cnt++; auto [x, y] = q.front(); q.pop(); for (int i = 0; i &lt; 4; i++) { int nx = x + dx[i]; int ny = y + dy[i]; if (nx &lt; 0 or nx &gt;= n or ny &lt; 0 or ny &gt;= m) continue; if (a[nx][ny] == '.' or vis[nx][ny]) continue; q.push({nx, ny}), vis[nx][ny] = 1; } } ans[2] += cnt / 13, cnt %= 13; ans[1] += cnt / 8, cnt %= 8; ans[0] += cnt / 3; }; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { if (vis[i][j]) continue; if (a[i][j] == '.') continue; bfs(i, j); } } for (auto x : ans) cout &lt;&lt; x &lt;&lt; ' ';}signed main() { // sfor (int T = read(); T--; solve()); solve(); return 0;} B原题 2024 河北省赛 - J - Iris’ Food 赛时糖丸了，写矩阵快速幂去了，赛后发现直接 $\\frac{10^x - 1}{9}$ 就行了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using i64 = long long;#define int i64#define pb push_back#define ep emplace#define eb emplace_backusing std::max, std::min, std::swap;using std::cin, std::cout, std::string, std::vector;int read(int x = 0, int f = 0, char ch = getchar()) { while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}template &lt;class T&gt;constexpr T power(T a, i64 b) { T res {1}; for (; b; b /= 2, a *= a) if (b % 2) res *= a; return res; }constexpr i64 mul(i64 a, i64 b, i64 p) { i64 res = a * b - (i64)(1.L * a * b / p) * p; res %= p; if (res &lt; 0) res += p; return res; }template &lt;i64 P&gt;struct MInt { i64 x; constexpr MInt() : x {0} {} constexpr MInt(i64 x) : x {norm(x % getMod())} {} static i64 Mod; constexpr static i64 getMod() { return P &gt; 0 ? P : Mod; } constexpr static void setMod(i64 Mod_) { Mod = Mod_; } constexpr i64 norm(i64 x) const { if (x &lt; 0) x += getMod(); if (x &gt;= getMod()) x -= getMod(); return x; } constexpr i64 val() const { return x; } constexpr MInt operator-() const { MInt res; res.x = norm(getMod() - x); return res; } constexpr MInt inv() const { return power(*this, getMod() - 2); } constexpr MInt &amp;operator*=(MInt rhs) &amp; { if (getMod() &lt; (1ULL &lt;&lt; 31)) x = x * rhs.x % int(getMod()); else x = mul(x, rhs.x, getMod()); return *this; } constexpr MInt &amp;operator+=(MInt rhs) &amp; { x = norm(x + rhs.x); return *this; } constexpr MInt &amp;operator-=(MInt rhs) &amp; { x = norm(x - rhs.x); return *this; } constexpr MInt &amp;operator/=(MInt rhs) &amp; { return *this *= rhs.inv(); } friend constexpr MInt operator*(MInt lhs, MInt rhs) { MInt res = lhs; res *= rhs; return res; } friend constexpr MInt operator+(MInt lhs, MInt rhs) { MInt res = lhs; res += rhs; return res; } friend constexpr MInt operator-(MInt lhs, MInt rhs) { MInt res = lhs; res -= rhs; return res; } friend constexpr MInt operator/(MInt lhs, MInt rhs) { MInt res = lhs; res /= rhs; return res; } friend constexpr std::istream &amp;operator&gt;&gt;(std::istream &amp;is, MInt &amp;a) { i64 v; is &gt;&gt; v; a = MInt(v); return is; } friend constexpr std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const MInt &amp;a) { return os &lt;&lt; a.val(); } friend constexpr bool operator==(MInt lhs, MInt rhs) { return lhs.val() == rhs.val(); } friend constexpr bool operator!=(MInt lhs, MInt rhs) { return lhs.val() != rhs.val(); } friend constexpr bool operator&lt;(MInt lhs, MInt rhs) { return lhs.val() &lt; rhs.val(); }};template &lt;&gt;i64 MInt&lt;0&gt;::Mod = 1e9 + 7;constexpr int P = 1e9 + 7;using Z = MInt&lt;P&gt;;const Z inv9 = Z(9).inv();void solve() { int m = read(); int a[10]; for (int i = 0; i &lt; 10; i++) a[i] = read(); if (m == 1 and a[0] &gt; 0) { puts(&quot;0&quot;); return; } Z ans = 0; for (int i = 1; i &lt; 10; i++) { if (a[i] &gt; 0) { ans += Z(i) * power(Z(10), m - 1); a[i]--, m--; break; } } for (int i = 0; i &lt; 10; i++) { int t = min(a[i], m); ans += Z(i) * power(Z(10), m - t) * (power(Z(10), t) - 1) * inv9; m -= t; } cout &lt;&lt; ans &lt;&lt; '\\n';} signed main() { for (int T = read(); T--; solve()); // solve(); return 0;} C2024 东北省赛 - K - Tasks 按 $b_i$ 分层。限制只有来自同一层的限制，和来自上一层的限制。 对于同一层的 $i, j$ 来说，若 $l_i &lt; l_j$，则 $r_i &lt; r_j$。 对于一个 $l_i$，找到上一层最大的满足 $l_j \\le l_i$ 的 $j$。如果 $l_j = l_i$，那么 $r_i &lt; r_j$，否则 $r_i \\le r_j$ 故不妨从 $l_i$ 最靠后的任务开始确定 $r_i$，取到最右的可行位置。 这样可以使得下一层的任务可以选择的位置尽可能多。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using i64 = long long;#define int i64#define pb push_back#define ep emplace#define eb emplace_backusing std::max, std::min, std::swap;using std::cin, std::cout, std::string, std::vector;int read(int x = 0, int f = 0, char ch = getchar()) { while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}void solve() { int n = read(); vector&lt;vector&lt;std::pair&lt;int, int&gt;&gt;&gt; mp(n + 1); vector&lt;int&gt; r(n + 1); for (int i = 1; i &lt;= n; i++) { int l = read(), b = read(); mp[b].pb({l, i}); } #define fi first #define se second for (int i = 0; i &lt;= n; i++) { int R = 1e6 + 1; std::sort(mp[i].begin(), mp[i].end()); for (int j = 0; j + 1 &lt; mp[i].size(); j++) { if (mp[i][j].fi == mp[i][j + 1].fi) { puts(&quot;-1&quot;); return; } } for (int j = mp[i].size() - 1; j &gt;= 0; j--) { auto [l, id] = mp[i][j]; if (i) { auto it = std::upper_bound(mp[i - 1].begin(), mp[i - 1].end(), std::pair&lt;int, int&gt;(l, n)); if (it == mp[i - 1].begin()) { puts(&quot;-1&quot;); return; } it--; if (it -&gt; fi == l) { R = min(R, r[it -&gt; se]); } else { R = min(R, r[it -&gt; se] + 1); } } r[id] = --R; if (l &gt; r[id]) { puts(&quot;-1&quot;); return; } } } for (int i = 1; i &lt;= n; i++) { cout &lt;&lt; r[i] &lt;&lt; '\\n'; }}signed main() { // for (int T = read(); T--; solve()); solve(); return 0;} D 2-sat原题 2024 河北省赛 - F - 3 Split","link":"/2024-ccpc-%E7%BD%91%E7%BB%9C%E9%A2%84%E9%80%89%E8%B5%9B-%E7%83%AD%E8%BA%AB%E8%B5%9B/"},{"title":"VP 2023 GDCPC","text":"比赛链接 和队友 VP 2023 广东省大学生程序设计竞赛 Problems AC A. Programming Contest ○ B. Base Station Construction ⊕ C. Trading ○ D. New Houses ○ E. New but Nostalgic Problem ⊕ F. Traveling in Cells ⊕ G. Swapping Operation H. Canvas I. Path Planning ○ J. X Equals Y K. Peg Solitaire ○ L. Classic Problem M. Computational Geometry Overview 阶段一（基本编程技巧）：A（枚举）、C（循环）、K（搜索）、I（二分）。 阶段二（常见算法应用）：D（贪心）、M（几何）、B（单调队列）、E（字典树）、F（线段树）。 阶段三（思维能力测试）：J（数学）、H（建图）、G（思维）、L（图论）。 B $n$ 个点排成一行，选择每个点都有一个代价。给 $m$ 个区间，要求每个区间里至少选一个点，求最小总代价。 维护 f[i] 表示只考虑前 i 个点，且第 $i$ 个点必选的最小总花费。枚举上一个选的点 $j$，得到 dp 方程 $f(i) = \\min_{j} f(j) + a_i$。因为每个区间至少选一个点，因此 $[j + 1, i - 1]$ 不能存在一个完整的区间 对于每个 $1 \\le i \\le n$，维护一个 $p_i$ 表示能转移到 $i$ 的最小合法 $j$。 $$p_i = \\max_{r_j &lt; i}{l_j}$$ 这个 $p_i$ 是可以双指针的 Code CCode DCode ECode FCode ICode KCode M 将一个凸多边形沿着两个顶点的连线分成两块，最小化两个小多边形直径平方的和。$4 \\le n \\le 5e3$ 第一眼以为是计算几何，赛后发现并不是。 枚举用于切开大多边形的顶点 i 和 j，问题变为如何快速计算两个小多边形的直径。显然两个小多边形也都是凸多边形。 凸多边形的直径一定是某两个顶点的连线，维护 $f(i, j)$ 表示第 $i$ 个顶点到第 $j$ 个顶点之间，两个顶点之间的最大距离的平方（如果 $i &gt; j$ 那就是顶点 $i, i + 1, \\ldots, n, 1, 2, \\ldots, j$之间的最大距离）。 令 dis(i, j) 表示顶点 i 和 j 之间的距离，容易得到区间 dp 方程 $f_{i, j}=\\max \\left{f_{i+1, j}, f_{i, j-1}, \\operatorname{dis}^2\\left(P_i, P_j\\right)\\right}$ Code","link":"/vp-2023-gdcpc/"},{"title":"VP 2023 ICPC 澳门","text":"The 2023 ICPC Asia Macau Regional Contest (The 2nd Universal Cup. Stage 15: Macau) Problems AC Note A. (-1,1)-Sumplete ⊕ 构造 B. Basic Equation Solving 不可做 C. Bladestorm 不可做 D. Graph of Maximum Degree 3 ⊕ 观察性质 E. Inverse Topological Sort ⊕ 构造、拓扑排序 F. Land Trade 不可做 G. Parity Game 不可做 H. Random Tree Parking ⊕ 树形背包、排列组合、随机生成数据 I. Refresher into Midas ○ J. Teleportation ○ 分层图、构造 K. Understand 不可做 A. (-1,1)-Sumplete$-1$ 都选上，其他的都不选。 这样的话问题就变成了 $n ^ 2$ 个格子，每个格子初始都是 $0$，可以选择变成 $1$。 贪心就做完了。 测了下 $O(n^2)$ 的桶排 没 $O(n^2 \\log n)$ 的堆排跑得快。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081void solve() { int n; cin &gt;&gt; n; vector a(n, vector&lt;int&gt;(n)); vector b(n, vector&lt;int&gt;(n)); for (int i = 0; i &lt; n; i++) { string s; cin &gt;&gt; s; for (int j = 0; j &lt; n; j++) { if (s[j] == '-') { b[i][j] = 1; a[i][j] = -1; } else { b[i][j] = 0; a[i][j] = 1; } } } vector&lt;int&gt; row(n); for (int &amp;x : row) cin &gt;&gt; x; vector&lt;int&gt; col(n); for (int &amp;x : col) cin &gt;&gt; x; for (int i = 0; i &lt; n; i++) { // cerr &lt;&lt; a[i] &lt;&lt; '\\n'; for (int j = 0; j &lt; n; j++) { row[i] += (a[i][j] == -1); } } for (int j = 0; j &lt; n; j++) { for (int i = 0; i &lt; n; i++) { col[j] += (a[i][j] == -1); } } // cerr &lt;&lt; &quot;---------\\n&quot;; // cerr &lt;&lt; row &lt;&lt; '\\n'; // cerr &lt;&lt; col &lt;&lt; '\\n'; // cerr &lt;&lt; &quot;---------\\n&quot;; std::priority_queue&lt;Node&gt; q; for (int j = 0; j &lt; n; j++) { if (col[j]) { q.ep(j, col[j]); } } for (int i = 0; i &lt; n; i++) { vector&lt;int&gt; t; while (!q.empty() and row[i] &gt; 0) { auto [j, _] = q.top(); q.pop(); b[i][j] ^= 1; row[i]--; col[j]--; if (col[j]) t.eb(j); } for (auto j : t) { q.ep(j, col[j]); } } for (int j = 0; j &lt; n; j++) { if (row[j] != 0 or col[j] != 0) { cout &lt;&lt; &quot;No\\n&quot;; return; } } cout &lt;&lt; &quot;Yes\\n&quot;; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { cout &lt;&lt; b[i][j]; } cout &lt;&lt; &quot;\\n&quot;; }} D. Graph of Maximum Degree 3 Bobo 最近得到了一个(无向)图 $G=(V, E)$ 。他注意到这个图的每条边都是红色或蓝色，并且这个图的最大度不大于 $3$ 。 现在，Bobo 想知道 $G$ 中有多少个非空诱导子图 $G[S]=(S, E’)$ ，使得满足以下两个条件： 仅保留 $G[S]$ 的红色边形成的图是连通的。 仅保留 $G[S]$ 的蓝色边形成的图也是连通的。 由于答案可能太大，您需要输出结果模数 $998\\,244\\,353$ (一个素数)。 被诈骗了，一看 $998244353$ 以为是很难的题。 由 $\\frac{3m}{2} \\ge 2(m - 1)$ 得 $m \\le 4$。 枚举联通块数数就做完了。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970void solve() { int n = read(); int m = read(); vector&lt;vector&lt;int&gt;&gt; g(n + 1); std::set&lt;pii&gt; s; for (int i = 1; i &lt;= m; i++) { int u = read(); int v = read(); int c = read(); if (u &gt; v) swap(u, v); if (c) { g[u].eb(v), g[v].eb(u); } else { s.ep(u, v); } } vector&lt;int&gt; path; auto check = [&amp;]() { int m = path.size(); DSU dsu(m); for (int i = 0; i &lt; m; i++) { for (int j = i + 1; j &lt; m; j++) { int u = path[i]; int v = path[j]; if (u &gt; v) swap(u, v); if (s.find({u, v}) == s.end()) continue; dsu.merge(i, j); } } for (int i = 1; i &lt; m; i++) { if (!dsu.same(0, i)) { return 0; } } return 1; }; int ans = 0; vector&lt;int&gt; vis(n + 1); auto dfs = [&amp;](this auto&amp;&amp; self, int u, int p) -&gt; void { vis[u] = 1; path.eb(u); if (p &gt; 1) ans += check(); if (p &lt; 4) { for (int v : g[u]) { if (vis[v]) continue; self(v, p + 1); } } vis[u] = 0; path.pop_back(); }; for (int i = 1; i &lt;= n; i++) { dfs(i, 1); } cout &lt;&lt; ans / 2 + n; } E. Inverse Topological Sort 对于一个有向无环图(DAG) $G=(V,E)$ ，有 $|V|=n$ 个顶点，编号从 $1$ 到 $n$ 给定两个序列 $A=(a _ 1,a _ 2,\\dots,a _ n)$ 和 $B=(b _ 1,b _ 2,\\dots,b _ n)$ ，其中 $A$ 是 $G$ 的字典序最小拓扑序，而 $B$ 是 $G$ 的字典序最大拓扑序，构造原图 $G=(V,E)$ $1\\leq n\\leq 10^5$ 假设一张图只有点没有边，那么最小就是 $1,2,3,\\cdots,n$，最大就是 $n, n - 1, \\cdots, 1$。 假如在这张图上连了条边 $2 \\rightarrow 1$，那么最小就变成了 $2,1,3,\\cdots,n$。 因此 $A$ 中的逆序对应当在原图上有边，$B$ 中的顺序对同理。 但是这样是 $O(n^2)$ 条边。 发现边是有传递性的，每个 $A_i$ 只需要向后面最近的一个逆序数连边，这样即可满足限制。 无解的情况只有构造出来的图不是 DAG 或者 最小最大拓扑序和 $A$ $B$ 不同。 Code >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798void solve() { int n; cin &gt;&gt; n; vector&lt;int&gt; a(n), b(n); for (int &amp;x : a) cin &gt;&gt; x, x--; for (int &amp;x : b) cin &gt;&gt; x, x--; vector&lt;vector&lt;int&gt;&gt; g(n); vector&lt;int&gt; stk; for (int i = 0; i &lt; n; i++) { while (not stk.empty() and stk.back() &lt; a[i]) stk.pop_back(); if (not stk.empty()) g[stk.back()].eb(a[i]); stk.eb(a[i]); } stk.clear(); for (int i = 0; i &lt; n; i++) { while (not stk.empty() and stk.back() &gt; b[i]) stk.pop_back(); if (not stk.empty()) g[stk.back()].eb(b[i]); stk.eb(b[i]); } // for (int i = 0; i &lt; n; i++) { // cerr &lt;&lt; i &lt;&lt; ' ' &lt;&lt; g[i] &lt;&lt; '\\n'; // } std::priority_queue&lt;int&gt; q; vector&lt;int&gt; ind(n); vector&lt;int&gt; A; for (int i = 0; i &lt; n; i++) { std::sort(g[i].begin(), g[i].end()); for (int j : g[i]) { // cout &lt;&lt; i + 1 &lt;&lt; ' ' &lt;&lt; j + 1 &lt;&lt; '\\n'; ind[j]++; } } for (int i = 0; i &lt; n; i++) { if (!ind[i]) { q.ep(-i); // cerr &lt;&lt; &quot;inque: &quot; &lt;&lt; i + 1 &lt;&lt; '\\n'; } } while (!q.empty()) { int u = -q.top(); q.pop(); A.eb(u); // cerr &lt;&lt; &quot;deque: &quot; &lt;&lt; u + 1 &lt;&lt; '\\n'; for (int v : g[u]) { if (!--ind[v]) { q.ep(-v); // cerr &lt;&lt; &quot;inque: &quot; &lt;&lt; v + 1 &lt;&lt; '\\n'; } } } ind.assign(n, 0); vector&lt;int&gt; B; for (int i = 0; i &lt; n; i++) { std::sort(g[i].rbegin(), g[i].rend()); for (int j : g[i]) { ind[j]++; } } for (int i = n - 1; ~i; i--) { if (!ind[i]) { q.ep(i); } } while (!q.empty()) { int u = q.top(); q.pop(); B.eb(u); for (int v : g[u]) { if (!--ind[v]) { q.ep(v); } } } // cerr &lt;&lt; A &lt;&lt; '\\n'; // cerr &lt;&lt; B &lt;&lt; '\\n'; if (a != A or b != B) { cout &lt;&lt; &quot;No\\n&quot;; return; } cout &lt;&lt; &quot;Yes\\n&quot;; vector&lt;pii&gt; ans; for (int i = 0; i &lt; n; i++) { for (int j : g[i]) { ans.eb(i + 1, j + 1); } } cout &lt;&lt; ans.size() &lt;&lt; '\\n'; for (auto [u, v] : ans) cout &lt;&lt; u &lt;&lt; ' ' &lt;&lt; v &lt;&lt; '\\n';} H. Random Tree Parking 考虑一个停车场，其形式为树 $T$ ，标签为 $[n]=\\{1,2,\\dots,n\\}$ ，根节点为 $1$ 。树的边朝向根顶点。我们有一系列 $n$ 司机，每个司机都有自己喜欢的停车位，这是树中的一个顶点。司机一个接一个地到达，每个司机 $i$ $(1 \\leq i \\leq n)$ 都试图停在他们喜欢的停车位 $s _ i\\in [n]$ 。如果停车位是空的，他们就停在那里。否则，他们沿着边向根顶点行驶，停在遇到的第一个空顶点。如果没有空顶点，他们就会离开停车场，即树，而无需停车。 如果所有司机都成功，即所有司机都能找到停车位，那么顶点序列 $\\mathbf{s} \\in [n]^n$ 就被称为树 $T$ 的停车函数。 现在，给定一棵有 $n$ 个顶点的树 $T$ ，Bobo 想知道 $T$ 的停车函数数量是多少。由于 Bobo 也痴迷于随机性，他决定树 $T$ 应该按以下方式随机生成： 对于 $i=2,\\dots,n$ ，顶点 $i$ 指向的点是从 $\\{1,2,\\dots,i-1\\}$ 中独立均匀随机选择的。 由于答案可能太大，您应该输出答案模数 $998\\,244\\,353$ (一个素数)。 $2\\leq n\\leq 10^5$ 对于 $u$ 的子树，可以选择的点的数量是 $[siz_u, siz_u + dep_i]$。最少的情况是每个点恰好选一次，一共 $siz_u$ 次，才可以填满子树。那么填满之后还可以任选最多 $dep_u$ 次，可以往上填到根。 那么可以做一个树形背包，把 $u$ 的每个儿子 $v$ 合并到 $u$ 上面，一路往上合并。转移的时候枚举选了多少个，然后乘上一个排列的系数（因为位置可以交换）。 由于数据的随机生成方式，树高是期望 $\\log$ 的，所以复杂度是 $O(n \\log n)$。 Code123456789101112131415161718192021222324252627282930313233343536void solve() { int n; cin &gt;&gt; n; vector&lt;int&gt; dep(n + 1); dep[1] = 1; vector&lt;vector&lt;int&gt;&gt; g(n + 1); for (int i = 2; i &lt;= n; i++) { int x; cin &gt;&gt; x; dep[i] = dep[x] + 1; g[x].eb(i); } vector&lt;int&gt; siz(n + 1); vector&lt;vector&lt;Z&gt;&gt; dp(n + 1); for (int u = n; u; u--) { dp[u].assign(dep[u] + 1, 1); for (int v : g[u]) { vector&lt;Z&gt; ndp(dep[u] + 1); for (int i = 0; i &lt;= dep[u]; i++) { for (int j = 0; i + j &lt;= dep[u]; j++) { ndp[i + j] += dp[u][i] * dp[v][j] * comb.binom(siz[u] + siz[v] + i + j, siz[u] + i); } } dp[u] = std::move(ndp); siz[u] += siz[v]; } siz[u]++; for (int i = 0; i &lt; dep[u]; i++) { dp[u][i] = dp[u][i + 1]; } } cout &lt;&lt; dp[1][0];} I. Refresher into Midas队友秒了。 J. Teleportation（并不）容易想到，操作过 操作一 之后，可以在任意时刻直接从 $u$ 走向 $u + 1$，代价为 $1$。 所以建两层图就做完了。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243void solve() { int n = read(); int T = read(); int nod = 2 * n; vector&lt;int&gt; a(nod); for (int i = 0; i &lt; n; i++) { a[i] = read(); a[i + n] = a[i]; } vector&lt;int&gt; vis(nod); vector&lt;int&gt; dis(nod, inf); std::priority_queue&lt;Node&gt; q; dis[0] = 0; q.ep(0, 0); auto relax = [&amp;](int u, int v, int dist) { if (dis[v] &gt; dis[u] + dist) { dis[v] = dis[u] + dist; if (!vis[v]) q.ep(v, dis[v]); } }; while (!q.empty()) { auto [u, _] = q.top(); q.pop(); if (vis[u]) continue; vis[u] = 1; if (u &lt; n) { relax(u, (u + a[u]) % n, 1); relax(u, n + (u + a[u] + 1) % n, 2); } else { relax(u, n + (u + a[u]) % n, 1); relax(u, n + (u + 1) % n, 1); } } cout &lt;&lt; min(dis[T], dis[T + n]);}","link":"/vp-2023-icpc-%E6%BE%B3%E9%97%A8/"},{"title":"VP 2022 ICPC 沈阳","text":"The 2022 ICPC Asia Shenyang Regional Contest (The 1st Universal Cup, Stage 1: Shenyang) 这个题解怎么和 Claris 一个 slides 板子，给我看 ptsd 了（ Problems AC A. Absolute Difference 待补 B. Binary Substrings C. Clamped Sequence ○ D. DRX vs. T1 ○ E. Graph Completing ⊕ F. Half Mixed ⊕ G. Meet in the Middle 待补 H. P-P-Palindrome 待补 I. Quartz Collection ⊕ J. Referee Without Red K. Security at Museums L. Tavern Chess ○ M. Vulpecula D 签到1234567891011121314151617181920212223242526void solve() { string s; cin &gt;&gt; s; int x = 0; int y = 0; for (auto ch : s) { if (ch == 'D') { x++; } if (ch == 'T') { y++; } if (x &gt; 2 or y &gt; 2) { break; } } if (x &gt; 2) { puts(&quot;DRX&quot;); } else { puts(&quot;T1&quot;); }} C赛时秒出思路但是吃了发罚时，队友提醒了下发现 a[i] 作为上下界都可以，但是忘了枚举其中一种情况。 1234567891011121314151617181920212223242526272829303132333435363738394041424344void solve() { int n = read(), d = read(); int ans = 0; vector&lt;int&gt; a(n + 1); for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; } for (int i = 1; i &lt;= n; i++) { int L = a[i], R = a[i] + d; int res = 0; for (int j = 1; j &lt; n; j++) { int x = a[j]; int y = a[j + 1]; x = max(x, L); x = min(x, R); y = max(y, L); y = min(y, R); res += abs(x - y); } ans = max(ans, res); } for (int i = 1; i &lt;= n; i++) { int L = a[i] - d, R = a[i]; int res = 0; for (int j = 1; j &lt; n; j++) { int x = a[j]; int y = a[j + 1]; x = max(x, L); x = min(x, R); y = max(y, L); y = min(y, R); res += abs(x - y); } ans = max(ans, res); } cout &lt;&lt; ans &lt;&lt; '\\n';} L炉管题，队友做了。 F 贪心，构造太神必了这题。 子矩形数量是 $\\frac{n(n + 1)}{2} \\times \\frac{m(m + 1)}{2}$，如果这个数量是奇数则显然无解。否则 $\\frac{n(n + 1)}{2}$ 和 $\\frac{m(m + 1)}{2}$ 至少有一个是偶数。不妨设后者是偶数。 赛时打表发现可以将问题转化到一维上去，然后堆叠起来。也就是解决 $1 \\times m$ 的问题然后堆叠 $n$ 行。 对于一个 $1 \\times m$ 的矩形，子矩形数量是 $\\frac{m(m + 1)}{2}$，设每一个同色区间的长度是 $a_i$。那么纯色子区间数量就是 $\\sum_{i = 1}^k{\\frac{a_i(a_i + 1)}{2}}$，则问题转化为解下列方程组： $\\sum_{i = 1}^{k} a_i = m$ $\\sum_{i = 1}^k{\\frac{a_i(a_i + 1)}{2}} = \\frac{m(m + 1)}{4}$ 不难证明一定存在一组解，构造时贪心让每个 $a_i$ 尽可能大即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970void solve() { int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; a(n, 1); int h = 0, t = n - 1; int tar = n * (n - 1) / 2; int val = n; while (h &lt; t and val &lt; tar) { int nval = val - a[h] * a[h] + (a[h] + 1) * (a[h] + 1) - 1; if (val &lt; nval and nval &lt;= tar) { val = nval; a[h] += 1; t--; } else { h++; } } if (val == tar) { puts(&quot;Yes&quot;); for (int i = 0, k = 0; i &lt;= t; i++, k ^= 1) { for (int rj = 1; rj &lt;= a[i]; rj++) { for (int j = 1; j &lt;= m; j++) { cout &lt;&lt; k &lt;&lt; &quot; \\n&quot;[j == m]; } } } return; } std::swap(n, m); a.assign(n, 1); h = 0, t = n - 1; tar = n * (n - 1) / 2; val = n; while (h &lt;= t and val &lt; tar) { int nval = val - a[h] * a[h] + (a[h] + 1) * (a[h] + 1) - 1; if (val &lt; nval and nval &lt;= tar) { val = nval; a[h]++; t--; } else { h++; } } std::swap(n, m); if (val == tar) { puts(&quot;Yes&quot;); for (int i = 1; i &lt;= n; i++) { for (int j = 0, k = 0; j &lt;= t; j++, k ^= 1) { for (int rj = 1; rj &lt;= a[j]; rj++) { cout &lt;&lt; k &lt;&lt; &quot; \\n&quot;[j == t and rj == a[j]]; } } } return; } puts(&quot;No&quot;);} I 贪心、线段树总的和是固定的，可以将游戏看作每块石头价值 $b_i$，但是先选的话就有 $a_i - b_i$ 的收益，后选的话收益为 $0$。 因此实际上双方就是按照 $a_i - b_i$ 从小到大分别选。A 拿第 0 个，B 拿第 1, 2 个，A 拿第 3, 4 个，以此类推，A 会拿 rank % 4 = 0 或 3 的。 因此维护一个权值线段树，下标是 $a_i - b_i$，维护区间内排名 % 4 相同的数的和即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768struct SGT { int cnt[N &lt;&lt; 2]; int sum[N &lt;&lt; 2][4]; #define ls (p &lt;&lt; 1) #define rs (p &lt;&lt; 1 | 1) #define mid (l + r &gt;&gt; 1) void pushup(int p) { cnt[p] = cnt[ls] + cnt[rs]; sum[p][0] = sum[p][1] = sum[p][2] = sum[p][3] = 0; for (int i = 0; i &lt; 4; i++) { sum[p][i] += sum[ls][i]; sum[p][(cnt[ls] + i) % 4] += sum[rs][i]; } } void upd(int p, int l, int r, int pos, int val) { if (l == r) { if (val &gt; 0) sum[p][cnt[p] % 4] += pos; else sum[p][(cnt[p] - 1) % 4] -= pos; cnt[p] += val; return; } if (pos &lt;= mid) upd(ls, l, mid, pos, val); else upd(rs, mid + 1, r, pos, val); pushup(p); } void upd(int pos, int val) { upd(1, -1e5, 1e5, pos, val); } int qry(int p = 1) { int res = sum[ls][0] + sum[ls][3]; if (cnt[ls] * 2 % 4 == 0) { res += sum[rs][0] + sum[rs][2]; } else { res += sum[rs][1] + sum[rs][3]; } return res; }} seg;void solve() { int n = read(), m = read(); int sumb = 0; vector&lt;int&gt; a(n + 1), b(n + 1); for (int i = 1; i &lt;= n; i++) { a[i] = read(), b[i] = read(); seg.upd(a[i] - b[i], 1); sumb += b[i]; } cout &lt;&lt; sumb + seg.qry() &lt;&lt; '\\n'; for (int i = 1; i &lt;= m; i++) { int t = read(), x = read(), y = read(); sumb -= b[t], sumb += y; seg.upd(a[t] - b[t], -1); a[t] = x, b[t] = y; seg.upd(a[t] - b[t], 1); cout &lt;&lt; sumb + seg.qry() &lt;&lt; '\\n'; }} A Calculus \\begin{aligned}&amp; \\int_l^r \\int_l^r |x-y| \\mathrm{d} x \\mathrm{d} y\\\\&amp;= \\int_0^{r-l} \\int_0^{r-l} |(x + l)-(y + l)| \\mathrm{d} x \\mathrm{d} y\\\\&amp;= \\int_0^{r-l} \\int_0^{r-l} |x-y| \\mathrm{d} x \\mathrm{d} y\\\\&amp;= \\int_0^{r-l} \\left(\\int_0^{x} (x - y) + \\int_x^{r-l} (y - x) \\right) \\mathrm{d} x \\mathrm{d} y\\\\&amp;= \\int_0^{r-l} \\left(\\int_0^{x}x - \\int_0^{x}y + \\int_x^{r-l}y - \\int_x^{r-l}x \\right) \\mathrm{d} x \\mathrm{d} y\\\\&amp;= \\int_0^{r-l} \\left(\\int_0^{x}x - \\int_x^{r-l}x - \\int_0^{x}y + \\int_x^{r-l}y \\right) \\mathrm{d} x \\mathrm{d} y\\\\&amp;= \\int_0^{r-l} \\left(x^2 - x(r - l - x) + \\frac{1}{2} (r-l)^2 - x^2 \\right) \\mathrm{d} x\\\\&amp;= \\int_0^{r-l} \\left( x^2 - x(r - l) + \\frac{1}{2} (r-l)^2\\right) \\mathrm{d} x\\\\&amp;= \\frac{(r-l)^3}{3}\\\\\\end{aligned} E 边双、容斥、TreeDP 给定一个 $n$ 个点 $m$ 条边的简单无向图，可以加入任意多条（包括 $0$ 条）边，使得这张图边双联通，求加边的方案数。 边双联通的定义：任意不同的两点存在至少两条没有重复边的简单路径。 对原图进行边双缩点，由于原图是连通的，缩点之后会得到一棵树。此时每加一条边 $(u, v)$ 就会对树上 $u$ 到 $v$ 的树上路径进行覆盖，当所有树边都被覆盖时就得到了一个边双连通图。 现在问题转化为：加若干条边，使得这棵树的每条树边都被新加的非树边覆盖至少一次。求方案数。 这个方案数不好求，考虑容斥：设至少有 $k$ 条边没被覆盖的方案数为 $g_k$，则答案为 $\\sum_{k}(-1)^{k}g_k$。 把这个容斥扔到树上做 TreeDP。如果一些边被钦定了没被覆盖，那么这些边会把原树划分成若干连通块，连通块内任意连边。 设 $dp_{u, i}$ 表示以 $u$ 为根的子树的连通块大小为 $i$ 时子树内的方案数。转移时考虑一个子树 $v$ 是否连上来（即边 $(u, v)$ 是否被覆盖）。如果连上来的话就是乘上一个 $2^{siz_u + siz_v - 1}$ 的系数（减去的 1 是那条已经有的树边，除此之外的边都可以覆盖这条边），没连上来的话就是容斥系数 $-1$。 注意每个子树根节点的初值应设为 $dp_{u, siz_u} = 2^{\\frac{siz_u(siz_u - 1)}{2} - cnte_u}$，其中 $cnte_u$ 表示边双连通分量中的边数。 注意要写个光速幂，这样转移的时候可以少个快速幂的 log。 另，用的是哥哥的 EBCC 板子，发现那个板子算 cnte 好像是有问题的，debug 了半天。。。。而且看了眼哥哥的代码，写的有点过于神秘了，看不懂。。。。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#include &lt;bits/stdc++.h&gt;using i64 = long long;#define int i64using std::cerr;using std::cin, std::cout, std::string, std::vector;int read(int x = 0, int f = 0, char ch = getchar()) { while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}using pii = std::pair&lt;int, int&gt;;struct EBCC { int n, cur, cnt; vector&lt;vector&lt;int&gt;&gt; adj; vector&lt;int&gt; stk, dfn, low, bel; EBCC() {} EBCC(int n) { init(n); } void init(int n) { this-&gt;n = n; adj.assign(n, {}), dfn.assign(n, -1); low.resize(n), bel.assign(n, -1); stk.clear(), cur = cnt = 0; } void addEdge(int u, int v) { adj[u].push_back(v), adj[v].push_back(u); } void dfs(int x, int p) { dfn[x] = low[x] = cur++, stk.push_back(x); for (auto y : adj[x]) { if (y == p) continue; if (dfn[y] == -1) dfs(y, x), low[x] = std::min(low[x], low[y]); else if (bel[y] == -1) low[x] = std::min(low[x], dfn[y]); } if (dfn[x] == low[x]) { int y; do { y = stk.back(), bel[y] = cnt, stk.pop_back(); } while (y != x); cnt++; } } std::vector&lt;int&gt; work() { return dfs(0, -1), bel; } struct Graph { int n; vector&lt;pii&gt; edges; vector&lt;int&gt; siz, cnte; }; Graph compress() { Graph g; g.n = cnt; g.siz.resize(cnt), g.cnte.resize(cnt); for (int i = 0; i &lt; n; i++) { g.siz[bel[i]]++; for (auto j : adj[i]) { if (bel[i] &lt; bel[j]) g.edges.emplace_back(bel[i], bel[j]); else if (i &lt; j and bel[i] == bel[j]) g.cnte[bel[i]]++; } } return g; }};template &lt;class T&gt;constexpr T power(T a, i64 b) { T res {1}; for (; b; b /= 2, a *= a) if (b % 2) res *= a; return res; }constexpr i64 mul(i64 a, i64 b, i64 p) { i64 res = a * b - (i64)(1.L * a * b / p) * p; res %= p; if (res &lt; 0) res += p; return res; }template &lt;i64 P&gt;struct MInt { i64 x; constexpr MInt() : x {0} {} constexpr MInt(i64 x) : x {norm(x % getMod())} {} static i64 Mod; constexpr static i64 getMod() { return P &gt; 0 ? P : Mod; } constexpr static void setMod(i64 Mod_) { Mod = Mod_; } constexpr i64 norm(i64 x) const { if (x &lt; 0) x += getMod(); if (x &gt;= getMod()) x -= getMod(); return x; } constexpr i64 val() const { return x; } constexpr MInt operator-() const { MInt res; res.x = norm(getMod() - x); return res; } constexpr MInt inv() const { return power(*this, getMod() - 2); } constexpr MInt &amp;operator*=(MInt rhs) &amp; { if (getMod() &lt; (1ULL &lt;&lt; 31)) x = x * rhs.x % int(getMod()); else x = mul(x, rhs.x, getMod()); return *this; } constexpr MInt &amp;operator+=(MInt rhs) &amp; { x = norm(x + rhs.x); return *this; } constexpr MInt &amp;operator-=(MInt rhs) &amp; { x = norm(x - rhs.x); return *this; } constexpr MInt &amp;operator/=(MInt rhs) &amp; { return *this *= rhs.inv(); } friend constexpr MInt operator*(MInt lhs, MInt rhs) { MInt res = lhs; res *= rhs; return res; } friend constexpr MInt operator+(MInt lhs, MInt rhs) { MInt res = lhs; res += rhs; return res; } friend constexpr MInt operator-(MInt lhs, MInt rhs) { MInt res = lhs; res -= rhs; return res; } friend constexpr MInt operator/(MInt lhs, MInt rhs) { MInt res = lhs; res /= rhs; return res; } friend constexpr std::istream &amp;operator&gt;&gt;(std::istream &amp;is, MInt &amp;a) { i64 v; is &gt;&gt; v; a = MInt(v); return is; } friend constexpr std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const MInt &amp;a) { return os &lt;&lt; a.val(); } friend constexpr bool operator==(MInt lhs, MInt rhs) { return lhs.val() == rhs.val(); } friend constexpr bool operator!=(MInt lhs, MInt rhs) { return lhs.val() != rhs.val(); } friend constexpr bool operator&lt;(MInt lhs, MInt rhs) { return lhs.val() &lt; rhs.val(); }};template &lt;&gt;i64 MInt&lt;0&gt;::Mod = 998244353;constexpr int P = 998244353;using Z = MInt&lt;P&gt;;void solve() { int n = read(), m = read(); EBCC g(n); for (int i = 1; i &lt;= m; i++) { int u = read(), v = read(); u--, v--; g.addEdge(u, v); } g.work(); auto G = g.compress(); vector&lt;Z&gt; pw(n + 1), comp(n + 1); pw[0] = 1; for (int i = 1; i &lt;= n; i++) { pw[i] = pw[i - 1] * 2; } comp[0] = 1; for (int i = 1; i &lt;= n; i++) { comp[i] = comp[i - 1] * pw[n]; } int N = n; n = G.n; auto pow2 = [&amp;](int b) { return pw[b % N] * comp[b / N]; }; vector&lt;vector&lt;int&gt;&gt; adj(n); for (auto [x, y] : G.edges) { adj[x].push_back(y); adj[y].push_back(x); } vector dp(n, vector&lt;Z&gt;(N + 1)); vector&lt;int&gt; siz(n); std::function&lt;void(int, int)&gt; dfs = [&amp;](int u, int fa) { siz[u] = G.siz[u]; dp[u][siz[u]] = pow2(siz[u] * (siz[u] - 1) / 2 - G.cnte[u]); for (auto v : adj[u]) { if (v == fa) continue; dfs(v, u); vector&lt;Z&gt; ndp(N + 1); for (int i = 1; i &lt;= siz[u]; i++) { for (int j = 1; j &lt;= siz[v]; j++) { ndp[i + j] += dp[u][i] * dp[v][j] * pow2(i * j - 1); ndp[i] -= dp[u][i] * dp[v][j]; } } dp[u] = std::move(ndp); siz[u] += siz[v]; } }; dfs(0, -1); Z ans = 0; for (int i = 1; i &lt;= N; i++) { ans += dp[0][i]; } cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;}signed main() { solve(); return 0;}","link":"/vp-2022-icpc-%E6%B2%88%E9%98%B3/"},{"title":"VP 2023 SDCPC","text":"比赛链接 Problems AC A. Orders ○ B. Building Company ○ C. Trie D. Fast and Fat ○ E. Math Problem ○ F. Colorful Segments ⊕ G. Matching ○ H. Be Careful 2 I. Three Dice ○ J. Not Another Path Query Problem ⊕ K. Difficult Constructive Problem L. Puzzle: Sashigane ○ M. Computational Geometry ○ E 数学 给定 $n$ 和 $k$, 可以进行以下两种操作任意次： 选择一个整数 $x$ 满足 $0 \\leq x&lt;k$, 将 $n$ 变为 $k \\cdot n+x$ 。该操作每次花费 $a$ 枚金币。每次选择的整数 $x$ 可以不同。 将 $n$ 变为 $\\left\\lfloor\\frac{n}{k}\\right\\rfloor$ 。该操作每次花费 $b$ 枚金币。其中 $\\left\\lfloor\\frac{n}{k}\\right\\rfloor$ 表示小于等于 $\\frac{n}{k}$ 的最大整数。 给定正整数 $m$, 求将 $n$ 变为 $m$ 的倍数最少需要花费几枚金币。 一个道理是，一定是先除再乘。因为这里是整除，会把你先乘上去的东西除掉，就没有意义。 进行 $p$ 次乘法操作后，$n$ 的范围是 $[k^p \\times n, k^p \\times (n + 1) )$，只要这个范围里面包括 $m$ 的倍数即可停止乘法操作。因此乘法操作至多进行 $\\log_k m$ 次 除法操作类似，最多 $\\log_k n$ 次。 $O(\\log_k n \\times \\log_k m)$ 枚举即可 J 位运算类似于数位 dp 的思想，大于 $V$ 的数都与 $V$ 都有一段前缀与 $V$ 相同，我们枚举这个前缀的长度 $i$。 那么对于 $V$ 和 $V^{\\prime}$ 的前 $i$ 高位是相同的，则 $V$ 第 $i + 1$ 位上的情况只能是 $0$，$V^{\\prime}$ 则是 $1$。那么剩下的位都是可以任意选择的。 那么我们只要让这 $i + 1$ 个 $0$ 都出现，用 BFS 判断连通性即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;using i64 = long long;#define int i64#define pb push_back#define ep emplace#define eb emplace_backusing std::max, std::min, std::swap;using std::cin, std::cout, std::string, std::vector;i64 read(i64 x = 0, char ch = getchar()) { while (ch &lt; 48 or 57 &lt; ch) ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return x;}void solve() { int n = read(), m = read(), q = read(); int V = read(); using pii = std::pair&lt;int, int&gt;; #define fi first #define se second vector&lt;vector&lt;pii&gt;&gt; g(n + 1); while (m--) { int u = read(), v = read(); int w = read(); g[u].eb(v, w); g[v].eb(u, w); } vector&lt;int&gt; ans(q); vector&lt;pii&gt; qry(q); for (auto &amp;[x, y] : qry) { x = read(), y = read(); } auto check = [&amp;](int V) { int cnt = 0; vector&lt;int&gt; bel(n + 1); std::function&lt;void(int, int)&gt; bfs = [&amp;](int s, int V) { std::queue&lt;int&gt; q; q.push(s), bel[s] = ++cnt; while (!q.empty()) { int u = q.front(); q.pop(); for (auto [v, dis] : g[u]) { if (bel[v] or (dis &amp; V) != V) continue; bel[v] = bel[u]; q.push(v); } } }; for (int i = 1; i &lt;= n; i++) { if (!bel[i]) { bfs(i, V); } } for (int i = 0; i &lt; q; i++) { auto &amp;[x, y] = qry[i]; ans[i] |= (bel[x] == bel[y]); } }; if (V == 0LL) { check(0); } else { for (int t = V; t &lt; (1LL &lt;&lt; 60); t += t &amp; (-t)) { check(t); } } for (auto x : ans) { puts(x ? &quot;Yes&quot; : &quot;No&quot;); }}signed main() { solve(); return 0;} F 线段树优化 DP 有 $n$ 条线段，第 $i$ 条线段的颜色为 $c_i$ $(0 \\le ci \\le 1)$。您需要选择若干条线段。如果选择的两条线段有重合，则这两条线段的颜色必须相同。求选择线段的不同方案数。 $1 \\le n \\le 10^5$ 这题其实和暑假给小朋友出的一个题形式类似，都是 dp 乘上一个 2 的幂次形式的。两个结合一下感觉还是很套路的。 官方题解上面介绍了一种常见的错误解法。在这种解法中，将线段按右端点排序，并单独考虑每条线段。状态的设置并不包括线段的颜色，所以在考虑第一条线段的时候，并不一定能从前面的状态转移，因为这条线段可能和之前的方案有冲突。 所以每次我们要同时考虑线段的颜色，设 $f(i, c)$ 表示前 $i$ 条线段中，$i$ 必选，且线段 $i$ 的颜色是 $c$ 的方案数。转移时，我们枚举上一条选的线段 $j$（必须颜色不同），则前 $i - 1$ 条线段中，左端点大于 $r_j$ 的线段都可以随便选，转移方程就是： $$f(i, c) = \\sum_{j = 0}^{p_i} f(j, 1 - c) \\times 2 ^ {g(i - 1, r_j + 1, c)}$$ 其中，对于每个 $i$，$p_i$ 可以一只 log 二分出来。 考虑维护 $g$，容易发现，每加入一条线段 $i$，会让一段前缀都乘上 2 （相当于可选择的线段多了一条）。 用线段树维护一下即可。更详细的题解详见官方题解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include &lt;bits/stdc++.h&gt;using i64 = long long;#define int i64#define pb push_back#define ep emplace#define eb emplace_backusing std::max, std::min, std::swap;using std::cin, std::cout, std::string, std::vector;i64 read(i64 x = 0, char ch = getchar()) { while (ch &lt; 48 or 57 &lt; ch) ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return x;}template &lt;class T&gt;constexpr T power(T a, i64 b) { T res {1}; for (; b; b /= 2, a *= a) if (b % 2) res *= a; return res; }constexpr i64 mul(i64 a, i64 b, i64 p) { i64 res = a * b - (i64)(1.L * a * b / p) * p; res %= p; if (res &lt; 0) res += p; return res; }template &lt;i64 P&gt;struct MInt { i64 x; constexpr MInt() : x {0} {} constexpr MInt(i64 x) : x {norm(x % getMod())} {} static i64 Mod; constexpr static i64 getMod() { return P &gt; 0 ? P : Mod; } constexpr static void setMod(i64 Mod_) { Mod = Mod_; } constexpr i64 norm(i64 x) const { if (x &lt; 0) x += getMod(); if (x &gt;= getMod()) x -= getMod(); return x; } constexpr i64 val() const { return x; } constexpr MInt operator-() const { MInt res; res.x = norm(getMod() - x); return res; } constexpr MInt inv() const { return power(*this, getMod() - 2); } constexpr MInt &amp;operator*=(MInt rhs) &amp; { if (getMod() &lt; (1ULL &lt;&lt; 31)) x = x * rhs.x % int(getMod()); else x = mul(x, rhs.x, getMod()); return *this; } constexpr MInt &amp;operator+=(MInt rhs) &amp; { x = norm(x + rhs.x); return *this; } constexpr MInt &amp;operator-=(MInt rhs) &amp; { x = norm(x - rhs.x); return *this; } constexpr MInt &amp;operator/=(MInt rhs) &amp; { return *this *= rhs.inv(); } friend constexpr MInt operator*(MInt lhs, MInt rhs) { MInt res = lhs; res *= rhs; return res; } friend constexpr MInt operator+(MInt lhs, MInt rhs) { MInt res = lhs; res += rhs; return res; } friend constexpr MInt operator-(MInt lhs, MInt rhs) { MInt res = lhs; res -= rhs; return res; } friend constexpr MInt operator/(MInt lhs, MInt rhs) { MInt res = lhs; res /= rhs; return res; } friend constexpr std::istream &amp;operator&gt;&gt;(std::istream &amp;is, MInt &amp;a) { i64 v; is &gt;&gt; v; a = MInt(v); return is; } friend constexpr std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const MInt &amp;a) { return os &lt;&lt; a.val(); } friend constexpr bool operator==(MInt lhs, MInt rhs) { return lhs.val() == rhs.val(); } friend constexpr bool operator!=(MInt lhs, MInt rhs) { return lhs.val() != rhs.val(); } friend constexpr bool operator&lt;(MInt lhs, MInt rhs) { return lhs.val() &lt; rhs.val(); }};template &lt;&gt;i64 MInt&lt;0&gt;::Mod = 998244353;constexpr int P = 998244353;using Z = MInt&lt;P&gt;;struct SGT { #define mid (l + r &gt;&gt; 1) #define ls (p &lt;&lt; 1) #define rs (p &lt;&lt; 1 | 1) vector&lt;Z&gt; sum, laz; SGT() {} SGT(int n) { init(n); } void init(int n) { int siz = 4 * n + 5; sum.resize(siz), laz.resize(siz); sum.assign(siz, 0), laz.assign(siz, 1); } void down(int p) { auto &amp;t = laz[p]; if (t == 1) return; sum[ls] *= t; sum[rs] *= t; laz[ls] *= t; laz[rs] *= t; t = 1; } void up(int p) { sum[p] = sum[ls] + sum[rs]; } void add(int p, int l, int r, int pos, Z val) { if (l == r) { sum[p] += val; } else { down(p); if (pos &lt;= mid) add(ls, l, mid, pos, val); else add(rs, mid + 1, r, pos, val); up(p); } } void mul2(int p, int l, int r, int pos) { if (r &lt;= pos) { sum[p] *= 2; laz[p] *= 2; } else { down(p); mul2(ls, l, mid, pos); if (mid &lt; pos) mul2(rs, mid + 1, r, pos); up(p); } } Z query(int p, int l, int r, int pos) { if (r &lt;= pos) { return sum[p]; } else { down(p); Z res = query(ls, l, mid, pos); if (mid &lt; pos) res += query(rs, mid + 1, r, pos); up(p); return res; } }};void solve() { int n = read(); vector&lt;std::array&lt;int, 3&gt;&gt; a(n + 1); for (int i = 1; i &lt;= n; i++) { for (auto &amp;x : a[i]) { x = read(); } } std::sort(a.begin() + 1, a.end(), [](auto a, auto b){ return a[1] &lt; b[1]; }); SGT t[2] {SGT(n), SGT(n)}; for (int k = 0; k &lt; 2; k++) { t[k].add(1, 0, n, 0, 1); } Z ans = 1; for (int i = 1; i &lt;= n; i++) { int p = 0; int &amp;c = a[i][2]; for (int l = 0, r = i - 1; l &lt;= r; ) { if (a[mid][1] &lt; a[i][0]) p = mid, l = mid + 1; else r = mid - 1; } Z val = t[c ^ 1].query(1, 0, n, p); t[c].add(1, 0, n, i, val); t[c ^ 1].mul2(1, 0, n, p); ans += val; } cout &lt;&lt; ans &lt;&lt; '\\n';}signed main() { for (int T = read(); T--; solve()); return 0;}","link":"/vp-2023-sdcpc/"},{"title":"VP 2024 CCPC 哈尔滨","text":"2024 China Collegiate Programming Contest (CCPC) Harbin Onsite (The 3rd Universal Cup. Stage 14: Harbin)比赛链接 Problems AC Note A. Build a Computer ⊕ 构造、拆数位 B. Concave Hull ⊕ 凹包 C. Giving Directions in Harbin ○ D. A Simple String Problem 字符串、后缀数组、不可做 E. Marble Race ⊕ 可撤销背包、多项式 F. 1D Galaxy 不可做 G. Welcome to Join the Online Meeting! ○ H. Subsequence Counting 不可做 I. A Brand New Geometric Problem DP、质因子分解 J. New Energy Vehicle ○ 铜牌题、贪心 K. Farm Management ○ L. A Game On Tree ⊕ 树上问题、期望、拆贡献 M. Weird Ceiling ○ M1234567891011121314151617181920212223242526272829void solve() { int n = read(); vector&lt;int&gt; a; // a.eb(1); for (int i = 1; i * i &lt;= n; i++) { if (n % i == 0) { a.eb(i); if (n / i != i) { a.eb(n / i); } } } std::sort(a.begin(), a.end()); int ans = 0; int m = a.size(); for (int i = 1; i &lt; m; i++) { // cout &lt;&lt; &quot;a: &quot; &lt;&lt; a[i] &lt;&lt; '\\n'; ans += n / a[i - 1] * (a[i] - a[i - 1]); } ans += n / a[m - 1] * (n - a[m - 1] + 1); cout &lt;&lt; ans &lt;&lt; '\\n';} G1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071void solve() { int n = read(), m = read(), k = read(); vector&lt;int&gt; bad(n + 1); for (int i = 1; i &lt;= k; i++) { int x = read(); bad[x] = 1; } vector&lt;int&gt; vis(n + 1); vector&lt;vector&lt;int&gt;&gt; g(n + 1); using pii = std::pair&lt;int, int&gt;; int timer = 0; vector&lt;int&gt; idx(n + 1); vector&lt;vector&lt;int&gt;&gt; ans(n + 1); std::function&lt;void(int)&gt; dfs = [&amp;](int u) { vis[u] = 1; if (bad[u]) return; for (int v : g[u]) { if (!vis[v]) { idx[++timer] = u; break; } } for (int v : g[u]) { if (!vis[v]) { ans[u].eb(v); dfs(v); } } }; for (int i = 1; i &lt;= m; i++) { int u = read(); int v = read(); g[u].eb(v); g[v].eb(u); } for (int i = 1; i &lt;= n; i++) { if (!bad[i]) { dfs(i); break; } } for (int i = 1; i &lt;= n; i++) { if (!vis[i]) { cout &lt;&lt; &quot;No\\n&quot;; return; } } cout &lt;&lt; &quot;Yes\\n&quot;; cout &lt;&lt; timer &lt;&lt; '\\n'; for (int i = 1; i &lt;= timer; i++) { int u = idx[i]; cout &lt;&lt; u &lt;&lt; ' ' &lt;&lt; ans[u].size(); for (int v : ans[u]) { cout &lt;&lt; ' ' &lt;&lt; v; } puts(&quot;&quot;); }} K 二分按 w 从大到小排序，枚举操作的 i。那么比这个收益小的都卡底线。收益大的是一段前缀，二分这个前缀就做完了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364void solve() { int n = read(), m = read(); vector&lt;Node&gt; a(n + 1); for (int i = 1; i &lt;= n; i++) { a[i].w = read(); a[i].l = read(); a[i].r = read(); } std::sort(a.begin() + 1, a.end()); int ans = 0; int tim = 0; int tot = 0; for (int i = 1; i &lt;= n; i++) { tim += a[i].l; tot += a[i].l * a[i].w; } vector&lt;int&gt; sum(n + 1); vector&lt;int&gt; sumw(n + 1); for (int i = 1; i &lt;= n; i++) { sum[i] = sum[i - 1] + a[i].r - a[i].l; sumw[i] = sumw[i - 1] + (a[i].r - a[i].l) * a[i].w; } for (int i = 1; i &lt;= n; i++) { int res = tot - a[i].l * a[i].w; int rem = max(0LL, m - tim + a[i].l); int pos = 0; for (int l = 1, r = i - 1; l &lt;= r; ) { int mid = l + r &gt;&gt; 1; if (sum[mid] &lt;= rem) { pos = mid, l = mid + 1; } else { r = mid - 1; } } // cout &lt;&lt; pos &lt;&lt; &quot; &quot;; // cout &lt;&lt; rem &lt;&lt; &quot; &quot;; // cout &lt;&lt; res &lt;&lt; &quot; &quot;; // cout &lt;&lt; &quot; | &quot;; res += sumw[pos]; rem -= sum[pos]; pos++; res += rem * a[pos].w; // cout &lt;&lt; i &lt;&lt; &quot; &quot;; // cout &lt;&lt; pos &lt;&lt; &quot; &quot;; // cout &lt;&lt; rem &lt;&lt; &quot; &quot;; // cout &lt;&lt; res &lt;&lt; &quot; &quot;; // cout &lt;&lt; '\\n'; ans = max(ans, res); } cout &lt;&lt; ans &lt;&lt; '\\n';} L TreeDP、期望首先期望是假的，算总收益再除去方案数即可。 考虑拆下这个期望，平方拆开来是每个数的平方加上选两个项乘起来。 $$\\left(\\left|e_1\\right|+\\left|e_2\\right|+\\ldots+\\left|e_k\\right|\\right)^2=\\sum_{i=1}^k\\left|e_i\\right|^2+\\sum_{1 \\leq i, j \\leq k}\\left|e_i\\right| \\cdot\\left|e_j\\right|$$ 这里的 $e_i$ 均为 $1$。 一种选法的贡献可以分为两种： 一种是由公共边 $e_i$ 产生的 一种是由有序对 $(e_i, e_j)$ 产生的 不妨设 $siz[u]$ 为 $u$ 的子树大小，$sum[u] = \\sum_{v \\in subtree_u}{(siz[v])^2}$。 分别讨论下这个贡献怎么算就行了，sol 写的很清楚了不再赘述 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253void solve() { int n = read(); vector&lt;vector&lt;int&gt;&gt; g(n + 1); for (int i = 1; i &lt; n; i++) { int u = read(); int v = read(); g[u].eb(v); g[v].eb(u); } Z ans = 0; vector&lt;Z&gt; siz(n + 1), sum(n + 1); std::function&lt;void(int, int)&gt; dfs = [&amp;](int u, int fa) { siz[u] = 1; for (int v : g[u]) { if (v == fa) continue; dfs(v, u); siz[u] += siz[v]; sum[u] += sum[v]; } Z t = sum[u]; sum[u] += siz[u] * siz[u]; for (int v : g[u]) { if (v == fa) continue; ans += siz[v] * siz[v] * (n - siz[v]) * (n - siz[v]); ans += 2 * (n - siz[v]) * (n - siz[v]) * (sum[v] - siz[v] * siz[v]); ans += (t - sum[v]) * sum[v]; } }; dfs(1, 0); // for (int i = 1; i &lt;= n; i++) { // cout &lt;&lt; siz[i] &lt;&lt; '\\n'; // } // puts(&quot;------&quot;); // for (int i = 1; i &lt;= n; i++) { // cout &lt;&lt; sum[i] &lt;&lt; '\\n'; // } // puts(&quot;------&quot;); ans /= n * (n - 1) / 2; ans /= n * (n - 1) / 2; cout &lt;&lt; ans &lt;&lt; '\\n';} A 构造唉唉 VP 的时候被这个痛苦折磨。构造解的时候不应该想着具体化的最优策略，应该好好想想形式化的表述的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107void solve() { int L = read(); int R = read(); vector&lt;int&gt; d(1000); int st = 1; int ed = 2; d[0] = ed; using pii = std::pair&lt;int, int&gt;; vector&lt;vector&lt;pii&gt;&gt; g(1000); for (int i = 1; i &lt;= 20; i++) { d[i] = ed + i; g[d[i]].eb(d[i - 1], 0); g[d[i]].eb(d[i - 1], 1); } int cur = 22; // 20(log) + 1(st) + 1(ed) vector ts(1000, vector&lt;int&gt;(2, -1)); // trie auto get_id = [&amp;](int p) { vector&lt;int&gt; s; for (; p; p &gt;&gt;= 1) s.eb(p % 2); std::reverse(s.begin(), s.end()); int now = st; for (auto x : s) { if (ts[now][x] == -1) { ts[now][x] = ++cur; g[now].eb(cur, x); } now = ts[now][x]; } return now; }; auto cons = [&amp;](this auto &amp;&amp;self, int l, int r, int lb, int rb, int lv, int p) -&gt; void { if (l == lb and r == rb) { int w = 0, f = p / 2; if (f * 2 + 1 == p) { w = 1; } int id = get_id(f); g[id].eb(d[lv], w); return; } int mid = lb + rb &gt;&gt; 1; if (r &lt;= mid) { self(l, r, lb, mid, lv - 1, p * 2); } else if (mid &lt; l) { self(l, r, mid + 1, rb, lv - 1, p * 2 + 1); } else { self(l, mid, lb, mid, lv - 1, p * 2); self(mid + 1, r, mid + 1, rb, lv - 1, p * 2 + 1); } return; }; cons(L, R, 0, (1 &lt;&lt; 20) - 1, 20, 0); // for (int i = 1; i &lt;= cur; ++i) { // printf(&quot;Node %d: &quot;, i); // for (auto v : g[i]) // printf(&quot;%d|%d &quot;, v.first, v.second); // puts(&quot;&quot;); // } int n = 1; std::map&lt;int, int&gt; idx; idx[1] = 1; vector&lt;int&gt; vis(1000); auto dfs = [&amp;](this auto &amp;&amp;self, int u) -&gt; void { vis[u] = 1; for (auto [v, dis] : g[u]) { if (vis[v]) continue; self(v); } }; dfs(1); for (int i = 2; i &lt;= cur; i++) { if (!vis[i]) continue; idx[i] = ++n; } vector&lt;vector&lt;pii&gt;&gt; G(1000); for (int i = 1; i &lt;= cur; i++) { if (!vis[i]) continue; for (auto [j, dis] : g[i]) { int u = idx[i]; int v = idx[j]; G[u].eb(v, dis); } } cout &lt;&lt; n &lt;&lt; '\\n'; for (int u = 1; u &lt;= n; u++) { cout &lt;&lt; G[u].size(); for (auto [v, dis] : G[u]) { cout &lt;&lt; &quot; &quot; &lt;&lt; v; cout &lt;&lt; &quot; &quot; &lt;&lt; dis; } cout &lt;&lt; '\\n'; }} E 可撤销背包、多项式 $m$ 个球，速度为 $v_i$ , $n$ 个位置 $x_1, \\cdots , x_n$ ，每个球都会随机选择一个位置，然后向正方向移动，求坐标中位数在原点的期望时间，对 $10^9 + 7$ 取模 $n, m \\le 500$ 设 $m = O(n)$，可能的时间答案一定是某个 $t = \\frac{x_i}{v_j}$，那么一共有 $n \\cdot m$ 个 $t$，对于每个 $t$，求恰好有 $\\lfloor \\frac{m}{2} \\rfloor$ 个球还没经过原点的概率 对于每个球，可以枚举所有位置，计算出在 $t$ 时没经过原点的概率 $p_i$，经过原点的概率 $1-p_i$。求恰好有 $\\lfloor \\frac{m}{2} \\rfloor$ 个球还没经过原点的概率，这东西是可以背包的。这样的复杂度是 $O(n^4)$。 实际上状态数量并没有那么多，看起来有 $O(n^3)$ 个 $p_i$ ($n^2$ 个 $t$ 和 $n$ 个球)，实际上对于每个球，假如我们将 $O(n^2)$ 个 $t$ 从小到大排序，并从小到大枚举这个 $t = \\frac{x_i}{v_j}$，对于这个 $t$，只有对应的 $p_j$ 会发生改变，而其他的球都不会发生改变，也就是说实际上就 $O(n^2)$ 个状态。并且我们可以维护所有球的 $dp$ 数组，当某个球发生改变时，撤销那个球，然后把概率变化后的新球加上去。 更进一步地，根据可撤销背包的知识，我们知道单次的可撤销背包对应除一个单项式。我们可以将每个球看作 $p_i\\cdot x + (1 - p_i)$，求的是生成函数的 $x^{m / 2}$ 项的系数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354void solve() { int n = read(), m = read(); vector&lt;int&gt; x(n); for (int i = 0; i &lt; n; i++) { x[i] = -read(); } vector&lt;int&gt; v(m); for (int i = 0; i &lt; m; i++) { v[i] = read(); } vector&lt;pii&gt; t; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { t.eb(i, j); } } std::sort(t.begin(), t.end(), [&amp;](pii a, pii b) { return x[a.fi] * v[b.se] &lt; x[b.fi] * v[a.se]; }); Z ans = 0; Z invN = Z(n).inv(); vector&lt;Z&gt; d(m + 1); vector&lt;Z&gt; f(m + 1); f[0] = power(Z(n), m); auto ins = [&amp;](Z x) { Z y = n - x; for (int i = m; i &gt;= 1; i--) { f[i] = f[i] * y + f[i - 1] * x; } f[0] *= y; }; auto del = [&amp;](Z x) { Z y = Z(n - x).inv(); f[0] *= y; for (int i = 1; i &lt;= m; i++) { f[i] = (f[i] - f[i - 1] * x) * y; } }; for (auto [i, j] : t) { del(d[j]); ans += f[m / 2] * invN * x[i] / v[j]; d[j] += 1; ins(d[j]); } ans *= power(invN, m - 1); cout &lt;&lt; ans &lt;&lt; '\\n';}","link":"/vp-2024-ccpc-%E5%93%88%E5%B0%94%E6%BB%A8/"},{"title":"VP 2023 JSCPC","text":"2023 Jiangsu Collegiate Programming Contest2023 National Invitational of CCPC (Hunan)The 13th Xiangtan Collegiate Programming Contest 比赛链接 Problems AC A. Today’s Word ○ B. Honkai in TAIKULA C. GG and YY’s Game D. Star Rail E. LCM Plus GCD ⊕ F. Timaeus ○ G. Moving Boxes H. Neil’s Machine ○ I. Elevator ○ J. Similarity (Easy Version) ○ K. Similarity (Hard Version) ○ L. Architect ○ I 签到1234void solve() { int n = read(), m = read(); cout &lt;&lt; n - m + 1 &lt;&lt; '\\n';} H 差分挺好玩的其实，像个 div2 c 题。 区间加相当于差分数组上的 2 点修改。 后缀加相当于差分数组上的 单点修改。 判断差分数组在 mod 26 意义下是否相等即可 12345678910111213141516171819202122232425262728293031void solve() { int n; cin &gt;&gt; n; vector&lt;char&gt; a(n + 1); vector&lt;char&gt; b(n + 1); vector&lt;int&gt; da(n + 1); vector&lt;int&gt; db(n + 1); for (int i = 1; i &lt;= n; i++) { // a[i] = read(); cin &gt;&gt; a[i]; da[i] = (a[i] - a[i - 1] + 26) % 26; } for (int i = 1; i &lt;= n; i++) { // b[i] = read(); cin &gt;&gt; b[i]; db[i] = (b[i] - b[i - 1] + 26) % 26; } int ans = 0; for (int i = 1; i &lt;= n; i++) { if (da[i] != db[i]) { ans++; } } cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;} J 最长公共子串123456789101112131415161718192021222324252627282930313233void solve() { int n = read(); vector&lt;string&gt; s(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; s[i]; } int ans = 0; for (int i = 0; i &lt; n; i++) { for (int j = i + 1; j &lt; n; j++) { int la = s[i].size(); int lb = s[j].size(); vector dp(la + 1, vector&lt;int&gt;(lb + 1)); for (int x = la - 1; x &gt;= 0; x--) { for (int y = lb - 1; y &gt;= 0; y--) { if (s[i][x] == s[j][y]) { dp[x][y] = 1 + dp[x + 1][y + 1]; } ans = max(ans, dp[x][y]); } } } } cout &lt;&lt; ans &lt;&lt; '\\n';} A 字符串循环移位和 24 ccpc 网络赛那个题很像，但是做法不太一样。 长度 &gt;= 2m 之后最后 m 个字符就确定了，之后只是会一直循环移位。 123456789101112131415161718192021222324252627282930313233void solve() { int n = read(), m = read(); string s; cin &gt;&gt; s; int p = 16; int len = s.size(); while (len &lt; 2 * m) { int m = len / 2; s = s.substr(0, m) + s + s.substr(m); len *= 2; for (int i = len - m; i &lt; len; i++) { s[i] = s[i] == 'z' ? 'a' : s[i] + 1; } // cout &lt;&lt; s &lt;&lt; &quot;\\n&quot;; p = (p + 25) % 26; } s = s.substr(len - m); for (auto &amp;ch : s) { int t = ch - 'a'; t = (t + p) % 26; ch = 'a' + t; } cout &lt;&lt; s;} K 构造12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849signed main() { std::ios::sync_with_stdio(false); std::cin.tie(0); // int T; // cin &gt;&gt; T; // for(;T--;solve()); int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; if(m == 0) { if(n &lt;= 26) { cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; for(int i = 0;i &lt; n;i ++) { for(int j = 0;j &lt; k;j ++) { cout &lt;&lt; char(i + 'a'); } cout &lt;&lt; endl; } }else { cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; } return 0; } if(m &lt; k) { cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; char s1 = 'b', s2 = 'c'; for(int i = 0;i &lt; n;i ++) { for(int j = 0;j &lt; m - 1;j ++) { cout &lt;&lt; &quot;a&quot;; } for(int j = m - 1;j &lt; k;j ++) { cout &lt;&lt; ((j - m + 1) % 2 == 0 ? s1 : s2); } cout &lt;&lt; endl; if (s2 == 'z') { s1++; s2 = s1 + 1; } else { s2 ++; } } }else { cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; } return 0;} F 期望 DP赛时 wa 了一发，第一眼没看出来。 状态转移的 dag 上面不能有自环。 1234567891011121314151617181920212223242526void solve() { int A = read(), B = read(); double P = read(), Q = read(); P /= 100, Q /= 100; std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(15); if (B == 1) { double x = A * (P * 2 + (1 - P) * 1); double y = A * (1.0 / (1 - Q)); cout &lt;&lt; max(x, y); return; } vector&lt;double&gt; dp(A + 1); for (int i = B; i &lt;= A; i++) { dp[i] = max( P * (dp[i - B] + 2) + (1 - P) * (dp[i - B] + 1), Q * (dp[i - B + 1] + 1) + (1 - Q) * (dp[i - B] + 1) ); // cout &lt;&lt; dp[i] &lt;&lt; &quot;\\n&quot;; } cout &lt;&lt; dp[A] &lt;&lt; &quot;\\n&quot;;} L 给出 n 个长方体，询问其是否拼接成一个 W × H × L 的立方体，没有重叠和空隙。 把原来大长方体等价代换成WHL个111的小方块，想象一下挖走一块移到另一个地方，会使中空的地方的8个顶点必然有奇数次覆盖，如果移到相邻位置，原来的点还是偶数次，但会造成新的点变成奇数次。所以所有顶点覆盖偶数次是充要条件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445void solve() { int W = read(), H = read(), L = read(); int n = read(); vector&lt;std::array&lt;int, 6&gt;&gt; a(n); for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; 6; j++) { a[i][j] = read(); } } i128 V = (i128)W * H * L; for (auto c : a) { i128 v = (i128)(c[3] - c[0]) * (c[4] - c[1]) * (c[5] - c[2]); V -= v; } if (V) { puts(&quot;No&quot;); return; } std::map&lt;std::array&lt;int, 3&gt;, int&gt; f; a.push_back({0, 0, 0, W, H, L}); for (auto c : a) { for (int x : {c[0], c[3]}) { for (int y : {c[1], c[4]}) { for (int z : {c[2], c[5]}) { ++f[{x, y, z}]; } } } } for (auto [x, y] : f) { if (y &amp; 1) { puts(&quot;No&quot;); return; } } puts(&quot;Yes&quot;);} E 容斥、数论 输入 $x, k$，求大小为 $k$ 的 distinct 集合个数，其中所有数的 $\\gcd + \\operatorname{lcm} = x$。 设 $\\gcd = G$，$\\operatorname{lcm} = A \\times G$ 那么 $(1 + A) \\times G = x$，故我们可以对 $x$ 枚举因子得到 $G$ 把集合中每个数除掉 $G$，那么限制就转化为 $gcd = 1$, $lcm = A$ 设 $A = \\prod_{j = 1}^m{p_j^{b_j}}$, $a_i^{\\prime} = \\prod_{j = 1}^m{p_j^{c_{ij}}}$ 限制转化为 $2m$ 条约束 $\\min{c_{ij}} = 0, \\max{c_{ij}} = b_j$ 假设不考虑约束（也就是 $\\min$ 不一定取到 $0$，$\\max$ 不一定取 $b_j$），一共有 $B = \\prod_{j = 1}^m{(b_j - 0 + 1)}$ 个数，在其中选 $k$ 个就是 $\\binom{B}{k}$ 考虑上约束，我们可以使用容斥原理：两个约束任意满不满足 - 约束1一定不满足 - 约束2一定不满足 + 约束12都一定不满足 假设约束 1 一定不满足，则 $\\min$ 一定不为 $0$，可选的数变为 $B^{\\prime} = \\prod_{j = 1}^m{(b_j - 1 + 1)}$，在其中选 $k$ 个就是 $\\binom{B^{\\prime}}{k}$ 约束 2 一定不满足也类似。 我们可以枚举 $2m$ 个约束分别有没有满足来进行容斥。 总的时间复杂度为 $O(Fm2^{2m})$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162void solve() { int x = read(), k = read(); Z ans = 0; auto calc = [&amp;](int G) { int A = x / G - 1; if (A == 0) return; vector&lt;int&gt; p, e; for (int i = 2; i * i &lt;= A; i++) { if (A % i != 0) continue; e.eb(0); while (A % i == 0) { A /= i; e.back()++; } p.eb(i); } if (A &gt; 1) { e.eb(1); p.eb(A); } int m = p.size(); for (int s = 0; s &lt; (1 &lt;&lt; m); s++) { for (int t = 0; t &lt; (1 &lt;&lt; m); t++) { int res = 1; int coef = 1; for (int i = 0; i &lt; m; i++) { int v = e[i] + 1; if (s &gt;&gt; i &amp; 1) { coef *= -1; v--; } if (t &gt;&gt; i &amp; 1) { coef *= -1; v--; } res *= v; } ans += comb.binom(res, k) * coef; } } }; for (int G = 1; G * G &lt;= x; G++) { if (x % G != 0) continue; calc(G); if (G * G != x) { calc(x / G); } } cout &lt;&lt; ans;}","link":"/vp-2023-jscpc/"},{"title":"VP 2024 ICPC 南京","text":"The 2024 ICPC Asia Nanjing Regional Contest (The 3rd Universal Cup. Stage 16: Nanjing)比赛链接 Problems AC Note A. Hey, Have You Seen My Kangaroo? Medium-Hard B. Birthday Gift ○ C. Topology ⊕ 拓扑序、组合数学 D. Toe-Tac-Tics Hard E. Left Shifting 3 ○ F. Subway ⊕ G. Binary Tree ○ H. Border Jump 2 Hard I. Bingo ⊕ min-max容斥 J. Social Media ○ K. Strips ○ L. $P \\oplus Q = R$ Impossible M. Ordainer of Inexorable Judgment Medium-Hard、计算几何 E12345678910111213141516171819202122232425262728293031323334353637383940void solve() { int n = read(), k = read(); string s; cin &gt;&gt; s; s = &quot; &quot; + s + s; if (n &lt;= 6) { puts(&quot;0&quot;); return; } int ans = 0; string t = &quot;nanjing&quot;; vector&lt;int&gt; a(2 * n + 1); for (int i = 1; i &lt;= 2 * n; i++) { bool f = 1; for (int j = i; j &lt;= i + 6 and j &lt;= 2 * n; j++) { if (s[j] != t[j - i]) { f = 0; break; } } if (f) { a[i]++; } } for (int i = 1; i &lt;= 2 * n; i++) { a[i] += a[i - 1]; } for (int i = 1; i + n - 1 - 6 &lt;= n + min(n, k) - 6; i++) { ans = max(ans, a[i + n - 1 - 6] - a[i - 1]); } cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;} J将边分为三类：老朋友–老朋友、新朋友–老朋友，新朋友–新朋友 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758void solve() { int n = read(), m = read(), k = read(); vector&lt;int&gt; bad(k + 1), used(k + 1); for (int i = 1; i &lt;= n; i++) { bad[read()] = 1; } int ans = 0; using pii = std::pair&lt;int, int&gt;; #define fi first #define se second std::map&lt;pii, int&gt; mp; vector&lt;int&gt; f(k + 1); vector&lt;vector&lt;int&gt;&gt; g(k + 1); for (int i = 1; i &lt;= m; i++) { int u = read(), v = read(); if (bad[u] and bad[v]) { ans++; continue; } g[u].eb(v); g[v].eb(u); if (u &gt; v) swap(u, v); if (u != v) mp[{u, v}]++; else f[u]++; // mp[{v, u}]++; } for (int i = 1; i &lt;= k; i++) { if (bad[i]) continue; for (int v : g[i]) { if (bad[v]) { f[i]++; } } // f[i] += mp[{i, i}]; } int res = 0; for (auto [it, cnt] : mp) { auto [u, v] = it; if (!bad[u] and !bad[v]) res = max(res, f[u] + f[v] + cnt); else res = max(res, f[u] + f[v]); } std::sort(f.begin() + 1, f.end()); res = max(res, f[k] + f[k - 1]); cout &lt;&lt; ans + res &lt;&lt; '\\n';} G 交互、树的重心找出树的重心 $p$，根据重心的邻居数量 $d$ 进行讨论 $d = 0$，$p$ 就是答案 $d = 1$，询问 $p$ 和他的邻居，删点递归。 $d = 2$，询问两个邻居 $d = 3$，询问两个 siz 最大的邻居 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134void solve() { int n; cin &gt;&gt; n; cout.flush(); vector&lt;vector&lt;int&gt;&gt; g(n + 1); for (int i = 1; i &lt;= n; i++) { int ls, rs; cin &gt;&gt; ls &gt;&gt; rs; cout.flush(); if (ls) { g[i].pb(ls); g[ls].pb(i); } if (rs) { g[i].pb(rs); g[rs].pb(i); } } vector&lt;int&gt; siz(n + 1); vector&lt;int&gt; w(n + 1); int p = 1, tot = n; vector&lt;int&gt; ban(n + 1); std::function&lt;void(int, int)&gt; dfs1 = [&amp;](int u, int fa) { siz[u] = 1; for (int v : g[u]) { if (ban[v] or v == fa) continue; dfs1(v, u); siz[u] += siz[v]; } }; std::function&lt;void(int, int)&gt; dfs2 = [&amp;](int u, int fa) { w[u] = 0; for (int v : g[u]) { if (ban[v] or v == fa) continue; dfs2(v, u); w[u] = max(w[u], siz[v]); } w[u] = max(w[u], tot - siz[u]); if (w[u] &lt;= tot / 2) { p = u; } }; using std::endl; auto qry = [&amp;](int x, int y) { cout &lt;&lt; &quot;? &quot; &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl; cout.flush(); int t; cin &gt;&gt; t; cout.flush(); return t; }; while (tot &gt; 1) { dfs1(p, 0); tot = siz[p]; dfs2(p, 0); int d = 0; for (int v : g[p]) { if (!ban[v]) d++; } if (d == 0) { cout &lt;&lt; &quot;! &quot; &lt;&lt; p &lt;&lt; endl; cout.flush(); return; } else if (d == 1) { int x = p, y = 0; for (int tmp : g[p]) { if (!ban[tmp]) { y = tmp; break; } } int t = qry(x, y); if (t == 0) { cout &lt;&lt; &quot;! &quot; &lt;&lt; x &lt;&lt; endl; cout.flush(); return; } else if (t == 2) { ban[x] = 1; p = y; } } else if (d == 2) { int x = 0, y = 0; for (int v : g[p]) { if (!ban[v]) { if (!x) x = v; else y = v; } } int t = qry(x, y); if (t == 0) { ban[p] = ban[y] = 1; p = x; } else if (t == 1) { cout &lt;&lt; &quot;! &quot; &lt;&lt; p &lt;&lt; endl; cout.flush(); return; } else { ban[p] = ban[x] = 1; p = y; } } else if (d == 3) { int x = g[p][0], y = g[p][1], z = g[p][2]; int sx = siz[x], sy = siz[y], sz = siz[z]; if (sx &lt; sy) swap(x, y), swap(sx, sy); if (sx &lt; sz) swap(x, z), swap(sx, sz); if (sy &lt; sz) swap(y, z), swap(sy, sz); int t = qry(x, y); if (t == 1) { ban[x] = ban[y] = 1; } else if (t == 0) { ban[y] = ban[z] = ban[p] = 1; p = x; } else { ban[p] = ban[x] = ban[z] = 1; p = y; } } }} C 组合数学、TreeDP、拓扑序 给定一棵由 $n$ 个点组成的外向树，满足父亲的编号小于儿子。对于每个 $1 \\le i \\le n$，求出这棵树的满足编号为 $i$ 的点出现在第 $i$ 个位置的拓扑序数量，对 $998244353$ 取模。 $n \\le 5000$ 考虑求出所有的 $dp(i, j)$，表示编号为 $i$ 的点在拓扑序中出现在第 $j$ 位的方案数。答案即为所有的 $dp(i, i)$。 为了方便转移，可以让 $dp(i, j)$ 先不考虑子树 $i$ 内部的顺序，最后求答案的时候再乘上子树 $i$ 的拓扑序个数。 设点 $u$ 的父亲为 $fa$，考虑从 $dp(fa, i)$ 转移到 $dp(u, j)$。 首先，需要安排在 $fa$ 子树中，但不在 $u$ 子树中的 $siz_{fa} - siz_{u} - 1$ 个点在拓扑序中的位置。已知条件是 $fa$ 出现在 $i$ 位置，后面的 $n - i$ 个位置里面 $u$ 的子树占了 $siz_u$ 个位置。那么可选的空位就是 $n - i - siz_u$ 个，要选 $siz_{fa} - siz_u - 1$ 个位置用来放这些点。方案数为 $\\binom{n - i - siz_u}{siz_{fa} - siz_u - 1}$。 其次，需要确定在 $fa$ 子树中，但不在 $u$ 子树中的 $siz_{fa} - siz_{u} - 1$ 个点在拓扑序中的相对顺序。这是一个经典的子问题：一棵 $n$ 个点的外向树的拓扑序个数为 $\\frac{n!}{\\prod_{i = 1}^{n}siz_i}$。那么个数就是 $\\frac{(siz_{fa} - siz_u - 1)!}{\\prod_{v \\in subtree(fa) \\land v \\notin subtree(u)}siz_v}$ 因此，我们可以写出： $$dp(u, j) = \\sum_{i = 1}^{j - 1} dp(fa, i) \\cdot \\binom{n - i - siz_u}{siz_{fa} - siz_u - 1} \\cdot \\frac{(siz_{fa} - siz_u - 1)!}{\\prod_{v \\in subtree(fa) \\land v \\notin subtree(u)}siz_v}$$ 观察到式子和 $j$ 没有关系，可以前缀和优化转移。总共 $O(n^2)$ 个状态，转移的复杂度为 $O(1)$。 因为一开始并没有考虑子树内部的顺序，所以最后求答案的时候要乘上 子树的点位置的方案数 和 拓扑序的个数。 总时间复杂度 $O(n^2)$，可以通过此题。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546void solve() { int n = read(); vector&lt;int&gt; p(n + 1); for (int i = 2; i &lt;= n; i++) { cin &gt;&gt; p[i]; } vector&lt;int&gt; siz(n + 1, 1); vector&lt;Z&gt; prod(n + 1, 1); for (int i = n; i &gt;= 1; i--) { prod[i] *= siz[i]; if (p[i]) { siz[p[i]] += siz[i]; prod[p[i]] *= prod[i]; } } vector dp(n + 1, vector&lt;Z&gt;(n + 1)); dp[1][1] = 1; for (int u = 2; u &lt;= n; u++) { int fa = p[u]; auto ndp = dp[fa]; Z coef = comb.fac(siz[fa] - siz[u] - 1) / (prod[fa] / prod[u] / siz[fa]); for (int i = 1; i &lt;= n; i++) { ndp[i] *= comb.binom(n - i - siz[u], siz[fa] - siz[u] - 1); } for (int i = 1; i &lt;= n; i++) { ndp[i] += ndp[i - 1]; } for (int i = 1; i &lt;= n; i++) { dp[u][i] = coef * ndp[i - 1]; } } for (int i = 1; i &lt;= n; i++) { Z res = dp[i][i]; res *= comb.binom(n - i, siz[i] - 1); res *= comb.fac(siz[i]) / prod[i]; cout &lt;&lt; res &lt;&lt; &quot; \\n&quot;[i == n]; }} I min–max 容斥、多项式 给定一个长度为 $nm$ 的整数序列，将其打乱之后按顺序填入 $n \\times m$ 的网格中。定义 bingo 整数为最小的整数 $k$，满足存在至少一行或者一列，其中所有的数都 $\\le k$。求出所有 $(nm)!$ 种打乱方式的 bingo 整数之和，对 $998244353$ 取模。 $nm \\le 2 \\times 10^5$ 定义一行或一列的 bingo 整数为其中填入的数的 $\\max$，则所求的 bingo 整数为所有行列的 bingo 整数的 $\\min$。 对于 $\\min$ 不好处理的情况，考虑使用 $\\min − \\max$ 容斥： $$\\min_{x \\in S}x = \\sum_{T \\subseteq S, T \\neq \\varnothing}(-1)^{\\lvert T \\rvert - 1} \\max_{x \\in T}x$$ $S$ 即为所有行和列的集合。$\\max_{x \\in T}x$ 即为 $T$ 中所有行和列的 bingo 数的最大值。 假设 $T$ 有 $x$ 行 $y$ 列，$T$ 覆盖了 $c = mx + ny - xy$ 个格子。 将数列从小到大排序。当这 $c$ 个格子的最大值是 $a_i$ 时，当且仅当，$a_i$ 在这 $c$ 个格子中出现，且 $a_{i + 1}, a_{i + 2}, \\cdots, a_{nm}$ 均没有出现，方案数为： $$\\binom{i - 1}{c - 1}c!(nm - c)!$$ 对于一个 $c$，暴力求出答案是 $O((nm)^2)$ 的。容易发现将这个式子拆开是可以卷积加速的。 具体地， \\begin{aligned}&amp;\\sum_{i=1}^{nm}\\binom{i - 1}{c - 1}c!(nm - c)!a_i \\\\&amp;= \\frac{(i - 1)!}{(c - 1)!(i - c)!}c!(nm - c)!a_i \\\\&amp;= \\frac{a_i(i - 1)!}{(i - c)!} \\cdot c(nm - c)! \\\\\\end{aligned} 我们令多项式 $f_i = a_i \\cdot (i - 1)!$，$g_i = \\frac{1}{(nm - 1 - i)!}$，令 $p$ 是 $f$ 和 $g$ 的卷积 \\begin{aligned}p_c &amp;= \\sum_{i + j = c} {f_i}{g_j} \\\\&amp;= \\frac{a_i \\cdot (i - 1)!}{(nm - 1 - j)!} \\\\&amp;= \\frac{a_i \\cdot (i - 1)!}{(nm + i - 1 - c)!} \\\\\\end{aligned} 再令 $p$ 左移 $nm - 1$ 位， $$p_c \\gets p_{c + nm - 1} = \\frac{a_i \\cdot (i - 1)!}{(i - c)!}$$ 再令 $p_c \\gets p_c \\cdot c(nm - c)!$，即可求出 $c$ 对应的答案 $p_c$。 这样，当我们对每个 $c$ 求出答案以后，枚举 $T$ 中选择了 $x$ 行 $y$ 列，则选择 $T$ 的方案数为 $\\binom{n}{x}\\binom{m}{y}$，乘上容斥系数求和即可。 时间复杂度 $O(nm \\log nm)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455void solve() { int n = read(), m = read(); vector&lt;int&gt; a(n * m + 1); for (int i = 1; i &lt;= n * m; i++) { a[i] = read(); } std::sort(a.begin(), a.end()); Poly&lt;P&gt; f, g; f.resize(n * m + 1); g.resize(n * m); for (int i = 1; i &lt;= n * m; i++) { f[i] = a[i] * comb.fac(i - 1); } for (int i = 0; i &lt; n * m; i++) { g[i] = comb.invfac(n * m - 1 - i); } f *= g; f = f.shift(- (n * m - 1)); for(int i = 1; i &lt;= n * m; i++) { f[i] *= i * comb.fac(n * m - i); } Z ans = 0; for (int x = 0; x &lt;= n; x++) { for (int y = 0; y &lt;= m; y++) { if (x + y == 0) { continue; } Z coef = (x + y - 1) % 2 == 0 ? 1 : -1; Z res = coef * comb.binom(n, x) * comb.binom(m, y); res *= f[m * x + n * y - x * y]; /* Z t = 0; for (int i = 1; i &lt;= n * m; i++) { t += comb.binom(i - 1, c - 1) * comb.fac(c) * comb.fac(n * m - c) * a[i]; } res *= t; */ ans += res; } } cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;} F 最短路、李超树 有 $n$ 个地铁站和 $k$ 条地铁线路，可以乘坐地铁或者在某站处换乘。乘坐第 $i$ 条线路的第 $j$ 段需要 $w_{i,j}$ 单位时间。从某站的 $x$ 号线路换乘到 $y$ 号线路需要 $a_x \\cdot by$ 单位时间。 求出从站点 $1$ 到每个站点的最短路。 $n$, $k$, $\\sum(p_i − 1) \\le 2 \\times 10^5$ 复读题解 考虑用状态 $(i, j)$ 表示当前在第 $i$ 个站，并在第 $j$ 条线路上。在状态间求最短路来得到答案。 乘坐地铁的转移是简单的，只需要从 $(i, j)$ 转移到第 $j$ 条线路的下一站 $x$ 对应的状态 $(x, j)$ 即可。 考虑如何处理换乘的转移。将一个站点的线路按照 $b$ 从小到大排序，可以发现转移到 $b$ 较小的线路一定代价比 $b$ 较大的线路小，也就是说，$b$ 较小的状态一定先于较大的状态被加入优先队列。于是可以考虑进行懒惰转移，在每个结点较小的 $b$ 被转移出去之后再考虑下一条线路。 对于一个结点上换乘的转移，相当于是给定若干直线，查询某个 $x$ 处的最小值。使用李超树或者动态凸包可以维护。 时间复杂度 $O((n + k + \\sum p_i) \\log(n + k + \\sum p_i))$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113void solve() { int n = read(); int k = read(); vector&lt;int&gt; a(k), b(k); for (int i = 0; i &lt; k; i++) { b[i] = read(); } for (int i = 0; i &lt; k; i++) { a[i] = read(); } vector&lt;vector&lt;int&gt;&gt; x(k); vector&lt;vector&lt;int&gt;&gt; w(k); for (int i = 0; i &lt; k; i++) { int p = read(); x[i].resize(p); w[i].resize(p - 1); for (int j = 0; j &lt; p; j++) { x[i][j] = read() - 1; if (j &lt; p - 1) w[i][j] = read(); } } vector&lt;pii&gt; t; vector&lt;vector&lt;pii&gt;&gt; g(n); for (int i = 0; i &lt; k; i++) { for (int j = 0; j &lt; x[i].size(); j++) { t.eb(i, j); g[x[i][j]].eb(b[i], t.size() - 1); } } vector&lt;lichao&gt; tt; for (int i = 0; i &lt; n; i++) { std::sort(g[i].begin(), g[i].end()); vector&lt;int&gt; x; for (auto [b, _] : g[i]) { x.eb(b); } tt.eb(x); } int nn = t.size(); vector&lt;int&gt; dis(nn + n, inf); std::set&lt;pii&gt; pq; for (auto [_, i] : g[0]) { dis[i] = 0; pq.ep(0, i); } vector&lt;int&gt; cur(n, 0); while (!pq.empty()) { auto p = pq.begin(); auto [d, v] = *p; pq.erase(p); if (v &lt; nn) { auto [i, j] = t[v]; if (j + 1 &lt; x[i].size()) { int nd = d + w[i][j]; int u = v + 1; if (nd &lt; dis[u]) { pq.erase({dis[u], u}); dis[u] = nd; pq.ep(dis[u], u); } } int f = x[i][j]; if (cur[f] &lt; g[f].size()) { int u = f + nn; pq.erase({dis[u], u}); tt[f].add(a[i], d); dis[u] = tt[f].calc(cur[f]); pq.ep(dis[u], u); } } else { v -= nn; int u = g[v][cur[v]].se; int nd = tt[v].calc(cur[v]); if (nd &lt; dis[u]) { pq.erase({dis[u], u}); dis[u] = nd; pq.ep(dis[u], u); } cur[v]++; if (cur[v] &lt; g[v].size()) { dis[nn + v] = tt[v].calc(cur[v]); pq.ep(dis[nn + v], nn + v); } } } for (int i = 1; i &lt; n; i++) { int res = inf; for (auto [_, j] : g[i]) { res = min(res, dis[j]); } cout &lt;&lt; res &lt;&lt; &quot; &quot;; } cout &lt;&lt; &quot;\\n&quot;;}","link":"/vp-2024-icpc-%E5%8D%97%E4%BA%AC/"},{"title":"VP 2024 CCPC 重庆","text":"比赛链接 Problems AC Note A. 乘积，欧拉函数，求和 ⊕ 欧拉函数、根号分治 B. osu!mania ○ 卡精度 C. 连方 ○ 构造 D. 有限小数 ⊕ 数论、不定方程 E. 合成大西瓜 ○ 思维 F. Pico Park G. 魔弹 H. str(list(s)) I. 算术 ○ 简单题 J. 骰子 ○ 简单题 K. 小 C 的神秘图形 ○ 简单题 L. 沙堆 M. Median Replacement A 乘积，欧拉函数，求和 给定 $n$ 个数 $a_1, a_2, \\cdots , a_n$，你需要求以下式子的值： $$\\sum_{S \\subseteq\\lbrace 1,2, \\cdots, n\\rbrace} \\varphi\\left(\\prod_{i \\in S} a_i\\right)$$ 答案可能很大，你需要求出其对质数 $998244353$ 取模的结果。 $1 \\le n \\le 2000, 1 \\le a_i \\le 3000$ 由 $\\varphi(n) = n \\times \\prod \\frac {p_i - 1}{p_i}$，一个集合的贡献分为两部分，第一部分是集合元素的乘积，第二部分是每个质因数算一次。 一个做法是状压 DP，记录每个质因数有没有出现过。$O(n2^m)$ 最多支持到 $m = 16$ 左右。 但是有个很典的 trick 是根号分治。恰好 $\\sqrt{3000} = 54$，小于等于 54 的质数只有 16 个。而一个数最多只能有一个大于根号的质因数。那么就可以根号分治了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293int tot = 0;std::vector&lt;int&gt; id;std::vector&lt;int&gt; minp, primes;void sieve(int n) { id.assign(n + 1, 0); minp.assign(n + 1, 0), primes.clear(); for (int i = 2; i &lt;= n; i++) { if (minp[i] == 0) { minp[i] = i, primes.push_back(i); id[i] = tot++; } for (auto p : primes) { if (i * p &gt; n) break; minp[i * p] = p; if (p == minp[i]) break; } }}void solve() { int n; cin &gt;&gt; n; vector&lt;vector&lt;pii&gt;&gt; buk(tot); for (int i = 0; i &lt; n; i++) { int x; cin &gt;&gt; x; pii t = {x, 0}; for (int i = 0; i &lt; 16; i++) { if (x % primes[i] != 0) continue; while (x % primes[i] == 0) x /= primes[i]; t.se |= (1LL &lt;&lt; i); } if (x &gt; 1) { buk[id[x]].eb(t); } else { buk[0].eb(t); } } vector&lt;Z&gt; dp(all); dp[0] = 1; for (auto [x, S] : buk[0]) { auto ndp = dp; for (int mask = 0; mask &lt; all; mask++) { ndp[mask | S] += dp[mask] * x; } dp = std::move(ndp); } for (int i = 16; i &lt; tot; i++) { if (buk[i].empty()) continue; vector&lt;Z&gt; f(all); Z coef = Z(primes[i] - 1) / Z(primes[i]); for (auto [x, S] : buk[i]) { auto nf = f; for (int mask = 0; mask &lt; all; mask++) { nf[mask | S] += f[mask] * x; nf[mask | S] += dp[mask] * x * coef; } f = std::move(nf); } for (int mask = 0; mask &lt; all; mask++) { dp[mask] += f[mask]; } } Z ans = 0; for (int mask = 0; mask &lt; all; mask++) { Z res = dp[mask]; for (int i = 0; i &lt; 16; i++) { if (mask &gt;&gt; i &amp; 1) { res *= Z(primes[i] - 1) / Z(primes[i]); } } ans += res; } cout &lt;&lt; ans &lt;&lt; '\\n';}signed main() { sieve(3000); std::ios::sync_with_stdio(false); std::cin.tie(nullptr); solve(); return 0;} B osu!mania这个题作为签到题并且在样例中给出了一组四舍五入爆精度的例子，可能是有点教育意义（ Code >folded123456789101112131415161718192021222324252627282930double eps = 1e-7;void solve() { double ppmax, a, b, c, d, e, f; cin &gt;&gt; ppmax &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e &gt;&gt; f; double pp = 0; pp = (320.0 * a + 300.0 * b + 200.0 * c + 100.0 * d + 50.0 * e) / (320.0 * (a + b + c + d + e + f)) - 0.8; // if (pp &lt; 0 - eps) pp = 0; pp = max(pp, 0.0); pp *= 5.0 * ppmax; // pp = round(pp); // cout &lt;&lt; pp &lt;&lt; '\\n'; // pp = round(pp); int ppans = int(pp + 0.5 + eps); double acc = 0; acc += 300 * a; acc += 300 * b; acc += 200 * c; acc += 100 * d; acc += 50 * e; acc /= 300.0 * (a + b + c + d + e + f); acc *= 100.0; printf(&quot;%.2f%% %d\\n&quot;, acc, ppans); // cout &lt;&lt; acc &lt;&lt; ' ' &lt;&lt; ppans &lt;&lt; '\\n';} C 连方很难相信赛时写的一坨屎能过，但是没看到条件就讨论了一些不必要的情况。这份代码赛后参考别人的简化了一下。 Code >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465void solve() { int n; cin &gt;&gt; n; string s, t; cin &gt;&gt; s &gt;&gt; t; vector&lt;string&gt; a(7); a[0] = s; a[1] = s; a[2].assign(n, '.'); a[3].assign(n, '.'); a[4].assign(n, '.'); a[5] = t; a[6] = t; for (auto &amp;ch : a[1]) ch = (ch == '.' ? '#' : '.'); for (auto &amp;ch : a[5]) ch = (ch == '.' ? '#' : '.'); int cnt1 = 0, cnt2 = 0; for (auto ch : s) cnt1 += ch == '#'; for (auto ch : t) cnt2 += ch == '#'; if (cnt1 == n and cnt2 == n) { cout &lt;&lt; &quot;Yes\\n&quot;; for (int i = 0; i &lt; 7; i++) { a[i].assign(n, '#'); cout &lt;&lt; a[i] &lt;&lt; '\\n'; } return; } if (max(cnt1, cnt2) == n and cnt1 != cnt2) { cout &lt;&lt; &quot;No\\n&quot;; return; } int l = -1, r = -1; for (int i = 0; i &lt; n and l == -1; i++) { if (a[1][i] == '#') continue; if (i - 1 &gt;= 0 and a[1][i - 1] == '#') l = i; if (i + 1 &lt; n and a[1][i + 1] == '#') l = i; } for (int i = 0; i &lt; n and r == -1; i++) { if (a[5][i] == '#') continue; if (i - 1 &gt;= 0 and a[5][i - 1] == '#') r = i; if (i + 1 &lt; n and a[5][i + 1] == '#') r = i; } a[2][l] = a[4][r] = '#'; if (l &gt; r) swap(l, r); if (l == r or l + 1 == r) { a[3][l] = '#'; } else { for (int i = l + 1; i &lt; r; i++) { a[3][i] = '#'; } } cout &lt;&lt; &quot;Yes\\n&quot;; for (int i = 0; i &lt; 7; i++) { cout &lt;&lt; a[i] &lt;&lt; '\\n'; } // cerr &lt;&lt; &quot;----\\n&quot;;} D. 有限小数 给定两个互质正整数 $a, b$，你需要求两个非负整数 $c, d$，满足以下两个条件： $\\frac{a}{b} + \\frac{c}{d}$ 为十进制下的整数或有限小数。 $1 \\le d \\le 10^9$ 在所有满足条件的非负整数对 $(c, d)$ 中，请求出 $c$ 最小的一对。$1 \\le a \\le b \\le 10^6$ 设 $b = 2^{x_1}5^{y_1}p$, $\\gcd(2^{x_1}5^{y_1}, p) = 1$。 设 $d = 2^{x_2}5^{y_2}q$, $\\gcd(2^{x_2}5^{y_2}, q) = 1$。 $$\\frac{a}{b} + \\frac{c}{d} = \\frac{ad + bc}{bd}= \\frac{\\frac{ad}{pq} + \\frac{bc}{pq}}{2^{x_1+x_2}5^{y_1+y_2}}= \\frac{w}{2^{x_1+x_2}5^{y_1+y_2}}$$ \\begin{aligned}w &amp;= \\frac{ad+bc}{pq} \\\\wpq &amp;= ad + bc \\\\\\end{aligned} 由裴蜀定理，关于未知数 $x, y$ 的方程 $ax + by = m$ 有整数解的条件是 $\\gcd(a, b) | m$。 将 $w, c$ 看作未知数，方程有解的条件是 $\\gcd(pq, b) | ad$，即 $\\gcd(pq, 2^{x_1}5^{y_1}p) | a 2^{x_2}5^{y_2}q$，即 $p | aq$。因为 $\\gcd(a, b) = 1$，所以 $\\gcd(a, p) = 1$，即 $p | q$。 将 $w, a$ 看作未知数，方程有解的条件是 $\\gcd(pq, d) | bc$，即 $\\gcd(pq, 2^{x_2}5^{y_2}q) | 2^{x_1}5^{y_1}pc$，即 $q | cp$。因为 $\\gcd(c, d) = 1$，所以 $\\gcd(c, q) = 1$，即 $q | p$。 故 $p = q$。 问题转化为，求关于未知数 $c, d, w$ 的方程 $ad + bc = wp^2$ 的 $c$ 最小的解。 枚举 $d$。转化为 $bc + ad \\equiv 0 (\\bmod p^2)$ 就可以直接套哥哥的板子了（） Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778int p2[31], p5[14];i64 exgcd(i64 a, i64 b, i64 &amp;x, i64 &amp;y) { if (b == 0) { x = 1; y = 0; return a; } i64 g = exgcd(b, a % b, y, x); y -= a / b * x; return g;}// ax + b = 0 (mod m)std::pair&lt;i64, i64&gt; sol(i64 a, i64 b, i64 m) { assert(m &gt; 0); b *= -1; i64 x, y; i64 g = exgcd(a, m, x, y); if (g &lt; 0) { g *= -1; x *= -1; y *= -1; } if (b % g != 0) { return {-1, -1}; } x = x * (b / g) % (m / g); if (x &lt; 0) { x += m / g; } return {x, m / g};}void solve() { int a; cin &gt;&gt; a; int b; cin &gt;&gt; b; int p = b; while (p % 2 == 0) p /= 2; while (p % 5 == 0) p /= 5; pii ans = {inf, inf}; for (int x : p2) { for (int y : p5) { int d = p * x * y; if (d &gt; 1'000'000'000) break; auto [c, g] = sol(b, a * d, p * p); // cout &lt;&lt; c &lt;&lt; ' ' &lt;&lt; d &lt;&lt; '\\n'; // cout &lt;&lt; &quot;bc = &quot; &lt;&lt; b * c; // cout &lt;&lt; &quot;, ad = &quot; &lt;&lt; a * d; // cout &lt;&lt; &quot;, p = &quot; &lt;&lt; p &lt;&lt; '-'; // cout &lt;&lt; c &lt;&lt; ' ' &lt;&lt; d &lt;&lt; '\\n'; if (c &lt; ans.fi) ans = {c, d}; } } cout &lt;&lt; ans.fi &lt;&lt; ' ' &lt;&lt; ans.se &lt;&lt; '\\n';}signed main() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); p2[0] = p5[0] = 1; for (int i = 1; i &lt;= 30; i++) p2[i] = p2[i - 1] * 2LL; for (int i = 1; i &lt;= 13; i++) p5[i] = p5[i - 1] * 5LL; int T; cin &gt;&gt; T; for (; T--; solve()); // solve(); return 0;} E 合成大西瓜Code >folded12345678910111213141516171819202122232425262728293031323334void solve() { int n; cin &gt;&gt; n; int m; cin &gt;&gt; m; vector&lt;int&gt; a(n); for (auto &amp;x : a) cin &gt;&gt; x; vector&lt;int&gt; ind(n); vector&lt;vector&lt;int&gt;&gt; g(n); for (int i = 0; i &lt; m; i++) { int u, v; cin &gt;&gt; u &gt;&gt; v; u--, v--; g[u].eb(v), g[v].eb(u); ind[u]++, ind[v]++; } int ans = 0; pii res = {0, 0}; for (int i = 0; i &lt; n; i++) { if (ind[i] == 1) { if (a[i] &gt;= res.fi) { res = {a[i], res.fi}; } else if (a[i] &gt; res.se) { res.se = a[i]; } } else ans = max(ans, a[i]); } if (res.se != inf) ans = max(ans, res.se); cout &lt;&lt; ans;} J 骰子Code >folded12345678void solve() { int n; cin &gt;&gt; n; int m; cin &gt;&gt; m; if (n &gt;= 2 and m &gt;= 2) { cout &lt;&lt; n * m * 6LL &lt;&lt; '\\n'; return; }} K 小 C 的神秘图形Code >folded1234567891011121314void solve() { int n; cin &gt;&gt; n; string s, t; cin &gt;&gt; s &gt;&gt; t; for (int i = 0; i &lt; n; i++) { if (s[i] == '1' or t[i] == '1') { continue; } else { cout &lt;&lt; &quot;0&quot;; return; } } cout &lt;&lt; &quot;1&quot;;}","link":"/vp-2024-ccpc-%E9%87%8D%E5%BA%86/"},{"title":"AtCoder Beginner Contest 363","text":"打完球回来边开会边打着玩的，然后降智了。 比赛链接 Problems AC A. Piling Up ○ B. Japanese Cursed Doll ○ C. Avoid K Palindrome 2 ○ D. Palindromic Number ⊕ E. Sinking Land ⊕ F. Palindromic Expression ⊕ G. Dynamic Scheduling ACode BCode CCode D 如果非负整数 $X$ 的十进制表示（没有前导零）是回文数，则该数称为回文数。例如， $363$ 、 $12344321$ 和 $0$ 都是回文数。 找出第 $N$ 个最小回文数。 赛时弱智了，没调出来。确定好前面的了以后，没有注意到直接减 n 即可。 Code E 有一个大小为 $H \\times W$ 的岛屿，四周环绕着大海。 岛屿被分成 $H$ 行、 $W$ 列的 $1 \\times 1$ 个区块，上部第 $i$ 行、左部第 $j$ 列的区块的海拔（相对于当前海平面）为 $A_{i,j}$ 。 从现在开始，海平面每年上升 $1$ 。 此处，垂直或水平相邻于海洋的区块或沉入海中的区块，其海拔 不大于 海平面，将沉入海中。在这里，当一个部分新近沉入海中时，任何垂直或水平相邻且海拔不高于海平面的部分也将同时沉入海中，这个过程对新沉入海中的部分重复进行。 对于每个 $i=1,2,\\ldots, Y$ ，找出从现在起 $i$ 年后仍高于海平面的岛屿面积。 赛时弱智了，没调出来。开局把最外面一圈入队的时候，四个角不小心重复入队了。 Code F问题陈述 给定一个整数 $N$ 。打印一个满足以下所有条件的字符串 $S$ 。如果不存在这样的字符串，则打印 -1。 $S$ 是一个长度在 $1$ 和 $1000$ 之间的字符串，包括字符 1、2、3、4、5、6、7、8、9 和 *（乘法符号）。 $S$ 是回文。 $S$ 的第一个字符是数字。 当按公式求值时， $S$ 的值等于 $N$ 。 从两边往中间搜索。 Code","link":"/atcoder-beginner-contest-363/"},{"title":"AtCoder Beginner Contest 348","text":"Toyota Programming Contest 2024#4（AtCoder Beginner Contest 348） 年轻人的第一场 abc 2024/04/06 打的，2024/06/20 补了下题解 比赛链接 Problems AC A. Penalty Kick ○ B. Farthest Point ○ C. Colorful Beans ○ D. Medicines on Grid ○ E. Minimize Sum of Distances ○ F. Oddly Similar ⊕ G. Max (Sum - Max) ⊕ AA - Penalty Kick BB - Farthest Point CC - Colorful Beans D 二维网格，起点终点，有障碍物，有一些格子有药，药的作用是将体力值变为 c[i][j]，可以选择用不用初始起点，体力值为 0，问能否走到终点。 &lt;censored&gt;就一个点 WA 有点搞心态 采用类似 SPFA 的写法 D - Medicines on Grid EE - Minimize Sum of Distances F 有 n 个长 m 的序列，问有多少对序列“相似”假如两个序列相似，说明有奇数个位置相同n &lt;= 2e3 朴素做法是 O(n^2m)，（吸氧能跑过 at 的机子） 这种 bool 数组想办法搞搞 bitset 优化 $cnt[j][k]$ 是一个大小为 n 的 bitset，假如 a[i][j] = k，则 cnt[j][k][i] = 1 枚举每一行，把每一列的情况 xor 在一起，统计一下 xor 结果中 1 的个数 F - Oddly Similar G 您有两个整数序列 $A$ 和 $B$ ，长度为 $N$ 。对于 $k = 1, 2, \\ldots, N$ ，解决以下问题： 考虑在 $1$ 和 $N$ 之间选择 $k$ 个不同的整数（含）。让 $S$ 成为所选整数的集合。找出 $\\displaystyle (\\sum_{i \\in S} A_i) - \\max_{i \\in S} B_i$ 的最大值。 赛后听说是 2023 CCPC 网络赛的原题 QOJ # 7523. Partially Free Meal Tutorial 首先考虑 $k$ 固定时的答案。将所有盘子按照 $b$ 从小到大排序，枚举第 $x (k \\le x \\le n)$ 个盘子作为 $\\max_{i \\in S} B_i$，那么剩下要选的 $k - 1$ 个盘子就是 前 $x - 1$ 个盘子中最大的 $k - 1$ 个。给定 $k$ 和 $x$，可以通过可持久线段树在 $O(log n)$ 的时间内求出对应方案的值 $w(k, x)$。 接下来精彩的一步是证明决策单调性：随着 $k$ 增大，最优情况下的 $B_{max}$ 是非严格单调递增的。 感性理解一下，当你选的数越来越多，你的 $B_{max}$ 会不得不越来越大。因为假如 k’ = k + 1, 那么假如 $B_{max}$ 变小了。意味着你放弃了那个最大的，改选了一个小一点的数。那这样的话他在 k 的时候应该就不是最优的了。 令 $f(k)$ 表示使 $k$ 取到最优解的 $x$。对于两个不同的决策 $x, y (x &lt; y)$，若 $w(k, x) \\leq w(k, y)$，那么增大 $k$ 之后由于 $y$ 的可选择范围严格包含了 $x$ 的可选择范围，因此 $y$ 新选的 $a$ 值一定不小于 $x$ 所选的，即 $w(k′, x) \\leq w(k′, y)$ 对于 $k \\leq k′ \\leq n$ 恒成立。由此可得 $f (1) \\leq f (2) \\leq f (3) \\leq \\ldots \\leq f(n)$，最优决策具有单调性，可以分治求解，共需计算 $O(n log n)$ 个 $w(k, x)$ 的值。 Code","link":"/atcoder-beginner-contest-348/"},{"title":"VP 2024 ICPC 武汉邀请赛","text":"VP Date 2024/5/17 2024 ICPC National Invitational Collegiate Programming Contest, Wuhan Site 比赛链接 Problems AC A. Shaking Trees B. Countless Me ○ C. TreeBag and LIS D. ICPC ⊕ E. Boomerang ⊕ F. Custom-Made Clothes ○ G. Pack H. Wings of Crystals I. Cyclic Apple Strings ○ J. Gensokyo Autobahn K. Party Games ○ L. Magic Fairies M. Merge ⊕ ACode B 给定一个长度为 $n$ 的非负整数数组 $a_i$ 可以进行如下操作至多 $n$ 次： 选择 $i, j, x$ ，令 $a_i \\leftarrow a_i+x, a_j \\leftarrow a_j-x$ 最小化操作后 $a_1\\left|a_2\\right| \\ldots \\mid a_n$ 的值。 很好的思维题。这个操作是不会改变序列的 sum 的。那么在 sum 不变的情况下我们是否能随意分配每个数的值呢？感性理解一下，显然是可以的。那么就是一个从高位向低位的贪心了 Code D 在 $n$ 个排成一列的格子中, 第 $i$ 格子上都有一个数 $a_i$ 。对所有 $1 \\leqslant s \\leqslant n, 1 \\leqslant t \\leqslant 2 n$ 求出从第 $s$ 个格子出发，每次移动至任意一个相邻的格子，移动 $\\mathrm{t}$ 次后到达过的格子上数的和的最大值。 显然的是最优的走法下改变方向至多一次 g[i][j] 表示从 $i$ 点出发，向右移动不超过 $j$ 次的和的最大值 f[i][j] 表示从 $i$ 点出发，先向左走，然后向右走，加起来移动不超过 $j$ 次的和的最大值 假设向左走了 $x$ 步折返 $$f[i][j] = \\max_{x = 0}^{i - 1}\\left{g[i - x][j - x]\\right}$$ 将 $i$ 换成 $i + 1$，$j$ 换成 $j + 1$ $$f[i + 1][j + 1] = \\max_{x = 0}^{i}\\left{g[i + 1 - x][j + 1 - x]\\right}$$ 将 $x$ 换成 $x + 1$ $$f[i + 1][j + 1] = \\max_{x = -1}^{i - 1}\\left{g[i - x][j - x]\\right}$$ 代换 $$f[i + 1][j + 1] = \\max\\left{f[i][j], g[i + 1][j + 1]\\right}$$ 于是我们可以得到 $$f[i][j] = \\max\\left{f[i - 1][j - 1], g[i][j]\\right}$$ 从而我们可以 $O(n^2)$ 枚举状态，$O(1)$ 转移 对于另一个方向，翻转数组再做一遍 dp 即可 E 给定一个 $n$ 个节点的树，根节点为 $r$, 设 $V(r, t)={v \\mid \\operatorname{dis}(r, v) \\leqslant t}$, 其中 $\\operatorname{dis}(u, v)$ 表示树上两点 $u$ 和 $v$ 间的唯一简单路径的边数。 再给定一个 $t_0$，对每个 $k$，你需要选择一个点 $r_0$，定义 $$V^{\\prime}\\left(r_0, t\\right)=\\left{v \\mid \\operatorname{dis}\\left(r_0, v\\right) \\leqslant k\\left(t-t_0\\right)\\right}$$ 。 找到一个最小的 $t$, 使得 $V(r, t) \\subseteq V^{\\prime}\\left(r_0, t\\right)$ 。 首先你可以注意到，对于每个可能是答案的 $t$，选择子树 $V(r, t)$ 的直径中点作为 $r^{\\prime}$ 应当是最优的。 这意味着，我们需要动态地维护每个时刻的树直径。这里有一个经典的 trick：假如当前树的直径端点是 $(u, v)$，当新加入一个节点时，新直径的端点只有可能是 $(u, v)$, $(u, x)$, $(v, x)$ 三者其一。 假设我们维护出了时刻 $t$ 子树 $V(r, t)$ 的直径长度 $d$。这个时刻合法需要满足 $(d + 1) / 2 \\le k * (t - t_0)$。考虑到 $t$ 是有单调性的，所以对于每个 k 二分这个 t 就行了 Code F 有一个 $n \\times n$ 的正整数方阵 $$a_{i, j}\\left(1 \\leq a_{i, j} \\leq n \\times n\\right)$$, 其满足: 若 $i&gt;1$, 则 $$a_{i, j} \\geq a_{i-1, j}$$ 若 $j&gt;1$, 则 $$a_{i, j} \\geq a_{i, j-1}$$ 我只知道方阵的大小 $n$, 但不知道其中的元素内容, 但是我可以询问方阵的某个位置 $a_{i, j}$ 是否不大于某个整数 $x$ 。 我需要使用不超过 50000 次询问找出 $$\\left{a_{i, j}\\right}$$ 中的第 $k$ 大值。 对于一个数 mid，小于等于他的数在左上角的某一块区域，并且有一条折线分割 二分答案，O(n) check 有多少个数小于等于他 Code ICode K找规律题 M 给定由 n 个数组成的序列，每次操作可以合并大小相差为 1 的数字并得到他们的和，求任意次操作后剩下的数的最大字典序 考虑到两个数相差为 1 的话意味着奇偶性不同，那么每次合并的都是一个奇数与一个偶数，并得到一个奇数。 设 $x$ 为当前序列的最大偶数，我们只需要不断判断能否产生 $2x + 1$ 或 $2x - 1$ 即可。 如果要产生 $2x \\pm 1$，则需要判断能否产生 $x \\pm 1$，不难发现这是一个递归的过程，且最多 log 次。 Code","link":"/vp-2024-icpc-%E6%AD%A6%E6%B1%89%E9%82%80%E8%AF%B7%E8%B5%9B/"},{"title":"AtCoder Beginner Contest 382","text":"比赛链接 Problems AC A. Daily Cookie ○ B. Daily Cookie 2 ○ C. Kaiten Sushi ○ D. Keep Distance ○ E. Expansion Packs ⊕ F. Falling Bars ○ G. Tile Distance 3 A 签到Code >folded1234567891011121314151617void solve() { int n = read(); int k = read(); string s; cin &gt;&gt; s; int m = s.size(); for (int i = m - 1; i &gt;= 0 and k; i--) { if (s[i] == '@') { s[i] = '.'; k--; } } cout &lt;&lt; s;} B 签到Code >folded1234567891011121314151617void solve() { int n = read(); int k = read(); string s; cin &gt;&gt; s; int m = s.size(); for (int i = m - 1; i &gt;= 0 and k; i--) { if (s[i] == '@') { s[i] = '.'; k--; } } cout &lt;&lt; s;} C 签到Code >folded12345678910111213141516171819202122232425262728293031323334353637void solve() { int n = read(); int m = read(); vector&lt;int&gt; a(n + 1); for (int i = 1; i &lt;= n; i++) { a[i] = read(); } vector&lt;int&gt; b(m + 1); for (int i = 1; i &lt;= m; i++) { b[i] = read(); } using pii = std::pair&lt;int, int&gt;; #define fi first #define se second std::priority_queue&lt;pii&gt; q; for (int i = 1; i &lt;= m; i++) { q.ep(b[i], i); } vector&lt;int&gt; c(m + 1, -1); // cout &lt;&lt; q.size() &lt;&lt; '\\n'; for (int i = 1; i &lt;= n; i++) { while (!q.empty() and q.top().fi &gt;= a[i]) { // cout &lt;&lt; q.top().fi &lt;&lt; &quot; &quot; &lt;&lt; q.top().se &lt;&lt; '\\n'; c[q.top().se] = i; // q.pop(); q.pop(); } } for (int i = 1; i &lt;= m; i++) { cout &lt;&lt; c[i] &lt;&lt; '\\n'; }} D 签到Code >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051void solve() { int n = read(); int m = read(); int ans = 0; vector&lt;int&gt; a(n + 1); auto dfs1 = [&amp;](auto&amp;&amp; self, int now) { if (now == n + 1) { ans++; return; } if (now == 1) { for (int i = 1; i &lt;= m; i++) { a[now] = i; if (i + (n - now) * 10 &lt;= m) self(self, now + 1); } } else { for (int i = max(1, a[now - 1] + 10); i &lt;= m; i++) { a[now] = i; if (i + (n - now) * 10 &lt;= m) self(self, now + 1); } } }; dfs1(dfs1, 1); a.assign(n + 1, 0); cout &lt;&lt; ans &lt;&lt; '\\n'; auto dfs2 = [&amp;](auto&amp;&amp; self, int now) { if (now == n + 1) { for (int i = 1; i &lt;= n; i++) { cout &lt;&lt; a[i] &lt;&lt; &quot; \\n&quot;[i == n]; } return; } if (now == 1) { for (int i = 1; i &lt;= m; i++) { a[now] = i; if (i + (n - now) * 10 &lt;= m) self(self, now + 1); } } else { for (int i = max(1, a[now - 1] + 10); i &lt;= m; i++) { a[now] = i; if (i + (n - now) * 10 &lt;= m) self(self, now + 1); } } }; dfs2(dfs2, 1);} E 期望 DP可以通过 dp 得到 $dp_i$ 表示开一个卡包得到 $i$ 张牌的概率。 令 $f_i$ 表示得到 $i$ 张牌期望开的卡包数量。 $$f_i = 1 + \\sum_{j = 0}^{i - 1} f_{i - j} dp_j$$ \\begin{aligned}f_i &amp;= 1 + \\sum_{j = 0}^{i - 1} f_{i - j} \\cdot dp_j \\\\f_i &amp;= 1 + f_i \\cdot dp_0 + \\sum_{j = 1}^{i - 1} f_{i - j} \\cdot dp_j \\\\f_i (1 - dp_0) &amp;= 1 + \\sum_{j = 1}^{i - 1} f_{i - j} \\cdot dp_j \\\\f_i &amp;= \\frac{1 + \\sum_{j = 1}^{i - 1} f_{i - j} \\cdot dp_j}{1 - dp_0} \\\\\\end{aligned} Code123456789101112131415161718192021222324252627282930313233343536373839void solve() { int n = read(); int m = read(); // int ans = 0; vector&lt;double&gt; a(n + 1); for (int i = 1; i &lt;= n; i++) { a[i] = read() * 1.0 / 100; } vector&lt;double&gt; dp(n + m + 1); dp[0] = 1; for (int i = 1; i &lt;= n; i++) { vector&lt;double&gt; ndp(n + 1 + m); ndp[0] = dp[0] * (1 - a[i]); for (int j = 1; j &lt;= i; j++) { ndp[j] = dp[j] * (1 - a[i]) + dp[j - 1] * a[i]; } dp = std::move(ndp); } // for (int i = 0; i &lt;= n; i++) { // cout &lt;&lt; dp[i] &lt;&lt; &quot; \\n&quot;[i == n]; // } vector&lt;double&gt; f(m + n + 1); for (int i = 0; i &lt;= m; i++) { double t = 1; for (int j = 1; j &lt; i; j++) { t += dp[j] * f[i - j]; } f[i] = t / (1 - dp[0]); } // cout &lt;&lt; f[m]; printf(&quot;%.16f&quot;, f[m]);} F 线段树Notice: 线段树带区间操作的时候必须要加懒标记，否则时间复杂度会退化。 Code >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;using i64 = long long;// #define int i64#define pb push_back#define ep emplace#define eb emplace_backusing std::cerr;using std::max, std::min, std::swap, std::array;using std::cin, std::cout, std::string, std::vector;int read(int x = 0, int f = 0, char ch = getchar()) { while (ch &lt; 48 or 57 &lt; ch) f = ch == 45, ch = getchar(); while(48 &lt;= ch and ch &lt;= 57) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;}const int N = 2e5 + 5;struct SGT { #define ls (p &lt;&lt; 1) #define rs (p &lt;&lt; 1 | 1) #define mid (l + r &gt;&gt; 1) int mx[N &lt;&lt; 2], tag[N &lt;&lt; 2]; void pushup(int p) { mx[p] = max(mx[ls], mx[rs]); } void pushdown(int p) { if (tag[p] == 0) return; mx[ls] = max(mx[ls], tag[p]); mx[rs] = max(mx[rs], tag[p]); tag[ls] = max(tag[ls], tag[p]); tag[rs] = max(tag[rs], tag[p]); tag[p] = 0; } int qry(int p, int l, int r, int ql, int qr) { if (ql &lt;= l and r &lt;= qr) { return mx[p]; } int res = 0; pushdown(p); if (ql &lt;= mid) res = max(res, qry(ls, l, mid, ql, qr)); if (mid &lt; qr) res = max(res, qry(rs, mid + 1, r, ql, qr)); pushup(p); return res; } void upd(int p, int l, int r, int ql, int qr, int x) { if (ql &lt;= l and r &lt;= qr) { mx[p] = max(mx[p], x); tag[p] = max(tag[p], x); return; } pushdown(p); if (ql &lt;= mid) upd(ls, l, mid, ql, qr, x); if (mid &lt; qr) upd(rs, mid + 1, r, ql, qr, x); pushup(p); }} sgt;void solve() { int h = read(); int w = read(); int n = read(); using tup = std::tuple&lt;int, int, int&gt;; vector&lt;vector&lt;tup&gt;&gt; a(h + 1); for (int i = 1; i &lt;= n; i++) { int r = h - read() + 1; int c = read(); int l = read(); // cerr &lt;&lt; r &lt;&lt; &quot; &quot; &lt;&lt; c &lt;&lt; &quot; &quot; &lt;&lt; c + l - 1 &lt;&lt; '\\n'; a[r].eb(c, c + l - 1, i); } vector&lt;int&gt; ans(n + 1); for (int i = 1; i &lt;= h; i++) { for (auto [l, r, idx] : a[i]) { // cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; sgt.qry(1, 1, w, l, r); ans[idx] = sgt.qry(1, 1, w, l, r) + 1; sgt.upd(1, 1, w, l, r, ans[idx]); // cout &lt;&lt; &quot; &quot; &lt;&lt; ans[idx] &lt;&lt; '\\n'; } } for (int i = 1; i &lt;= n; i++) { // cout &lt;&lt; ans[i] &lt;&lt; &quot;\\n&quot;; cout &lt;&lt; h - ans[i] + 1 &lt;&lt; &quot;\\n&quot;; }}signed main() { // for (int T = read(); T--; solve()); solve(); return 0;}","link":"/atcoder-beginner-contest-382/"},{"title":"PSY2013 Lecture 01 Notes","text":"PSY2013 Research Methods in Psychology Ch01 Scientific Thinking in Psychology Ch02 Ethics in Psychological Research Scientific Thinking: Learning Objectives 科学思维：学习目标 Defend the need for a research methods course for psychology students 为心理学学生开设研究方法课程的必要性辩护 Foundation for understanding other psychology courses, which are based on research 研究方法课程为理解其他基于研究的心理学课程奠定基础 Explain how the overall purpose of a methods course differs from other psychology courses 解释方法课程的总体目的如何与其他心理学课程不同 Methods course teaches the process of acquiring knowledge about psychological phenomena 方法课程教授获取心理现象知识的过程 Identify and evaluate nonscientific ways of knowing about things in the world – authority, reasoning, and experience 识别和评估关于世界事物的非科学认知方式——权威、推理和经验 Describe the attributes of science as a way of knowing 描述科学作为一种认知方式的属性 Assumes determinism and discoverability 假定决定论和可发现性 Systematic observations, public knowledge, data-based conclusions 系统的观察，公开的知识，基于数据的结论 Distinguish science from pseudoscience and recognize the attributes of pseudoscientific thinking 区分科学与伪科学，并识别伪科学思维的属性 Pseudoscience associates itself with real science, relies on anecdotal evidence, sidesteps falsification 伪科学与真正的科学联系在一起，依赖轶事证据，回避证伪 Describe the main goals of research in psychology and relate them to various research strategies to be encountered later in the book 描述心理学研究的主要目标，并将其与书中稍后提到的各种研究策略联系起来 Ways of Knowing 认知方式 Authority 权威 Basing beliefs on what we are told by others (e.g., parents, teachers, textbooks) 基于他人告知的内容建立信念（例如，父母、老师、教科书） Problem: authorities can be wrong 问题：权威也可能是错误的 Reason / Logical Argument 推理 / 逻辑论证 Use of reason via conversation to come to a consensus 通过对话使用推理达成共识 Problems: initial assumptions may be incorrect; valid arguments can lead to opposite conclusions 问题：初始假设可能是错误的；有效的论证可能导致相反的结论 Empiricism / Direct Experience 经验主义 / 直接经验 Process of learning via direct observation or experience 通过直接观察或经验学习的过程 Problems: experiences are limited to our interpretations; influenced by social cognition biases 问题：经验受到我们解释的限制；受到社会认知偏见的影响 Confirmation Bias 确认偏见: Tendency to seek information that supports one’s beliefs Belief Perseverance 信念固守: Holding onto beliefs despite contradictory evidence Availability Heuristic 可得性启发: Overestimating the frequency of memorable events Science as a Way of Knowing 科学作为一种认知方式 Attributes of Science 科学的属性 Assumes determinism (events have causes) and discoverability (causes can be discovered) 假定决定论（事件有原因）和可发现性（原因可以被发现） Systematic observations, less affected by bias 系统的观察，受偏见影响较小 Produces public knowledge (objectivity criterion) 产生公开的知识（客观性标准） Produces data-based conclusions 产生基于数据的结论 Produces tentative conclusions (subject to future research) 产生暂定结论（取决于未来的研究） Asks answerable questions (empirical questions) 提出可回答的问题（实证问题） Develops theories that can be falsified (falsification criterion) 发展可证伪的理论（证伪标准） Distinguishing Science from Pseudoscience 区分科学与伪科学 Pseudoscience associates with real science, relies on anecdotal evidence, avoids falsification 伪科学与真正的科学联系在一起，依赖轶事证据，回避证伪 The Goals of Research in Psychology 心理学研究的目标 Describe 描述 Identify regularly occurring sequences of psychological events 识别经常发生的心理事件序列 Predict 预测 Psychological events follow certain “laws” that are regular and predictable 心理事件遵循某些规律，这些规律是规律性的和可预测的 Explain 解释 Psychological events are explained in terms of their relationship to other factors 心理事件通过其与其他因素的关系来解释 Causal explanations are ideal 因果解释是理想的 Apply 应用 Science informs real-world applications of psychological events 科学为心理事件的现实应用提供信息 Ethics in Psychology: Learning Objectives 心理学伦理：学习目标 Describe the origins of the APA ethics code 描述APA伦理守则的起源 Articulate the code’s five general principles, especially as they apply to research in psychology 阐明该守则的五项一般原则，尤其是在心理学研究中的应用 Describe the role of the Institutional Review Board (IRB) in the research process and what needs to be done by the researcher to achieve IRB approval of research 描述机构审查委员会（IRB）在研究过程中的作用，以及研究人员需要做什么才能获得IRB批准 Explain when research proposals are exempt from IRB review, eligible for expedited review, or in need of a full formal review 解释何时研究提案可以免于IRB审查、何时可以加速审查、何时需要全面正式审查 Explain why the decision-making processes of IRBs have occasionally been controversial 解释为什么IRB的决策过程有时具有争议 Identify the essential features of a researcher’s ethical responsibilities when completing psychological research using adult human participants 识别研究人员在使用成人参与者进行心理学研究时的基本伦理责任 Describe historical examples of research that raised serious ethical questions 描述引发严重伦理问题的历史研究实例 Identify the ethical questions involved when completing research using children and those from special populations (e.g., prisoners, nursing home residents) 识别在使用儿童和特殊人群（如囚犯、养老院居民）进行研究时涉及的伦理问题 Describe how the ethics code applies to research that involves using the Internet 描述伦理守则如何适用于涉及使用互联网的研究 Describe the arguments for and against the use of animals in psychological research 描述在心理学研究中使用动物的支持和反对论点 Identify the essential features of a researcher’s ethical responsibility when completing psychological research using animal subjects 识别在使用动物作为受试者进行心理学研究时研究人员的基本伦理责任 Identify the varieties of scientific dishonesty, how it can be detected, and understand some of the reasons why misconduct sometimes occurs in science 识别科学不诚实的各种形式，如何检测，并理解为什么有时会在科学中发生不端行为 Ethics Code 伦理守则 What is ethics? 什么是伦理？ Standards governing the conduct of a person or the members of a profession. 规范个人或职业成员行为的标准。 Morality are guidelines that affect individuals, and ethics are guidelines for entire larger groups. 道德是影响个人的准则，伦理是影响整个更大群体的准则。 Law sets minimum standards of behavior while ethics sets maximum standards. 法律设定最低行为标准，而伦理设定最高行为标准。 Why do we need ethical guidelines in psychology? 为什么我们需要心理学的伦理指南？ Obliged by law, morality, and social norm to follow basic ethical principles in the treatment of humans and other animals. 法律、道德和社会规范要求我们在对待人类和其他动物时遵循基本伦理原则。 Expected to produce research that is meaningful and helpful to society. 期望产出对社会有意义和有帮助的研究。 Developing the APA Code of Ethics 制定APA伦理守则 Historical cases of ethically questionable research 伦理上有争议的历史研究案例 Watson &amp; Rayner (1920) – Scaring Little Albert 恐吓小阿尔伯特 McGraw (1941) – Effects of repeated pinpricks 反复针刺的效果 Dennis (1941) – Raising children in isolation 在隔离环境中抚养孩子 First code → 1953 第一版守则 → 1953 Hobbs committee 霍布斯委员会 Critical incidents technique: Surveying APA members for examples of unethical conduct. 关键事件技术：调查APA成员关于不道德行为的例子。 APA Ethical Principles of Psychologists and Code of Conduct → 2002 (2010 amendments) APA心理学家伦理原则和行为守则 → 2002（2010年修订） APA Ethical Principles of Psychologists and Code of Conduct APA心理学家伦理原则和行为守则 5 General Principles 五项一般原则 Beneficence and Nonmaleficence 有益与无害原则 Constantly weigh costs &amp; benefits; protect from harm; produce for the greatest good. 不断权衡成本和收益；保护免受伤害；产生最大的利益。 Fidelity and Responsibility 诚信与责任 Be professional; constantly be aware of responsibility to society. 保持专业；不断意识到对社会的责任。 Integrity 正直 Be scrupulously honest in all aspects of the research enterprise. 在研究工作各个方面都要严格诚实。 Justice 公正 Always treat people fairly &amp; maintain a level of expertise. 始终公平对待他人并保持专业水平。 Respect for People’s Rights and Dignity 尊重人权和尊严 Safeguard individual rights; protect rights of privacy and confidentiality. 保护个人权利；保护隐私和保密权利。 Ethical Guidelines for Research with Humans 人类研究的伦理指南 Weighing Benefits and Costs: The IRB 权衡收益与成本：IRB IRB = Institutional Review Board IRB = 机构审查委员会 Determines whether the project meets ethical guidelines. 确定项目是否符合伦理指南。 Key factor: degree of risk to subjects. 关键因素：对受试者的风险程度。 No risk 无风险: Could be exempt from review. 可能免于审查。 Minimal risk 最小风险: Eligible for expedited review. 适合加速审查。 At risk 有风险: Requires full review. 需要全面审查。 Informed Consent 知情同意 Sufficient information provided to research participants to decide whether to participate. 向研究参与者提供足够的信息，以决定是否参与。 Historical examples of poor consent: Tuskegee syphilis study: Withheld treatment without participants’ knowledge. 塔斯基吉梅毒研究：在参与者不知情的情况下扣留治疗。 Willowbrook hepatitis study 威洛布鲁克肝炎研究 MK-ULTRA (CIA &amp; LSD) MK-ULTRA（CIA和LSD） Deception in Research 研究中的欺骗 Desire to have subjects act naturally. 希望受试者自然表现。 Example: Milgram obedience study (1963). 例子：米尔格伦服从研究（1963）。 No consent needed in some circumstances (e.g., some survey, educational, archival, and observational research). 在某些情况下无需同意（例如，一些调查、教育、档案和观察研究）。 Treating Participants Well 善待参与者 Debriefing: Post-experimental explanation of the study’s purpose. 事后解释：解释研究的目的。 Dehoaxing and desensitizing participants. 揭露真实目的和减少参与者的敏感性。 Consent with Special Populations 特殊人群的同意 Children: Parental assent also needed. 儿童：需要父母的同意。 Avoid feelings of coercion. 避免强迫感。 Ethical Guidelines for Research with Animals 动物研究的伦理指南 Animal Rights 动物权利 Using animals in psychological research aids both humans and animals. 在心理学研究中使用动物有助于人类和动物。 APA Code for Animal Research APA动物研究伦理守则 Justifying the study. 研究的合理性。 Cost-benefit analysis. 成本收益分析。 Caring for the animals (expertise with species). 照顾动物（物种专业知识）。 Using animals for educational purposes: Minimize use. 为教育目的使用动物：减少使用。 Scientific Fraud 科学欺诈 Plagiarism 剽窃 Unethical representation of someone else’s ideas or words as one’s own. 不道德地将他人的思想或文字作为自己的代表。 Falsifying Data 伪造数据 Explicit effort to misrepresent data. 明确努力歪曲数据。 Varying degrees of misconduct. 不同程度的不端行为。 Summary 总结 Psychology is a science that adheres to the assumptions and goals of science. 心理学是一门遵循科学假设和目标的科学。 Science distinguishes itself from pseudoscience by being systematic, empirical, data-driven, tentative, and falsifiable. 科学通过系统性、实证性、数据驱动、暂定性和可证伪性区分自己与伪科学。 As psychological researchers, we adhere to a Code of Ethics regarding research with humans and animals. 作为心理学研究人员，我们遵循关于人类和动物研究的伦理守则。 The APA code and IRBs guide our decisions and actions in conducting research ethically, responsibly, and with integrity. APA守则和IRB指导我们在进行研究时的决策和行动，以确保伦理、责任和诚信。","link":"/psy2013-lecture-01-notes/"},{"title":"Singular Value Decomposition","text":"SVD，全称为奇异值分解（Singular Value Decomposition），是一种在数值线性代数中广泛使用的矩阵分解技术。SVD 将一个矩阵分解成三个特定的矩阵的乘积，可以用于许多应用领域，包括信号处理、统计分析、图像处理和推荐系统等。 Review: Eigendecomposition我们首先回顾下特征值和特征向量的定义如下： $$A x=\\lambda x$$ 其中 $\\mathrm{A}$ 是一个 $n \\times n$ 的实对称矩阵, $x$ 是一个 $n$ 维向量, 则我们说 $\\lambda$ 是矩阵 $\\mathrm{A}$ 的一个特征值, 而 $x$ 是矩阵 $\\mathrm{A}$ 的特征值 $\\lambda$ 所对应的特征向量。 求出特征值和特征向量有什么好处呢? 就是我们可以将矩阵A特征分解。如果我们求出了矩阵A的 $n$ 个特征值 $\\lambda_1 \\leq \\lambda_2 \\leq \\ldots \\leq \\lambda_n$ ，以及这 $n$ 个特征值所对应的特征向量 ${w_1, w_2, \\ldots w_n}$, ，如果这 $n$ 个特征向量线性无关，那么矩阵A就可以用下式的特征分解表示： $$A=W \\Sigma W^{-1}$$ 其中 $\\mathrm{W}$ 是这 $n$ 个特征向量所张成的 $n \\times n$ 维矩阵, 而 $\\Sigma$ 为这 $\\mathrm{n}$ 个特征值为主对角线的 $n \\times n$ 维矩阵。 一般我们会把 $\\mathrm{W}$ 的这 $n$ 个特征向量标准化，即满足 $\\left|w_i\\right|_2=1$ ，或者说 $w_i^T w_i=1$, 此时 $\\mathrm{W}$ 的 $n$ 个特征向量为标准正交基，满足 $W{ }^T W=I$, 即 $W^T=W^{-1}$, 也就是说 $\\mathrm{W}$ 为酉矩阵。 这样我们的特征分解表达式可以写成 $$A=W \\Sigma W^T$$ 注意到要进行特征分解, 矩阵A必须为方阵。那么如果A不是方阵, 即行和列不相同时, 我们还可以对矩阵进行分解吗? 答案是可以, 此时我们的SVD登场了。 SVD: DefinitionSVD也是对矩阵进行分解，但是和特征分解不同，SVD并不要求要分解的矩阵为方阵。假设我们的矩阵A是一个$m \\times n$的矩阵，那么我们定义矩阵A的SVD为： $$A=\\mathrm{U} \\Sigma \\mathrm{V}^{-1}$$ 其中$\\mathrm{U}$是一个$m \\times m$的矩阵，$\\Sigma$是一个$m \\times n$的矩阵，除了主对角线上的元素以外全为0，主对角线上的每个元素都称为奇异值，V是一个$n \\times n$的矩阵。$\\mathrm{U}$和$\\mathrm{V}$都是酉矩阵，即满足$\\mathrm{U}^{T}\\mathrm{U} = I, \\mathrm{V}^{T}\\mathrm{V} = I$。 求解矩阵 $\\mathrm{V}$如果我们将A的转置和A做矩阵乘法，那么会得到$n \\times n$的一个方阵$(A^TA)$。既然是方阵，那么我们就可以进行特征分解，得到的特征值和特征向量满足下式： $$(A^TA)v_i = \\lambda_i v_i$$ 这样我们就可以得到矩阵$(A^TA)$的n个特征值和对应的n个特征向量$v$了。将$(A^TA)$的所有特征向量张成一个$n \\times n$的矩阵$\\mathrm{V}$，就是我们 SVD 公式里面的$\\mathrm{V}$矩阵了。一般我们将 $\\mathrm{V}$ 中的每个特征向量叫做 $\\mathrm{A}$ 的右奇异向量。 求解矩阵 $\\mathrm{U}$同理，对 $(AA^T)$ 如此操作，可以得到 $m \\times m$ 的矩阵 $\\mathrm{U}$。一般我们将 $\\mathrm{U}$ 中的每个特征向量叫做 $\\mathrm{A}$ 的左奇异向量。 求解 $\\Sigma$$$A=U\\Sigma V^T \\Rightarrow AV=U\\Sigma V^TV \\Rightarrow AV=U\\Sigma \\Rightarrow Av_i = \\sigma_i u_i \\Rightarrow \\sigma_i = Av_i / u_i$$ 解法的证明上面还有一个问题没有讲，就是我们说$(A^TA)$的特征向量组成的就是我们 SVD 中的 $\\mathrm{V}$ 矩阵，而$(AA^T)$的特征向量组成的就是我们 SVD 中的 $\\mathrm{U}$ 矩阵，这有什么根据吗？这个其实很容易证明，我们以 $\\mathrm{V}$ 矩阵的证明为例。 $$A=U\\Sigma V^T \\Rightarrow A^T=V\\Sigma^T U^T \\Rightarrow A^TA = V\\Sigma^T U^TU\\Sigma V^T = V\\Sigma^2V^T$$ 可以看出 $(A^TA)$的特征向量组成的就是我们 SVD 中的 $\\mathrm{V}$ 矩阵。同理，$(AA^T)$的特征向量组成的就是我们 SVD 中的 $\\mathrm{U}$ 矩阵。 进一步我们还可以看出我们的特征值矩阵等于奇异值矩阵的平方，也就是说特征值和奇异值满足如下关系： $$\\sigma_i = \\sqrt{\\lambda_i}$$ 性质对于奇异值,它跟我们特征分解中的特征值类似，在奇异值矩阵中也是按照从大到小排列，而且奇异值的减少特别的快，在很多情况下，前10%甚至1%的奇异值的和就占了全部的奇异值之和的99%以上的比例。也就是说，我们也可以用最大的k个的奇异值和对应的左右奇异向量来近似描述矩阵。也就是说： $$A_{m \\times n} = U_{m \\times m}\\Sigma_{m \\times n} V^T_{n \\times n} \\approx U_{m \\times k}\\Sigma_{k \\times k} V^T_{k \\times n}$$ 其中k要比n小很多。由于这个重要的性质，SVD可以用于PCA降维，来做数据压缩和去噪。 在 PCA 中的应用PCA和白化（Whitening）是一种预处理形式。在这种处理中，先对数据进行零中心化处理，然后计算协方差矩阵，它展示了数据中的相关性结构。 123# 假设输入数据矩阵X的尺寸为[N x D]X -= np.mean(X, axis = 0) # 对数据进行零中心化(重要)cov = np.dot(X.T, X) / X.shape[0] # 得到数据的协方差矩阵 数据协方差矩阵的第(i, j)个元素是数据第i个和第j个维度的协方差。具体来说，该矩阵的对角线上的元素是方差。还有，协方差矩阵是对称和半正定的。我们可以对数据协方差矩阵进行SVD（奇异值分解）运算。 1U,S,V = np.linalg.svd(cov) U的列是特征向量，S是装有奇异值的1维数组（S中元素是特征值的算术平方根）。为了去除数据相关性，将已经零中心化处理过的原始数据投影到特征基准上： 1Xrot = np.dot(X,U) # 对数据去相关性 注意U的列是标准正交向量的集合（范式为1，列之间标准正交），所以可以把它们看做标准正交基向量。因此，投影对应x中的数据的一个旋转，旋转产生的结果就是新的特征向量。如果计算Xrot的协方差矩阵，将会看到它是对角对称的。np.linalg.svd的一个良好性质是在它的返回值U中，特征向量是按照特征值的大小排列的。我们可以利用这个性质来对数据降维，只要使用前面的小部分特征向量，丢弃掉那些包含的数据没有方差的维度。 这个操作也被称为主成分分析（ Principal Component Analysis 简称PCA）降维： 1Xrot_reduced = np.dot(X, U[:,:100]) # Xrot_reduced 变成 [N x 100] 经过上面的操作，将原始的数据集的大小由[N x D]降到了[N x 100]，留下了数据中包含最大方差的100个维度。通常使用PCA降维过的数据训练线性分类器和神经网络会达到非常好的性能效果，同时还能节省时间和存储器空间。 最后一个在实践中会看见的变换是白化（whitening）。白化操作的输入是特征基准上的数据，然后对每个维度除以其特征值来对数值范围进行归一化。该变换的几何解释是：如果数据服从多变量的高斯分布，那么经过白化后，数据的分布将会是一个均值为零，且协方差相等的矩阵。该操作的代码如下： 123# 对数据进行白化操作:# 除以特征值 Xwhite = Xrot / np.sqrt(S + 1e-5) References 奇异值分解(SVD)原理与在降维中的应用 – 刘建平Pinard","link":"/singular-value-decomposition/"},{"title":"PSY2013 Lecture 04 Notes","text":"PSY2013 Research Methods in Psychology Ch05 Introduction to Experimental Research Ch06 Methodological Control in Experimental Research What is an Experiment? 什么是实验？ Experiment 实验 研究调查至少一个自变量 (IV) X 对至少一个因变量 (DV) Y 的影响，同时保持所有其他因素不变。 Independent Variable (IV) 自变量 (IV): The manipulated variable that is believed to be the cause. 被认为是原因的操作变量。 Dependent Variable (DV) 因变量 (DV): The measured variable that is the outcome. 结果的测量变量。 Extraneous Variables 外在变量: Factors held constant. 保持不变的因素。 Expanded Notes 扩展笔记: Woodworth’s ‘Columbia Bible’ (1938): First distinguished between independent and dependent variables in experiments and showed preference for experimental over correlational research. Woodworth 的《哥伦比亚圣经》(1938) 首次在实验中区分了自变量和因变量，并显示了对实验研究的偏好。 Correlation and Causation 相关性与因果关系 Correlation 相关性 Does X occur when Y also occurs? (X &lt;-&gt; Y) X 出现时 Y 是否也出现？ 例子：冰淇淋消费与溺水死亡；巧克力消费与诺贝尔奖。 Causation 因果关系 Does X cause Y? (X -&gt; Y) X 是否导致 Y？ 例子：锻炼是否导致健康？吸烟是否导致肺癌？ Expanded Notes 扩展笔记: Criterions for Causation 因果关系的标准 Association 关联: Two variables are observed to vary together. 两个变量被观察到一起变化。 Time Order 时间顺序: One variable comes first in time before the other variable. 一个变量在时间上先于另一个变量。 Nonspuriousness 非虚假性: Other possible explanations can be ruled out. 其他可能的解释可以排除。 Mechanism 机制: The process that creates a causal connection between two variables. 创造两个变量之间因果关系的过程。 The Logic of Experimental Research 实验研究的逻辑 John Stuart Mill’s Inductive Logic 约翰·斯图尔特·密尔的归纳逻辑 Method of Agreement 一致法 If X, then Y (sufficiency -&gt; X is sufficient for Y). 如果有 X，则有 Y（充分条件 -&gt; X 足以导致 Y）。 Method of Difference 差异法 If not X, then not Y (necessity -&gt; X is necessary for Y). 如果没有 X，则没有 Y（必要条件 -&gt; X 是 Y 所必需的）。 Together, these methods enable us to conclude, with a high degree of confidence (but not absolute certainty), that X causes Y. 结合这些方法，我们可以高度确信（但不是绝对确定）X 导致 Y。 Essential Features of Experimental Research 实验研究的基本特征Establishing Independent Variables (IVs) 确立自变量 (IV) Types of IVs 自变量的类型 Situational 情境性: Different conditions or contexts. 不同的条件或情境。 Task 任务性: Different tasks participants perform. 参与者执行的不同任务。 Instructional 指导性: Different instructions given to participants. 给参与者的不同指示。 Experimental Group 实验组 Given treatment. 接受处理。 Control Group 控制组 Treatment withheld. 不接受处理。 Expanded Notes 扩展笔记: Manipulate Situational IV 操作情境性自变量 Example: Personal space invasions in the lavatory by Middlemis (1976). 例子：Middlemis (1976) 在洗手间的个人空间侵犯实验。 Manipulate Task IV 操作任务性自变量 Example: Bushman and Anderson (2009) study on video games. 例子：Bushman 和 Anderson (2009) 关于电子游戏的研究。 Manipulate Instructional IV 操作指导性自变量 Example: Priming study by Dijksterhuis and Knippenberg (1998). 例子：Dijksterhuis 和 Knippenberg (1998) 的启动研究。 Controlling Extraneous Variables (EVs) 控制外在变量 (EV) Confounds 混淆变量 Any uncontrolled extraneous variable. 任何未控制的外在变量。 Results could be due to IV or due to confound. 结果可能是由于自变量或混淆变量。 Expanded Notes 扩展笔记: Example 例子 Distributed practice study with different study schedules. 不同学习时间表的分布式练习研究。 Measuring Dependent Variables (DVs) 测量因变量 (DVs) Dependent Variables 因变量 Any behaviors measured in an experiment. 在实验中测量的任何行为。 回顾测量尺度（名义、顺序、间隔、比率）。 Expanded Notes 扩展笔记: Problems 问题 Ceiling Effects 天花板效应: Task is too easy, all scores very high. 任务太容易，所有分数都很高。 Floor Effects 地板效应: Task is too difficult, all scores very low. 任务太难，所有分数都很低。 Subject Variables 受试者变量Definition 定义 Subject Variables 受试者变量 Already-existing attributes of subjects in a study. 研究中受试者的既有属性。 Expanded Notes 扩展笔记: Examples 例子 Gender, age, religion, SES, personality characteristic. 性别、年龄、宗教、社会经济地位、性格特征。 Drawing Conclusions with Subject Variables 使用受试者变量得出结论 With a Manipulated IV 使用操作自变量 Assuming no confounds -&gt; IV causes DV. 假设没有混淆变量 -&gt; 自变量导致因变量。 With a Subject Variable 使用受试者变量 Groups may differ in several ways -&gt; IV cannot be said to cause DV. 各组可能在多方面有所不同 -&gt; 不能说自变量导致因变量。 Expanded Notes 扩展笔记: Example 例子 Self-esteem study with manipulated IV (feedback on test performance) and subject variable (low vs. high self-esteem). 自尊研究，使用操作自变量（测试表现反馈）和受试者变量（低 vs. 高自尊）。 The Validity of Experimental Research 实验研究的效度Types of Validity 效度类型 Statistical Conclusion Validity 统计结论效度 The extent a researcher uses statistics properly and draws the appropriate conclusions from the statistical analysis. 研究人员适当使用统计方法并从统计分析中得出适当结论的程度。 Construct Validity 构念效度 The extent to which the abstract construct can be inferred from the operational definition. 从操作定义推断抽象构念的程度。 External Validity 外部效度 The extent to which research findings generalize to contexts other than those of the experiment. 研究发现推广到实验以外环境的程度。 Internal Validity 内部效度 The degree to which an experiment is methodologically sound and confound-free. 实验在方法上是否健全和没有混淆变量的程度。 Expanded Notes 扩展笔记: Threats to Internal Validity 内部效度的威胁 History 历史效应: Results from a historical or external factor affecting the experimental group. 由于影响实验组的历史或外部因素导致的结果。 Maturation 成熟效应: Participants naturally change over time, independent of their participation in the study. 参与者随着时间自然变化，与他们参与研究无关。 Regression to the Mean 均值回归: 极端分数在随后的测试中往往会趋向于平均值。 Testing and Instrumentation 测试和仪器效应: 随着时间的推移，参与者或测量工具的变化。 Subject Selection 受试者选择: Groups are not equivalent. 各组不等价。 Attrition 退出效应: Reduction in participant numbers due to dropouts. 由于退出导致的参与者人数减少。 --- Methodological Control 方法控制Between-Subjects and Within-Subjects Design 被试间设计和被试内设计 Between-Subjects Design 被试间设计 Each subject experiences only one level of the variable. 每个受试者仅经历一个变量水平。 Solved by random assignment or matching. 通过随机分配或匹配解决。 Random Assignment 随机分配 Definition 定义 A procedure in which each participant has an equal chance of being assigned to any group in an experiment. 一种程序，使每个参与者有平等机会被分配到实验中的任何组。 Ensures that groups are equivalent at the start of the experiment. 确保各组在实验开始时是等价的。 Expanded Notes 扩展笔记: Example 例子 In a study on the effects of a new drug, participants are randomly assigned to either the treatment group or the control group. 在一项关于新药效果的研究中，参与者被随机分配到治疗组或对照组。 Matching 配对 Definition 定义 A procedure to ensure that groups are equivalent by matching participants on specific characteristics before assigning them to groups. 一种通过在分组之前根据特定特征匹配参与者以确保各组等价的程序。 Used when random assignment is not feasible or when there are known confounding variables. 在随机分配不可行或存在已知混淆变量时使用。 Expanded Notes 扩展笔记: Example 例子 In a study on the effects of teaching methods on student performance, participants are matched on GPA before being assigned to different teaching methods. 在一项关于教学方法对学生表现影响的研究中，参与者在分配到不同的教学方法之前根据 GPA 进行匹配。 Within-Subjects Design 被试内设计 Each subject experiences all levels of the variable. 每个受试者经历所有变量水平。 Solved by counterbalancing. 通过平衡解决。 Counterbalancing 平衡设计 Definition 定义 A method to control for order effects in a within-subjects design by varying the order of conditions for participants. 一种在被试内设计中控制顺序效应的方法，通过改变参与者的条件顺序。 Types 类型 Complete Counterbalancing 完全平衡 All possible orders of conditions are used equally. 所有可能的条件顺序都同等使用。 Example: For 3 conditions (A, B, C), there are 6 possible orders (ABC, ACB, BAC, BCA, CAB, CBA). 例子：对于3个条件（A, B, C），有6种可能的顺序（ABC, ACB, BAC, BCA, CAB, CBA）。 Partial Counterbalancing 部分平衡 Only a subset of all possible orders is used. 仅使用所有可能顺序的一个子集。 Often achieved through a Latin Square design. 通常通过拉丁方设计实现。 Expanded Notes 扩展笔记: Latin Square Design 拉丁方设计 A special case of partial counterbalancing where each condition appears in each position and precedes and follows each other condition exactly once. 部分平衡的特殊情况，其中每个条件出现在每个位置，并且每个条件恰好一次出现在其他条件之前和之后。 Example 例子: Example of Counterbalancing 平衡示例 Testing the effect of different study techniques (reading, summarizing, testing) on memory retention. 测试不同学习技术（阅读，总结，测试）对记忆保持的影响。 Complete counterbalancing: Participants experience all 6 orders of the 3 conditions. 完全平衡：参与者经历所有3个条件的6种顺序。 Partial counterbalancing: Using a Latin Square, participants experience a subset of all possible orders. 部分平衡：使用拉丁方，参与者经历所有可能顺序的一个子集。 Controlling for Bias 控制偏见 Experimenter Bias 实验者偏见 Expectations can influence subject behavior. 期望可能影响受试者行为。 Solution: Automatize routine, standardize procedures, use double-blind procedures. 解决方案：自动化常规，标准化程序，使用双盲程序。 Participant Bias 参与者偏见 Participants change behavior because they are being observed. 参与者因为被观察而改变行为。 Solution: Effective deception, use of manipulation checks, field research. 解决方案：有效的欺骗，使用操控检查，现场研究。 Expanded Notes 扩展笔记: Example 例子 Hawthorne Effect: Participants change behavior because they are aware of being observed. 霍桑效应：参与者因为知道被观察而改变行为。 Summary 总结 Experimental research involves manipulating independent variables to observe their effect on dependent variables while controlling extraneous variables. 实验研究涉及操控自变量以观察其对因变量的影响，同时控制外在变量。 Methodological controls include random assignment, matching, counterbalancing, and controlling for biases. 方法控制包括随机分配、匹配、平衡和控制偏见。 Ensuring internal validity is crucial for drawing accurate conclusions from an experiment. 确保内部效度对于从实验中得出准确结论至关重要。","link":"/psy2013-lecture-04-notes/"},{"title":"PSY2013 Lecture 02 Notes","text":"PSY2013 Research Methods in Psychology Ch03 Developing Ideas for Research in Psychology Developing Ideas for Research in Psychology 发展心理学研究的想法Types of Psychological Research 心理学研究类型Basic vs. Applied 基础研究 vs. 应用研究 Basic 基础研究 旨在理解基本的心理现象。 例如：影响选择性注意的刺激因素。 Applied 应用研究 旨在解决现实世界中的问题。 例如：手机使用对驾驶的影响。 Expanded Notes 扩展笔记: Strayer 和 Johnston（2001）：该研究结合了基础研究（有限容量注意理论）和应用研究（手机使用与汽车安全）。 棉花糖测试：Walter Mischel（1972）对延迟满足的实验可以预测以后的生活结果，如学术表现和肥胖。 Laboratory vs. Field 实验室 vs. 现场研究 Laboratory 实验室研究 Greater control, minimal mundane realism. 更大的控制，最小的日常现实感。 Field 现场研究 More realistic, maximal mundane realism. 更真实，最大的日常现实感。 Experimental Realism 实验现实感 The extent to which subjects are involved in the procedures. 受试者参与程序的程度。 Expanded Notes 扩展笔记: Manipulation Check 操纵检查 A procedure to determine if subjects were aware of a deception experiment’s true purpose and if systematic manipulations have the intended effect on participants. 用于确定受试者是否意识到欺骗实验的真实目的以及系统操纵是否对参与者产生预期效果的程序。 Pilot Study 试点研究 A small-scale study conducted to ensure the experiment procedure works as planned. 进行小规模研究以确保实验程序按计划进行。 Quantitative vs. Qualitative 定量 vs. 定性 Quantitative 定量研究 Numbers and greater control in lab settings. 数据和实验室中的更大控制。 Qualitative 定性研究 Narrative descriptions, content analyses, interviews. 叙述描述、内容分析、访谈。 Asking Empirical Questions 提出实证问题Empirical vs. Non-Empirical Questions 实证 vs. 非实证问题 Non-Empirical Questions 非实证问题 Cannot be answered by science. 无法通过科学回答。 例如：上帝存在吗？生命的意义是什么？ Empirical Questions 实证问题 Answerable with data; terms precisely defined. 可以用数据回答；术语精确定义。 例如：信仰上帝与对死亡的恐惧之间有什么关系？ Expanded Notes 扩展笔记: Transform non-empirical questions into empirical questions by framing them in a way that allows for data collection and analysis. 通过以允许数据收集和分析的方式来框定非实证问题，将其转化为实证问题。 Conceptual and Operational Definitions 概念定义和操作定义Conceptual Definition 概念定义 The researcher’s theoretical definition of the variable in question. 研究者对所研究变量的理论定义。 Operational Definition 操作定义 The specific decision about how to measure or manipulate the variable. 关于如何测量或操纵变量的具体决策。 Expanded Notes 扩展笔记: Principles of Operational Definition 操作定义原则 Concepts must be defined by the steps or operations used to measure them. 必须通过用于测量它们的步骤或操作来定义概念。 Necessary to eliminate confusion and ensure replication. 有必要消除混乱并确保复制。 Examples 例子 Anxiety 焦虑 Dictionary definition: A state of being uneasy, apprehensive, or worried. 字典定义：一种不安、担忧或担心的状态。 Operational definition: Increased heart rate; self-rating scale or questionnaire. 操作定义：心率增加；自我评估量表或问卷。 Hunger 饥饿 Dictionary definition: Gnawing feeling in stomach, a strong desire for food. 字典定义：胃部的咬痛感，对食物的强烈渴望。 Operational definition: 12 hours of food deprivation. 操作定义：12小时不进食。 Reading Speed 阅读速度 Definition: Number of words read in one minute. 定义：一分钟内阅读的单词数。 Origins of Research Ideas 研究想法的起源Observation 观察 有时来自意外事件。 例如：Kitty Genovese谋杀案后的旁观者效应。 Psychological Theories 心理理论 E.g., cognitive dissonance, diffusion of responsibility. 例如，认知失调，责任扩散。 Existing Research 现有研究 Development of research teams and the question of “what’s next?” 研究团队的发展以及“接下来是什么？”的问题。 Expanded Notes 扩展笔记: Serendipitous Events 意外事件 Discovering something when looking for something else, such as Skinner’s first extinction curve. 在寻找其他东西时发现某些东西，例如Skinner的第一个消退曲线。 Developing Research from Theory 从理论发展研究 The Nature of Theory 理论的本质 Summarizes, organizes, explains, and provides a basis for predictions. 总结、组织、解释并提供预测的基础。 Includes constructs: hypothetical factors involved in the explanation (e.g., Cognitive Dissonance theory). 包括构造：解释中涉及的假设因素（例如，认知失调理论）。 Relationship Between Theory and Research 理论与研究的关系 Hypotheses deduced from theory. 从理论推导出的假设。 Outcomes/data provide or fail to provide inductive support for the theory. 结果/数据提供或未能提供归纳支持理论。 Attributes of Good Theories 好理论的属性 Productivity 生产力 Good theories produce much research and advance our knowledge. 好的理论会产生大量研究并推进我们的知识。 Example: Cognitive dissonance theory. 例如：认知失调理论。 Falsifiability 可证伪性 Good theories can be shown to be wrong (fail to be supported by data). 好的理论可以被证明是错误的（数据不支持）。 Example: Einstein’s theory of general relativity. 例如：爱因斯坦的广义相对论。 Parsimony 简洁性 Good theories are concise and provide a simple explanation for results. 好的理论是简洁的，并为结果提供简单的解释。 Example: Occam’s Razor. 例如：奥卡姆剃刀。 Reviewing the Literature 文献综述Computerized Database Searches 计算机数据库检索 PsycINFO: Psychology database. ERIC: Educational Psychology database. Expanded Notes 扩展笔记: Search Tips 检索技巧 Use advanced search options and truncated search terms to avoid narrow results. 使用高级搜索选项和截断搜索词以避免结果过于狭窄。 Results list usually begins with the most recent research. 结果列表通常以最新研究开始。 Reading abstracts can help quickly determine the relevance of the research. 阅读摘要可以快速确定研究的相关性。 Summary 总结 研究人员根据目标（基础研究 vs. 应用研究）、设置（实验室 vs. 现场）和收集的信息类型（定量 vs. 定性）进行各种类型的研究。 提出实证问题以更好地理解心理现象。 研究想法来源于观察、理论和现有研究。 研究人员通过探索研究文献（例如，通过Google Scholar，PsycINFO）来熟悉一个主题。","link":"/psy2013-lecture-02-notes/"},{"title":"PSY2013 Lecture 03 Notes","text":"PSY2013 Research Methods in Psychology Ch04 Sampling, Measurement, and Hypothesis Testing Who to Measure – Sampling Procedures 测量对象 - 抽样程序Samples vs. Populations 样本 vs. 总体 Population 总体 研究人员希望通过研究了解的一组个体。 Sample 样本 从总体中选择的个体群体，用于代表总体进行研究。 Sampling Procedure 抽样程序Probability Sampling 概率抽样 Simple Random Sampling 简单随机抽样 总体中的每个成员都有相等的机会被选为样本成员，例如彩票。 有时使用随机数生成器从总体中选择。 Stratified Sampling 分层抽样 Proportions of important subgroups in the population are represented precisely in the sample. 总体中重要子群体的比例在样本中被精确代表。 Example: 75% female; 25% male (2 strata). 例如：75%女性；25%男性（2层）。 Cluster Sampling 聚类抽样 Randomly select a cluster of individuals all having some feature in common. 随机选择具有某些共同特征的个体群体。 Example: Sample 3/20 dormitory students who live on-campus, and random select from each dormitory. 例如：抽样3/20住在校园宿舍的学生，并从每个宿舍中随机选择。 Non-Probability Sampling 非概率抽样 Convenience Sampling 方便抽样 Select subjects who are available and convenient, e.g., “subject pool”. 选择可用和方便的受试者，例如“受试者池”。 受试者自愿参与。 Purposive Sampling 目的抽样 Selecting specific individuals who meet certain criteria. 选择符合特定标准的个体。 例如：Milgram不使用大学生。 Quota Sampling 配额抽样 Similar to stratified sampling, but non-random. 类似于分层抽样，但非随机。 Snowball Sampling 滚雪球抽样 请求受试者让他们的朋友、家人和熟人参与。 通常通过在线调查进行。 What to Measure – Varieties of Behavior 测量对象 - 行为的种类Developing Measures from Constructs 从构念中发展测量工具 Reaction Time 反应时间 One of psychology’s original methods. 心理学的原始方法之一。 Example: Mental chronometry (Donders). 例子：心理计时法（Donders）。 Expanded Notes 扩展笔记: Mental Rotation 心理旋转 Construct: Visual imagery. 构念：视觉想象。 Measure: Reaction time. 测量：反应时间。 Evaluating Measures 评估测量工具 Reliability 信度 Repeatability and consistency of measures. 测量的重复性和一致性。 Results from a minimum of measurement errors. 测量误差最小化的结果。 Quantified using correlation coefficient. 使用相关系数量化。 Validity 效度 Measures what it is designed to measure. 测量其设计测量的内容。 Expanded Notes 扩展笔记: Types of Validity 效度类型 Content Validity 内容效度: Measures broadly represent what the measure is supposed to measure. 测量广泛代表其应测量的内容。 Criterion Validity 标准效度: The extent to which a measure is related to some criterion (outcome variable). 测量与某些标准（结果变量）相关的程度。 Concurrent: How well the measure predicts present performance. 现时效度：测量预测当前表现的效果如何。 Predictive: How well the measure predicts future performance. 预测效度：测量预测未来表现的效果如何。 Construct Validity 构念效度: The extent to which the abstract construct can be inferred from the operational definition. 从操作定义推断抽象构念的程度。 Scales of Measurement 测量尺度 Nominal Scale 名义尺度 Category-defined, e.g., gender, ethnicity. 类别定义，例如性别、种族。 Ordinal Scale 顺序尺度 Rank order, e.g., order of finish in a test. 排序，例如测试中的完成顺序。 Interval Scale 间隔尺度 Order + equal intervals, e.g., temperature scales. 顺序 + 相等间隔，例如温度刻度。 Ratio Scale 比率尺度 Order + equal intervals + true zero point, e.g., weight. 顺序 + 相等间隔 + 真实零点，例如重量。 Expanded Notes 扩展笔记: Example of Scales 尺度示例 Nominal: Gender (male, female). Ordinal: Education level (high school, bachelor’s, master’s). Interval: Temperature (Celsius). Ratio: Height (cm). Statistical Analysis 统计分析Descriptive Statistics 描述统计 Frequency Distribution 频数分布 Count or frequency for nominal/categorical data. 名义/分类数据的计数或频率。 Measures of Central Tendency 集中趋势测量 What scores are at the center of a distribution. 分布中心的分数。 Mean, median, mode. 平均数、中位数、众数。 Measures of Variability 变异性测量 How spread out or dispersed scores are in a distribution. 分布中分数的分散程度。 Range, standard deviation (SD), variance (VAR), interquartile range (IQR). 范围、标准差（SD）、方差（VAR）、四分位距（IQR）。 Inferential Statistics 推论统计 Inferential Statistics 推论统计 Makes inferences and predictions about a population based on a sample of data. 基于样本数据对总体进行推断和预测。 Provide a way to test a claim or hypothesis using sample data. 提供一种使用样本数据检验主张或假设的方法。 Hypothesis Testing 假设检验Null Hypothesis 零假设 Definition 定义 No relationship (“no difference”) between variables in the population is expected. 预计总体中变量之间没有关系（“没有差异”）。 Alternative Hypothesis 备择假设 Definition 定义 A relationship (“a difference”) between variables in the population is expected. 预计总体中变量之间有关系（“有差异”）。 Expanded Notes 扩展笔记: Significance Testing 显著性检验 If the observed p-value is less than a predefined value (alpha, α), the null hypothesis can be rejected. 如果观察到的p值小于预定义值（alpha，α），则可以拒绝零假设。 Common alpha level: α = 0.05. 常见的alpha水平：α = 0.05。 Possible Errors 可能的错误 Type I Error 类型I错误 Rejecting a true null hypothesis (false positive). 拒绝正确的零假设（假阳性）。 Type II Error 类型II错误 Failing to reject a false null hypothesis (false negative). 未能拒绝错误的零假设（假阴性）。 Expanded Notes 扩展笔记: Power 功效 The chance of rejecting a false null hypothesis. 拒绝错误的零假设的机会。 Power = 1 - β (where β is the probability of a Type II error). 功效 = 1 - β（其中β是类型II错误的概率）。 Beyond Hypothesis Testing 超越假设检验Confidence Intervals 置信区间 Definition 定义 The range within which the population mean is likely to be found within a percentage of the time. 总体均值可能在一定百分比时间内出现的范围。 Example: A 95% confidence interval tells us that we can be 95% confident that the interval captures the population mean. 例子：95%的置信区间告诉我们，我们可以95%确定该区间包含总体均值。 Effect Size 效应量 Definition 定义 Emphasizes the size of the difference between variables, not merely whether there is a difference. 强调变量之间差异的大小，而不仅仅是是否存在差异。 Open Science, Pre-registration, and Replications 开放科学、预注册和复制研究Expanded Notes 扩展笔记: Open Science 开放科学 Promotes transparency and accessibility in scientific research. 促进科学研究的透明性和可访问性。 Pre-registration 预注册 Registering study design and analysis plans before conducting the research. 在进行研究之前注册研究设计和分析计划。 Replications 复制研究 Repeating studies to confirm findings and ensure reliability. 重复研究以确认发现并确保可靠性。 Summary 总结 Various sampling procedures are available to find a representative sample from the population. 有多种抽样程序可用于从总体中找到具有代表性的样本。 Statistics is the language used to communicate findings in the field of psychology. 统计是心理学领域中用于交流发现的语言。 Hypothesis testing involves determining the likelihood that the observed results are due to chance. 假设检验涉及确定观察到的结果是由于机会的可能性。 Beyond hypothesis testing, confidence intervals, effect sizes, and power are essential for understanding psychological phenomena. 超越假设检验，置信区间、效应量和功效对于理解心理现象至关重要。","link":"/psy2013-lecture-03-notes/"},{"title":"PSY2013 Lecture 05 Notes","text":"PSY2013 Research Methods in Psychology Ch07 Experimental Design I: Single‐Factor Designs Ch08 Experimental Design II: Factorial Designs Single-Factor Designs 单因素设计Learning Objectives 学习目标 Identify and understand the defining features of the four varieties of single-factor designs识别并理解四种单因素设计的定义特征 Independent groups 独立组设计 Matched groups 配对组设计 Nonequivalent groups 不等组设计 Repeated measures 重复测量设计 Describe two reasons for using more than two levels of an independent variable描述使用多于两个自变量水平的两个原因 Decide when to use a bar graph and when to use a line graph决定何时使用柱状图，何时使用折线图 Describe the goals, methodology, and results of Ebbinghaus memory research描述艾宾浩斯记忆研究的目标、方法和结果 Understand the logic behind the use of three special types of control groups理解使用三种特殊类型对照组的逻辑 Placebo 安慰剂组 Wait list 等候名单组 Yoked 依附组 Understand the ethical issues involved in using certain types of control groups理解使用某些类型对照组的伦理问题 Know when to use an independent samples t-test and when to use a dependent samples t-test知道何时使用独立样本t检验，何时使用配对样本t检验 Understand why a one-way ANOVA is appropriate for single-factor, multilevel studies理解为何单因素多水平研究应使用单因素方差分析 Understand why post hoc statistical analyses typically accompany one-factor ANOVAs理解为何单因素方差分析通常伴随事后统计分析 Single-Factor Designs 单因素设计Decision Tree 决策树Single-Factor—Two Levels 单因素双水平设计 Between-subjects, single factor designs 被试间单因素设计 Independent Groups Designs 独立组设计 Manipulated independent variable 操作自变量 Random assignment to create equivalent groups 随机分配以创建等价组 Example 例子: IV → Note-taking method 记笔记方法 Laptop note-taking 使用笔记本电脑记笔记 Handwritten note-taking 手写记笔记 DV → Performance on memory test 记忆测试表现 Other concepts 其他概念: Conceptual replication 概念复制 What’s next thinking 接下来是什么 Ecological validity 生态效度 Matched Groups Designs 配对组设计 Manipulated independent variable 操作自变量 Matching to produce equivalent groups 配对以产生等价组 Example 例子: IV → Type of social skills training 社交技能训练类型 Direct teaching 直接教学 Play activities 玩耍活动 Matching variable 配对变量 → Autism Quotient 自闭症商数 DV → Social Interaction Observation Code 社交互动观察代码 Other concepts 其他概念: Operational definitions 操作定义 Double-blind procedure 双盲程序 Inter-rater reliability 评估者间信度 Ex Post Facto Designs 事后设计 Subject variable as an independent variable 使用受试者变量作为自变量 Deliberate attempts to select participants to reduce nonequivalence 有意选择参与者以减少不等性 Example 例子: IV → Whether or not traumatic brain injury (TBI) had occurred 是否发生了脑外伤 Experimental group 实验组 → Had experienced TBI 发生过脑外伤 Control group 对照组 → No TBI 未发生脑外伤 DV → Ability to detect insincerity in others 检测他人虚伪的能力 Other concepts 其他概念: Matching 配对 External validity addressed 外部效度 Within-subjects, single factor designs 被试内单因素设计 Also called repeated measures designs 也称为重复测量设计 Example 例子: IV → Whether or not you share your experience with another person 是否与他人分享你的经历 Shared 分享 Unshared 不分享 DV → Ratings of liking and of flavorfulness of chocolate 对巧克力的喜好和味道评分 Other concepts 其他概念: Confederate 共谋者 Cover story 掩饰故事 What’s next thinking 接下来是什么 Single-Factor—More Than Two Levels 单因素多水平设计 Between-subjects, multilevel designs 被试间多水平设计 Advantages 优势: Ability to discover nonlinear effects 发现非线性效应的能力 Ability to rule out alternative explanations 排除其他解释的能力 Example 例子: Bransford and Johnson’s (1972) ‘Laundry Study’ 布兰斯福德和约翰逊（1972）的‘洗衣研究’ IV → Context 情境 No context (no topic presented) 无情境（未呈现主题） Context before (topic presented before reading paragraph) 阅读段落前呈现主题 Context after (topic presented after reading paragraph) 阅读段落后呈现主题 DV → Recall of paragraph’s ideas 回忆段落的想法 Multilevel Independent Groups Design 多水平独立组设计 Example 例子: IV → Number of people with children 与儿童在一起的人数 Alone 独自 Bystander (with 2 other children who could help) 旁观者（与另外两个可以帮助的儿童在一起） Bystander-Unavailable (with 2 other children who could not help) 旁观者不可用（与另外两个不能帮助的儿童在一起） DV → Whether or not child (participant) helped teacher 儿童（参与者）是否帮助老师 Other concepts 其他概念: Operational definitions 操作定义 Confederates 共谋者 Inter-rater reliability 评估者间信度 Within-subjects, multilevel designs 被试内多水平设计 Example 例子: Multilevel repeated measures 多水平重复测量 IV → Listening experience 听觉体验 Listening to Mozart 听莫扎特 Listening to a rainstorm 听暴雨 Control – no listening 对照组 - 不听 DV → Recall of digits 回忆数字 Other concepts 其他概念: Counterbalancing via 3x3 Latin square 通过3x3拉丁方平衡 Cover story 掩饰故事 Analyzing Data from Single-Factor Designs 单因素设计的数据分析Presenting the Data 数据展示 Bar Graphs vs. Line Graphs 柱状图 vs. 折线图 Bar graphs are used for discrete variables. 柱状图用于离散变量。 Line graphs are used for continuous variables. 折线图用于连续变量。 Example 例子: Bransford and Johnson’s (1972) data presented in table and graphical forms 布兰斯福德和约翰逊（1972）数据的表格和图形展示 Analyzing Single-Factor, Two-Level Designs 单因素双水平设计的数据分析 t-Test Assumptions t检验的假设 Interval or ratio scale data 间隔或比率尺度数据 Data normally distributed 数据近似正态分布 Homogeneity of variance 方差齐性 t-Test for Independent Samples 独立样本t检验 Used for independent groups designs and nonequivalent groups designs 用于独立组设计和不等组设计 t-Test for Related Samples 相关样本t检验 Used for matched groups designs and repeated measures designs 用于配对组设计和重复测量设计 Analyzing Single-Factor, Multilevel Designs 单因素多水平设计的数据分析 One-Way ANOVA 单因素方差分析 Multiple t-tests are inappropriate as they increase the chances of Type I error. 多次t检验不合适，因为它们增加了I型错误的机会。 One-Way ANOVA for Independent Groups 独立组单因素方差分析 For multilevel independent groups designs and multilevel ex post facto designs 用于多水平独立组设计和多水平事后设计 One-Way ANOVA for Repeated Measures 重复测量单因素方差分析 For multilevel matched groups designs and multilevel repeated measures designs 用 于多水平配对组设计和多水平重复测量设计 Once an overall significant effect is found, post hoc testing is conducted. 一旦发现总体显著效应，就进行事后检验。 Special-Purpose Control Group Designs 特殊用途的对照组设计Types of Control Groups 对照组类型 Placebo Control Groups 安慰剂对照组 Participants believe they are receiving treatment but are not. 参与者认为自己正在接受治疗但实际上没有。 Placebo effect is when subjects improve due to belief in the treatment. 安慰剂效应是指受试者因相信治疗而有所改善。 Double-blind procedures are often used to prevent bias. 通常使用双盲程序以防止偏见。 Wait List Control Groups 等候名单对照组 Participants are placed on a wait list and receive treatment after the experimental group. 参与者被列入等候名单，在实验组之后接受治疗。 Ensures equivalent groups in program effectiveness studies. 确保在项目效果研究中组等价。 Yoked Control Groups 依附对照组 Each control group subject is matched to an experimental group subject in terms of treatment or conditions. 每个对照组受试者在治疗或条件上与实验组受试者相匹配。 Expanded Notes 扩展笔记: Ethics of Placebo Control Groups 安慰剂对照组的伦理 Placebo-controlled experiments are unethical if an effective therapy is available. 如果有有效疗法，安慰剂对照实验是不道德的。 Informed consent is required, and the benefits must be weighed against the risks. 需要知情同意，并且必须权衡收益与风险。 Factorial Designs 因素设计Learning Objectives 学习目标 Describe factorial designs using a standardized notation system (2x2, 3x5, etc.)使用标准记号系统描述因素设计（2x2，3x5等） Place data accurately into a factorial matrix and calculate row and column means准确地将数据放入因素矩阵并计算行和列的平均值 Understand what is meant by a main effect and know how to determine if one exists理解主效应的含义并知道如何确定是否存在 Understand what is meant by an interaction effect and know how to determine if one exists理解交互作用的含义并知道如何确定是否存在 Know how to interpret interactions and know that the presence of an interaction sometimes lessens or eliminates the relevance of a main effect知道如何解释交互作用，并且知道交互作用的存在有时会减弱或消除主效应的相关性 Describe the research design of Jenkins and Dallenbach’s (1924) famous study on sleep and memory and understand why their results could be considered an interaction描述Jenkins和Dallenbach（1924）关于睡眠和记忆的著名研究设计，并理解为何他们的结果可以被认为是交互作用 Essentials of Factorial Designs 因素设计的基础知识Overview 概述 Factorial Design 因素设计 More than one independent variable (IV). 多个自变量。 Factors 因素: Refers to the independent variables. 指自变量。 Notation System 记号系统: Example 例子: 2 × 3 factorial (two IVs, one with 2 levels, one with 3 levels = 6 total conditions). 2 × 3 因素设计（两个自变量，一个有2个水平，一个有3个水平 = 总共6个条件） Example 例子: 2 × 4 × 4 factorial (three IVs, one with 2 levels, two with 4 levels = 32 total conditions). 2 × 4 × 4 因素设计（三个自变量，一个有2个水平，两个有4个水平 = 总共32个条件） Main Effects and Interactions 主效应与交互作用 Main Effects 主效应 The overall effect of an IV, averaging over the levels of the other IV(s). 自变量的总体效果，平均其他自变量的水平。 Example 例子: Imagery vs. rote learning, presentation rate (2-sec vs. 4-sec). 想象 vs. 死记硬背，展示速度（2秒 vs. 4秒）。 Calculation 计算: Compare row means 比较行平均值 Compare column means 比较列平均值 Hypothetical Data 示例数据: Row mean #1 (imagery) = 20 行均值#1（想象）= 20 Row mean #2 (rote) = 15 行均值#2（死记硬背）= 15 Column mean #1 (2-sec) = 14.5 列均值#1（2秒）= 14.5 Column mean #2 (4-sec) = 20.5 列均值#2（4秒）= 20.5 Interactions 交互作用 The effect of one IV depends on the level of another IV. 一个自变量的效果取决于另一个自变量的水平。 Example 例子: Context-dependent memory (study conditions: silent vs. noisy, test conditions: silent vs. noisy). 情境依赖记忆（学习条件：安静 vs. 嘈杂，测试条件：安静 vs. 嘈杂）。 Identifying Interactions 识别交互作用: If the lines in a graph are parallel, there is no interaction. 如果图中的线是平行的，则没有交互作用。 If the lines are nonparallel, an interaction likely exists. 如果线不平行，则可能存在交互作用。 Varieties of Factorial Designs 因素设计的种类Types 类型 Mixed Factorial Designs 混合因素设计 At least one IV is a between-subjects factor and at least one IV is a within-subjects factor. 至少一个自变量是被试间因素，至少一个自变量是被试内因素。 Example 例子: 2x3 Mixed Factorial Design 2x3 混合因素设计 IV1: Salience of instructions (mortality vs. exam) 指示的显著性（死亡 vs. 考试）(between-subjects 被试间) IV2: Leadership style of political candidates (charismatic, task-oriented, relationship-oriented) 政治候选人的领导风格（有魅力的，任务导向的，关系导向的）(within-subjects 被试内) DV: Evaluation of candidates 候选人的评价 Results 结果: Main effect of leadership style and an interaction. 领导风格的主效应和交互作用。 P × E Designs P × E 设计 Factorials with both subject and manipulated variables. 既有受试者变量又有操控变量的因素设计。 P = Person Factor 受试者因素 E = Environmental Factor 环境因素 Example 例子: 2x2 P×E Factorial Design 2x2 P × E 因素设计 IV1: Gender of subject (men vs. women) 受试者性别（男 vs. 女） IV2: Whether subject took math test with same-sex or opposite-sex group 受试者是否在同性或异性组中参加数学测试 DV: Math scores 数学成绩 Results 结果: Women performed poorly only when in a room with men. 女性只有在与男性在同一个房间时表现差。 Analyzing Factorial Designs 因素设计的数据分析Factorial ANOVAs 因素方差分析 Origins of Factorial Designs 因素设计的起源 Fisher’s agricultural research 费雪的农业研究 Looking for interactions between such factors as fertilizer type and wheat strain 寻找肥料类型和小麦品种等因素之间的交互作用 Invented ANOVA 发明了方差分析 The Ethical Researcher 道德研究者On Being a Competent and Ethical Researcher 成为一名有能力和道德的研究者 Guidelines 指导方针 Be organized, congenial, and welcoming 组织良好、和蔼可亲、热情欢迎 Take consent seriously 认真对待同意书 Write out instructions 写出指示 Practice first, with friends 先与朋友练习 Be alert to distress 注意受试者的痛苦 Be careful and thorough in debriefing 小心且彻底地进行事后解释 Remind departing subjects about contact information 提醒离开的受试者关于联系方式 Thank them for their time 感谢他们的时间 Summary 总结 Single-factor designs have one independent variable (factor), which can be either a between-subjects or within-subjects factor单因素设计有一个自变量（因素），可以是被试间因素或被试内因素。 Independent groups and ex post facto designs are between-subjects designs and repeated measures are within-subjects designs独立组和事后设计是被试间设计，重复测量是被试内设计。 Single-factor designs with more than two levels can demonstrate nonlinear effects and rule out alternative explanations具有多于两个水平的单因素设计可以展示非线性效应并排除其他解释。 Data from single-factor designs can be presented in table or graphical form (bar graph or line graph)单因素设计的数据可以以表格或图形形式展示（柱状图或折线图）。 Data from single-factor designs can be analyzed with t-tests for two-level designs, or with one-way ANOVAs for multilevel designs单因素设计的数据可以用t检验分析双水平设计，或用单因素方差分析分析多水平设计。 Special-purpose control groups may be used to compare the effect of experimental treatments to no-treatment controls特殊用途的对照组可以用来比较实验处理与无处理对照的效果。 Factorial designs allow us to evaluate the effects of multiple IVs on the DV or DVs因素设计允许我们评估多个自变量对因变量或因变量的影响。 There are different types of factorial designs, depending on how you manipulate your IVs根据自变量的操控方式，有不同类型的因素设计。 Main effects of each IV and interactions among IVs are the results from factorial designs每个自变量的主效应和自变量之间的交互作用是因素设计的结果。 Factorial ANOVAs are the statistical tests used for analyzing data from factorial designs因素方差分析是用于分析因素设计数据的统计检验。 With the experimental design tools at your disposal, remember to be an ethical researcher使用手头的实验设计工具时，记住要成为一个有道德的研究者。","link":"/psy2013-lecture-05-notes/"},{"title":"PSY2013 Lecture 07 Notes","text":"PSY2013 Research Methods in Psychology Statistics in Psychology Part 1: Descriptive Statistics 描述性统计Basic Concepts 基本概念 Variables 变量 Dependent Variable (DV) 因变量: The variable that is measured. Independent Variable (IV) 自变量: The variable that is manipulated. Scales 测量尺度: Nominal, Ordinal, Interval, Ratio 名义、顺序、区间、比率 Population and Sample 总体与样本 Population 总体: The entire group of individuals or instances about whom we hope to learn. Sample 样本: A subset of the population examined in the study. Descriptive Statistics 描述性统计 Definition 定义 Methods for organizing and summarizing data. 组织和总结数据的方法。 Examples: Tables, graphs, and descriptive values (e.g., average score). 例如：表格、图表和描述性值（如平均分）。 Parameters and Statistics 参数与统计量 Parameter 参数: A descriptive value for a population. Statistic 统计量: A descriptive value for a sample. 参数：总体的描述值。 统计量：样本的描述值。 Four Types of Measurement Scales 四种测量尺度 Nominal Scale 名义尺度 Unordered set of categories identified only by name. 仅以名称标识的无序类别集合。 Example: Gender, ethnicity 性别、种族 Ordinal Scale 顺序尺度 Ordered set of categories. 有序类别集合。 Example: Class rankings 班级排名 Interval Scale 区间尺度 Ordered series of equal-sized categories; arbitrary zero point. 等间距有序系列；零点是任意的。 Example: Temperature in Celsius 摄氏温度 Ratio Scale 比率尺度 Interval scale with a true zero point. 具有真实零点的区间尺度。 Example: Height, weight 身高、体重 Frequency Distributions 频数分布 Definition 定义 Organized tabulation showing the number of individuals located in each category. 显示每个类别中个体数量的有组织的列表。 Example: Frequency table 频数表 Types 类型 Histograms 直方图: Bars touch, used for interval or ratio scales. 条形接触，用于区间或比率尺度。 Polygons 多边形图: Dots connected by lines. 点通过线连接。 Bar Graphs 条形图: Bars do not touch, used for nominal or ordinal scales. 条形不接触，用于名义或顺序尺度。 Central Tendency 集中趋势 Definition 定义 Measures that determine a single value to describe the center of a distribution. 确定单个值来描述分布中心的测量。 Mean 平均数: Sum of scores divided by the number of scores. 总分数除以分数个数。 $$\\text{Mean} (\\mu) = \\frac{\\sum X}{N}$$ Median 中位数: Middle score in a distribution. 分布中的中间分数。 Mode 众数: Most frequently occurring score. 出现最频繁的分数。 Variability 变异性 Definition 定义 Measure of how spread out the scores are in a distribution. 测量分数在分布中的分散程度。 Range 范围: Difference between the highest and lowest scores. 最高分和最低分之间的差。 Standard Deviation 标准差: Average distance between each score and the mean. 每个分数与平均数之间的平均距离。 $$\\text{Standard Deviation} (\\sigma) = \\sqrt{\\frac{\\sum (X - \\mu)^2}{N}}$$ Variance 方差: Mean of the squared deviations. 平均平方偏差。 $$\\text{Variance} (\\sigma^2) = \\frac{\\sum (X - \\mu)^2}{N}$$ Correlation 相关性 Pearson Correlation 皮尔逊相关系数 Measures the direction and strength of the linear relationship between two variables. 测量两个变量之间线性关系的方向和强度。 Formula 公式: $$r = \\frac{\\sum (X - \\overline{X})(Y - \\overline{Y})}{\\sqrt{\\sum (X - \\overline{X})^2 \\sum (Y - \\overline{Y})^2}}$$ Range 范围: -1 to 1 Regression 回归分析 Linear Regression 线性回归 Determines the equation for the best-fitting line. 确定最佳拟合线的方程。 Equation 方程: $$Y = bX + a$$ $b$: Slope 斜率 $a$: Y-intercept 截距 Part 2: Probability and Samples 概率与样本Inferential Statistics 推论统计 Definition 定义 Methods for using sample data to make general conclusions about populations. 使用样本数据对总体做出一般结论的方法。 z-Scores 标准分数 Formula 公式 $$z = \\frac{X - \\mu}{\\sigma}$$ $$X = \\mu + z\\sigma$$ Purpose 目的 Specifies the precise location of each X value within a distribution. 指定每个X值在分布中的精确位置。 Example 例子 Mean $\\mu$ = 100, Standard Deviation $\\sigma$ = 10, X = 130 → z = 3 平均数 $\\mu$ = 100，标准差 $\\sigma$ = 10，X = 130 → z = 3 Probability 概率 Definition 定义 Method for measuring the likelihood of obtaining a specific sample. 测量获得特定样本的可能性的方法。 Formula 公式: $$P(A) = \\frac{\\text{number of outcomes classified as A}}{\\text{total number of possible outcomes}}$$ Sampling and Probability 抽样与概率 Random Sampling 随机抽样 Each member of a population has an equal chance of being selected. 总体的每个成员都有同等的被选中机会。 Normal Distribution 正态分布 Symmetrical, bell-shaped distribution. 对称的钟形分布。 Properties 特性 Mean = Median = Mode 平均数 = 中位数 = 众数 Empirical Rule 经验法则: ~68% within 1 SD, ~95% within 2 SDs, ~99.7% within 3 SDs 68%在1个标准差内，95%在2个标准差内，~99.7%在3个标准差内 Central Limit Theorem 中心极限定理 Definition 定义 The distribution of sample means will be normal if the sample size is large enough (n ≥ 30). 如果样本量足够大（n ≥ 30），样本均值的分布将是正态分布。 Properties 特性 Mean of sample means = Population mean 样本均值的平均数 = 总体均值 Standard Error 标准误差: $$\\sigma_M = \\frac{\\sigma}{\\sqrt{n}}$$ Part 3: Hypothesis Testing 假设检验Hypothesis Testing 假设检验 Definition 定义 Statistical method that uses sample data to evaluate a hypothesis about a population. 使用样本数据评估总体假设的统计方法。 Steps 步骤 State hypothesis about the population. 陈述关于总体的假设。 Use hypothesis to predict the characteristics the sample should have. 使用假设预测样本应具有的特征。 Obtain a sample from the population. 从总体中获取样本。 Compare data with the hypothesis prediction. 将数据与假设预测进行比较。 Null Hypothesis (H0) 零假设 States that there is no change or effect. 声明没有变化或效果。 Alternative Hypothesis (H1) 备择假设 States that there is a change or effect. 声明存在变化或效果。 Critical Regions and Alpha Level 临界区和显著性水平 Critical Region 临界区 Extreme sample values that are very unlikely to occur if H0 is true. 如果零假设成立，极不可能发生的样本值。 Alpha Level (α) 显著性水平 Probability value used to define “very unlikely” outcomes. 用于定义“极不可能”结果的概率值。 Common α values 常用α值: 0.05, 0.01, 0.001 Errors in Hypothesis Testing 假设检验中的错误 Type I Error (α) 一类错误 Rejecting H0 when it is true. 拒绝成立的零假设。 False positive 假阳性 Type II Error (β) 二类错误 Failing to reject H0 when it is false. 未拒绝错误的零假设。 False negative 假阴性 Statistical Power 统计功效 Definition 定义 Probability that the test will correctly reject a false null hypothesis. 检验正确拒绝错误的零假设的概率。 Formula 公式: $$\\text{Power} = 1 - \\beta$$ Measuring Effect Size 测量效果大小 Cohen’s d 科恩的d Measures the size of the mean difference in terms of standard deviation units. 以标准差单位衡量平均差异的大小。 Part 4: t-Tests t检验The t Statistic t统计量 Definition 定义 Used to test hypotheses about an unknown population mean when the population standard deviation is also unknown. 用于在总体标准差未知的情况下检验未知总体均值的假设。 Formula 公式: $$t = \\frac{M - \\mu}{s_M}$$ $s_M$: Estimated standard error 估计标准误差 Degrees of Freedom 自由度 Definition 定义 Number of scores in a sample that are independent and free to vary. 样本中独立且自由变化的分数数量。 Formula 公式: $$df = n - 1$$ Hypothesis Tests with the t Statistic 使用t统计量的假设检验 Steps 步骤 State the hypotheses and select an alpha level. 陈述假设并选择显著性水平。 Locate the critical region using df and alpha level. 使用自由度和显著性水平找到临界区。 Calculate the test statistic. 计算检验统计量。 Make a decision. 做出决定。 Independent-Measures t Test 独立样本t检验 Purpose 目的 Determine whether the sample mean difference indicates a real mean difference between two populations. 确定样本均值差异是否表示两个总体之间的真实均值差异。 Pooled Variance 合并方差 Definition 定义 Provides an unbiased basis for calculating the standard error. 提供计算标准误差的无偏基础。 Formula 公式: $$s_p^2 = \\frac{SS_1 + SS_2}{df_1 + df_2}$$ Repeated-Measures t Test 重复测量t检验 Definition 定义 Evaluate the mean difference between two treatment conditions using data from a single sample. 使用单个样本的数据评估两个处理条件之间的平均差异。 Difference Score 差异分数: $$D = X_2 - X_1$$ Confidence Intervals 置信区间 Definition 定义 Range of values that estimate the unknown population mean. 估计未知总体均值的值范围。 Formula 公式: $$\\mu = M \\pm t(s_M)$$","link":"/psy2013-lecture-07-notes/"},{"title":"PSY2013 Lecture 06 Notes","text":"PSY2013 Research Methods in Psychology Ch09 Non‐Experimental Design I: Survey Methods Ch10 Non‐Experimental Design II: Observational and Archival Methods Ch11 Quasi‐Experimental Designs and Applied Research Ch12 Small N Designs Non-Experimental Design 非实验性设计Learning Objectives 学习目标 Explain why sampling issues are more relevant for survey research than for most other research in psychology解释为什么抽样问题对调查研究比对心理学中的其他研究更相关 Articulate the principles of good survey construction阐述构建良好调查的原则 Explain the problems that can make it difficult to interpret survey data解释导致难以解释调查数据的问题 Describe four ways to collect survey data and list the advantages and disadvantages of each描述四种收集调查数据的方法，并列出每种方法的优缺点 Describe three varieties of probability sampling and know when each is used描述三种概率抽样，并知道每种抽样的使用情况 Distinguish between positive and negative bivariate correlations, create scatterplots to illustrate them区分正相关和负相关双变量，创建散点图来说明它们 Calculate a coefficient of determination (r²) and interpret its meaning计算决定系数 (r²) 并解释其含义 Understand how a regression analysis accomplishes the goal of prediction, and distinguish between simple linear regression and multiple regression techniques理解回归分析如何实现预测目标，并区分简单线性回归和多元回归技术 Understand how directionality can make it difficult to interpret correlations and how a cross-lagged panel study can help with the directionality problem理解方向性如何使解释相关性变得困难，以及交叉滞后面板研究如何帮助解决方向性问题 Understand the third variable problem and how such variables can be evaluated and controlled through a partial correlation procedure理解第三变量问题，以及如何通过部分相关程序评估和控制这些变量 Distinguish between mediators and moderators within the context of understanding third variables in a correlation在理解相关性的第三变量时区分中介变量和调节变量 Survey Research 调查研究Origins of Survey Research 调查研究的起源 Early Surveys 早期调查 Darwin’s study on facial expressions of emotion 达尔文对情感面部表情的研究 Galton’s work on the origins of scientific interests 高尔顿对科学兴趣起源的研究 Hall’s research on the contents of children’s minds 霍尔对儿童思维内容的研究 Sampling Issues 抽样问题 Biased vs. Representative Samples 有偏见的样本 vs. 代表性样本 Non-Probability Sampling 非概率抽样: Convenience sampling, quota sampling, etc. Probability Sampling 概率抽样: Simple random sampling, stratified sampling, cluster sampling Self-Selection Bias 自我选择偏差: Example of 1936 Literary Digest election poll 1936年《文学文摘》的选举民调例子 Creating an Effective Survey 创建有效的调查 Types of Survey Questions 问题类型 Open-Ended Questions 开放式问题: Allows respondents to answer in their own words Closed Questions 封闭式问题: Provides predefined response options Likert Scales 李克特量表: Measures attitudes by asking respondents to rate their agreement on a scale Survey Wording 问卷措辞 Avoid ambiguity 避免模糊 Avoid double-barreled questions 避免双重问题 Avoid biased and leading questions 避免有偏见和引导性的问题 Collecting Survey Data 收集调查数据 Methods 方法 In-Person Interview Surveys 面对面访谈 Advantages: Comprehensive data, follow-ups possible Disadvantages: High cost, interviewer bias Mailed Written Surveys 邮寄书面调查 Advantages: Ease of scoring Disadvantages: Low response rate, nonresponse bias Phone Surveys 电话调查 Advantages: Cost-effective, efficient Disadvantages: Must be brief, lower response rate Electronic Surveys 电子调查 Advantages: Cost-effective, efficient Disadvantages: Sampling issues, ethical concerns Ethical Considerations 伦理考虑 Issues 问题 Informed consent 知情同意 Privacy and confidentiality 隐私和保密 Use and misuse of survey data 调查数据的使用和滥用 Analyzing Data from Non-Experimental Designs 分析非实验性设计的数据Correlation: Describing Relationships 相关性：描述关系 Types of Correlations 相关类型 Positive Correlation 正相关: Higher scores on one variable associated with higher scores on another Negative Correlation 负相关: Higher scores on one variable associated with lower scores on another No Correlation 无相关性: No consistent relationship between two variables Scatterplots 散点图 Visual representation of data from two variables Helps in identifying the type and strength of correlation Correlation Coefficients 相关系数 Statistical Tests 统计检验 Pearson’s r: Measures linear correlation between two variables Spearman’s rho: Non-parametric measure of rank correlation Phi Coefficient: Used for binary variables Coefficient of Determination 决定系数 (r²) Proportion of variability in one variable that can be explained by variability in another variable Example: r = .60 → r² = .36 (36% of variability can be explained by the relationship) Regression: Making Predictions 回归：做出预测 Simple Linear Regression 简单线性回归 Predicting the value of one variable based on the value of another Equation: Y = a + bX Y: Criterion variable (dependent variable) X: Predictor variable (independent variable) a: Y-intercept b: Slope of the line Multiple Regression 多元回归 Predicting the value of a criterion variable based on multiple predictor variables Allows for the weighting of each predictor variable’s influence Interpreting Correlational Results 解释相关结果 Directionality Problem 方向性问题 Correlation does not imply causation Cross-lagged panel studies can help determine the directionality Third Variable Problem 第三变量问题 An uncontrolled third variable could influence both correlated variables Partial correlation can help control for third variables Mediators and Moderators 中介变量和调节变量 Mediator 中介变量: Explains how or why a relationship exists between two variables Moderator 调节变量: Explains under what conditions the relationship exists Observational Research 观察研究Varieties of Observational Research 观察研究的种类 Naturalistic Observation 自然观察 Describing behaviors in their natural settings without intervention Examples: Snack selection at movie theaters, gender differences in fighting behaviors at a bar Participant Observation 参与观察 The researcher joins the group being observed Example: Festinger’s study of a cult Challenges in Observational Research 观察研究的挑战 Absence of Control 缺乏控制 Can falsify strong claims but cannot establish causality Observer Bias 观察者偏见 Use behavior checklists and ensure interobserver reliability Participant Reactivity 参与者反应 Use unobtrusive measures to minimize reactivity Ethics 伦理 Issues with consent and privacy Analyzing Qualitative Data from Non-Experimental Designs 分析非实验性设计中的定性数据 Thematic Analysis 主题分析 Identifying patterns in qualitative data Steps: Get familiar with the data 熟悉数据 Code 编码 Search for themes 搜索主题 Review themes 审查主题 Define and name themes 定义和命名主题 Write report 撰写报告 Archival Research 档案研究 Using Previously Collected Data 使用以前收集的数据 Often involves content analysis Susceptible to missing data and bias Analyzing Archival Data 分析档案数据 Factor analysis identifies clusters of related items Meta-analysis evaluates effect sizes across multiple studies Quasi-Experimental Designs 准实验性设计Learning Objectives 学习目标 Identify the dual functions of applied research识别应用研究的双重功能 Understand why applied research has always been an important element in American psychology理解为什么应用研究一直是美国心理学中的重要元素 Define translational research and explain how psychological research can translate into applied settings定义转化研究并解释心理学研究如何转化为应用环境 Identify the design and ethical problems associated with applied research, especially if that research occurs outside of the laboratory识别与应用研究相关的设计和伦理问题，特别是当该研究在实验室外进行时 Identify the defining feature of quasi-experimental designs, and recognize which designs appearing in earlier chapters were quasi-experimental识别准实验性设计的定义特征，并认识到前几章中出现的哪些设计是准实验性的 Describe the features of a nonequivalent control group design and understand why this design is necessarily confounded描述不等价对照组设计的特点，并理解为什么这种设计必然混淆 Understand why matching nonequivalent groups on pretest scores can introduce a regression artifact理解为什么在前测分数上匹配不等价组可以引入回归伪影 Describe the features of interrupted time series designs and understand how they can be used to evaluate trends描述中断时间序列设计的特点，并理解它们如何用于评估趋势 Describe variations on the basic time series design描述基本时间序列设计的变体 Describe the strategies that can be used complete a needs analysis in a program evaluation project描述在项目评估项目中完成需求分析的方法 Understand the purposes and the procedures involved in various program evaluation procedures理解各种项目评估程序的目的和程序 Identify and describe the ethical problems that often accompany program evaluation research识别并描述经常伴随项目评估研究的伦理问题 Beyond the Laboratory 超越实验室 Applied Research 应用研究 Solves real-world problems and increases basic knowledge 解决现实世界的问题并增加基础知识 Example: Nutrition labels’ effect on health decisions 营养标签对健康决策的影响 Design Problems in Applied Research 应用研究中的设计问题 Ethical dilemmas, trade-off between internal and external validity 伦理困境，内部和外部效度之间的权衡 Problems with creating equivalent groups, uncontrolled order effects 创建等价组的问题，未控制的顺序效应 Quasi-Experimental Designs 准实验性设计 Features 特点 No causal conclusions, less than complete control, no random assignment 无因果结论，控制不完全，没有随机分配 Examples from prior chapters: single-factor nonequivalent groups designs, ex post facto factorial designs, P x E factorial designs 以前章节中的例子：单因素不等组设计，事后因素设计，P x E 因素设计 Nonequivalent Control Group Designs 不等价对照组设计 Include pretests and posttests 包括前测和后测 Random assignment not possible for practical reasons 由于实际原因，无法进行随机分配 Interrupted Time Series Designs 中断时间序列设计 Features 特点 Evaluates overall trends 评估总体趋势 Example: Effect of incentive plan on productivity 激励计划对生产力的影响 Variations 变体 Adding a control group 添加对照组 Adding a second treatment at a different time 在不同时间添加第二个处理 Adding a second DV that is not expected to be influenced by the program 添加一个不受程序影响的第二个因变量 Program Evaluation 项目评估Steps 步骤 Needs Analysis 需求分析 Census data, surveys of resources and potential users, focus groups 人口普查数据，资源和潜在用户调查，焦点小组 Formative Evaluation 形成性评估 Evaluating the program while it is in progress 在项目进行时进行评估 Program audit, pilot study 项目审计，试点研究 Summative Evaluation 总结性评估 Evaluating program effectiveness 评估项目效果 More threatening than formative evaluation 比形成性评估更具威胁性 Use of quasi-experimental designs 使用准实验性设计 Cost-Effectiveness Analysis 成本效益分析 Comparing the costs and effectiveness of different programs 比较不同项目的成本和效果 Ethical Issues 伦理问题 Concerns 关注点 Consent, confidentiality, perceived injustice 知情同意，保密性，感知的不公正 Stakeholder conflicts 利益相关者冲突 Small N Designs 小样本设计Learning Objectives 学习目标 Describe examples of classic studies in psychology’s history, all using single individuals or a small number of participants, with additional subjects used for replication描述心理学历史上经典研究的例子，这些研究都使用单个个体或少数参与者，并使用额外的受试者进行复制 Explain how grouping data from large numbers of participants can yield misleading conclusions about behavior解释将大量参与者的数据分组如何得出关于行为的误导性结论 Describe some practical reasons for doing small N research描述进行小样本研究的一些实际原因 Describe B. F. Skinner’s basic philosophy about how best to conduct research—the experimental analysis of behavior描述B. F. 斯金纳关于如何最好地进行研究的基本哲学——行为的实验分析 Describe the essential components of any single-subject design描述任何单个受试者设计的基本组成部分 The Experimental Analysis of Behavior 行为的实验分析 Operant Conditioning 操作性条件反射 Behavior conditioned by consequences (e.g., reinforcement) 行为由结果（如强化）条件化 Primary DV: Rate of response 主要因变量：反应率 Small N Designs in Applied Behavior Analysis 应用行为分析中的小样本设计 Single-Subject Designs 单受试者设计 Importance of operational definitions 操作定义的重要性 Baselines established 建立基线 Introducing treatment 引入处理 Withdrawal Designs 撤回设计 A-B Design: Baseline (A), Treatment (B) A-B-A Design: Baseline (A), Treatment (B), Withdrawal (A) A-B-A-B Design: Baseline (A), Treatment (B), Withdrawal (A), Treatment (B) again Multiple Baseline Designs 多基线设计 Variations include multiple subjects, multiple behaviors, multiple environments 变体包括多个受试者，多个行为，多个环境 Changing Criterion Designs 变化标准设计 For behaviors that must be changed gradually 对必须逐步改变的行为 Alternating Treatments Designs 交替处理设计 Compares the relative effectiveness of two or more treatments 比较两种或多种治疗的相对效果 Case Study Designs 案例研究设计 Detailed Analysis 详细分析 Incorporates other methods (e.g., observation, psychometric tests) 融合其他方法（如观察、心理测量测试） Evaluating Case Studies 评估案例研究 Strengths: Level of detail not found elsewhere 优势：独有的详细程度 Limitations: Limited control, external validity issues 限制：有限的控制，外部效度问题 Summary 总结 Surveys are used to obtain information primarily about attitudes, beliefs, opinions and/or projected behaviors.调查主要用于获取关于态度、信仰、观点和/或预测行为的信息。 Correlation and regression are statistical techniques that can be used to analyze data from non-experimental designs, including survey data.相关和回归是统计技术，可以用来分析非实验性设计的数据，包括调查数据。 Observational methods are used to assess natural behaviors either in their natural setting or in a lab setting.观察方法用于评估自然环境或实验室环境中的自然行为。 Quasi-experimental designs are used when participants cannot be randomly assigned to groups, and include: nonequivalent control group and interrupted time series designs.当参与者不能随机分配到组时使用准实验性设计，包括：不等价对照组设计和中断时间序列设计。 Program evaluation is used to assess the effectiveness of large-scale programs.项目评估用于评估大规模项目的效果。 Small N designs are used when individual-subject validity is weak and when studying individuals from rare populations.当个体受试者效度较弱时，以及研究稀有人群时使用小样本设计。 Case studies are in-depth analyses of one or a few people, usually to develop treatment plans or obtain knowledge.案例研究是对一个或几个人的深入分析，通常是为了制定治疗计划或获取知识。","link":"/psy2013-lecture-06-notes/"},{"title":"PSY2033 Ch02 Lecture Notes","text":"PSY2033 Developmental Psychology Ch02 Theory and Research Learning Objectives 学习目标 Describe the purpose of a theory in research and two theoretical issues on which developmental scientists differ.描述理论在研究中的目的以及发展科学家存在分歧的两个理论问题。 Summarize the main theories of human development.概述人类发展的主要理论。 Describe the methods of developmental research used to collect data and the advantages and disadvantages of each.描述用于收集数据的发展研究方法及其优缺点。 Explain ethical guidelines for researchers who study people.解释研究人类的伦理指南。 Basic Theoretical Terms 基本理论术语Theory 理论 Definition 定义 Logically related concepts that describe and explain development, predict behavior under certain conditions, and uncover connections between isolated data. 逻辑相关的概念，用于描述和解释发展，预测在特定条件下可能发生的行为，并发现孤立数据之间的联系。 Hypotheses 假设 Definition 定义 Explanations that can be tested by further research. 可以通过进一步研究检验的解释。 Two Theoretical Issues 两个理论问题 Is development active or reactive?发展是主动的还是被动的？ Is development continuous or discontinuous?发展是连续的还是间断的？ Active vs. Reactive 主动 vs 被动Mechanistic Model 机械模型 Definition 定义 Human development as a series of predictable responses to stimuli; reactive; people are like machines. 人类发展被视为对刺激的可预测反应；被动的；人如同机器。 酗酒：机械主义理论家会寻找环境因素，如广告和同伴影响。 Organismic Model 有机模型 Definition 定义 Human development is internally initiated by an active organism; occurs in a sequence of qualitatively different stages. Environmental factors do not cause development, though they can speed or slow it 环境因素不能 cause 发展，尽管可以加速或减速 人类发展是由一个主动的有机体内部发起的；在质上不同的阶段中发生。 Example 例子 Binge drinking: Do individuals choose friends who prefer to party or study? 酗酒：个体是否选择喜欢聚会或学习的朋友？ Continuous vs. Discontinuous 连续 vs 间断Quantitative Change 定量变化 Mechanistic Theories 机械理论 Development involves the same processes continuously. 发展涉及相同的连续过程。 Qualitative Change 定性变化 Organismic Theories 有机理论 Development involves different processes at different stages. 发展在不同阶段涉及不同的过程。 Theoretical Perspectives 理论视角Perspective 1: Psychoanalytic 精神分析Freud’s Psychosexual Development 弗洛伊德的性心理发展理论 Hypothetical Parts of Personality 假设的性格部分 Id, ego, and superego. 本我、自我和超我。 Erikson’s Psychosocial Development 埃里克森的社会心理发展理论 Stages 阶段 Each stage involves a “crisis” that must be resolved. 每个阶段都涉及必须解决的“危机”。 Trust vs. Mistrust (Infancy 婴儿期): Developing trust in caregivers and the environment. 信任对不信任（婴儿期）：对照顾者和环境产生信任。 Autonomy vs. Shame and Doubt (Early Childhood 早期童年): Developing a sense of personal control and independence. 自主对羞耻和怀疑（早期童年）：发展个人控制和独立意识。 Initiative vs. Guilt (Preschool 学龄前): Initiating activities and asserting control over the environment. 主动性对内疚（学龄前）：发起活动并对环境进行控制。 Industry vs. Inferiority (School Age 学龄期): Developing a sense of competence and achievement. 勤奋对自卑（学龄期）：发展成就感和能力感。 Identity vs. Role Confusion (Adolescence 青春期): Developing a coherent sense of self and identity. 身份认同对角色混乱（青春期）：发展连贯的自我和身份认同。 Intimacy vs. Isolation (Young Adulthood 青年期): Forming intimate relationships with others. 亲密对孤立（青年期）：与他人形成亲密关系。 Generativity vs. Stagnation (Middle Adulthood 中年期): Contributing to society and supporting the next generation. 繁衍对停滞（中年期）：为社会做贡献并支持下一代。 Ego Integrity vs. Despair (Late Adulthood 晚年期): Reflecting on life and feeling a sense of fulfillment or regret. 自我完整对绝望（晚年期）：反思生活，感到满足或遗憾。 Perspective 2: Learning 学习Behaviorism 行为主义 Definition 定义 Views human development as long-lasting change in behavior based on experience. 将人类发展视为基于经验的行为持久变化。 Key Concepts 关键概念 Classical Conditioning 经典条件反射: Learning through association (e.g., Pavlov’s dogs). 通过联想学习（例如，巴甫洛夫的狗）。 Operant Conditioning 操作性条件反射: Learning through reinforcement and punishment (e.g., Skinner’s box). 通过强化和惩罚学习（例如，斯金纳的箱子）。 Social Learning Theory 社会学习理论 Albert Bandura 阿尔伯特·班杜拉 Behaviors are learned by observing and imitating models. 行为通过观察和模仿模型而学习。 Key Concepts 关键概念 Reciprocal Determinism 相互决定论: The person acts on the world, and the world acts on the person. 个人对世界的影响，世界对个人的影响。 Self-efficacy 自我效能感: Belief in one’s ability to succeed. 相信自己成功的能力。 Perspective 3: Cognitive 认知Cognitive-Stage Theory 认知阶段理论 Jean Piaget 让·皮亚杰 关注反映这些过程的思维过程和行为。 Key Stages 关键阶段 Sensorimotor Stage 感知运动阶段: Birth to 2 years; learning through sensory and motor interactions. 出生到2岁；通过感官和运动互动学习。 Preoperational Stage 前运算阶段: 2 to 7 years; developing language and symbolic thinking. 2到7岁；发展语言和符号思维。 Concrete Operational Stage 具体运算阶段: 7 to 11 years; logical thinking about concrete objects. 7到11岁；对具体事物的逻辑思维。 Formal Operational Stage 形式运算阶段: 11 years and up; abstract and hypothetical thinking. 11岁及以上；抽象和假设思维。 Sociocultural Theory 社会文化理论 Lev Vygotsky 列夫·维果斯基 Views cognitive growth as a collaborative process. 将认知成长视为一个协作过程。 Key Concepts 关键概念 Zone of Proximal Development (ZPD) 最近发展区: The difference between what a child can do alone and what they can do with help. 孩子独自能做的事情和在帮助下能做的事情之间的差距。 Scaffolding 支架: Temporary support to help a child master a task. 临时支持帮助孩子掌握任务。 Information-Processing Approach 信息处理方法 Definition 定义 Analyzes processes involved in making sense of incoming information. 分析理解输入信息过程中涉及的过程。 Key Concepts 关键概念 Focuses on the ways children process, store, and retrieve information. 关注儿童处理、存储和检索信息的方式。 Neo-Piagetian Theories 新皮亚杰理论 Definition 定义 Combines Piaget’s theory with information-processing approaches. 结合皮亚杰理论和信息处理方法。 Key Concepts 关键概念 Emphasizes the variability in cognitive development across different domains. 强调不同领域中认知发展的可变性。 Perspective 4: Contextual 语境 Bioecological Theory 生物生态理论 Urie Bronfenbrenner 乌里·布伦芬布伦纳 Development can be understood only in its social contexts. 发展只能在其社会语境中理解。 Key Concepts 关键概念 Microsystem 这是个体直接接触和互动的环境，包括家庭、学校、同伴关系等。在这个层次上，个体与环境之间的相互作用是最直接和最亲密的。 Mesosystem 这是指不同 Microsystem 之间的相互关系和相互作用。例如，家庭与学校之间的互动，父母与老师之间的交流等。 Exosystem 这是个体并不直接参与但会间接影响个体发展的环境，例如父母的工作场所、社区服务、地方政府政策等。 Macrosystem 这是指更广泛的文化、社会价值观、法律和经济系统，这些都会影响个体的成长和发展。 Perspective 5: Evolutionary 进化 Darwin’s Evolutionary Theory 达尔文的进化论 Key Concepts 关键概念 Survival of the Fittest 适者生存: Animals with traits suited to the environment survive. Natural Selection 自然选择: Traits change in adaptiveness as environments change. 适应环境的动物存活下来。 随着环境变化，特征的适应性也会变化。 Ethology 动物行为学 Definition 定义 Study of distinctive adaptive behavior of animal species. 研究动物物种独特的适应性行为。 Key Concepts 关键概念 Innate behaviors evolved to increase survival odds. 进化出的先天行为以提高生存几率。 Examples: Imprinting, squirrels burying nuts. 示例：印记行为，松鼠埋坚果。 Evolutionary Psychology 进化心理学 Definition 定义 How biology and environment interact to produce behavior and development. 生物和环境如何相互作用产生行为和发展。 Key Concepts 关键概念 Development of mechanisms to solve problems for personal survival and genetic legacy. 为个人生存和基因遗传而发展出解决问题的机制。 Example: Morning sickness in pregnant women as a protective mechanism. 示例：孕妇的晨吐作为保护机制。 Research Design 研究设计Developmental Research Designs 发展研究设计 Cross-sectional 纵断面设计 在某一时间点评估人们。 Advantages 优点: 快速且成本效益高。 Disadvantages 缺点: 无法推断随时间的变化。 Longitudinal 纵向设计 同一人多次研究。 Advantages 优点: 可以跟踪随时间的变化 Disadvantages 缺点: 耗时且昂贵，存在参与者退出的风险。 Sequential 序列设计 结合纵断面和纵向设计。 Advantages 优点: 结合两种设计的优点，增加更多数据。 Disadvantages 缺点: 复杂且资源密集。 Research Ethics 研究伦理 Milgram Experiments 米尔格伦实验 Acute Effects 急性效应: 大多数参与者表现出极度不安。 Chronic Effects 慢性效应: 使用解密和后续跟进不一致。米尔格伦声称大多数参与者表示从中受益，但最近的调查对此表示怀疑。","link":"/psy2033-ch02-lecture-notes/"},{"title":"PSY2033 Ch01 Lecture Notes","text":"PSY2033 Developmental Psychology Ch01 The Study of Human Development Learning Objectives 学习目标 Describe human development and how its study has evolved.描述人类发展的概念及其研究的演变。 Describe the domains and periods of human development.描述人类发展的领域和时期。 Give examples of the influences that make one person different from another.举例说明影响个体差异的因素。 Discuss the principles of the lifespan perspective.讨论生命周期观点的原则。 Why We Study Human Development 为什么我们研究人类发展？Research Findings and Applications 研究发现与应用 School Breakfast Program 学校早餐计划 参与学校早餐计划可以提高日常营养摄入量，营养摄入量的提高与学生学业表现和心理社会功能的显著改善以及饥饿感的减少有关。 Teen Drug Use 青少年药物使用 一位研究人员承诺，如果她的女儿到21岁之前不使用任何毒品，就会支付她1000美元。这突显了早期使用物质的青少年成瘾风险更高。 Adolescent Brain Development 青少年大脑发育 The prefrontal cortex, which handles reasoning, grows during the pre-teen years but is pruned back during adolescence, increasing impulsive, risk-taking behavior and susceptibility to addiction. 前额叶皮质负责推理，在青春前期发育，但在青春期会被修剪，增加了冲动、冒险行为和成瘾的易感性。 Human Development: Scientific Discipline 人类发展：科学学科 Definition 定义 Scientific study of the systematic processes of change and stability in people. 人类发展的科学研究是研究人类变化和稳定的系统过程。 Goals 目标 Describe 描述 When do children say their first words? 孩子什么时候说出第一个词？ Explain 解释 How do children learn to use language? 孩子们如何学习使用语言？ Predict 预测 Will delayed language development affect speech? 语言发育迟缓是否会影响语言能力？ Modify 修改 Can therapy intervene speech delays? 治疗是否可以干预语言延迟？ Basic Concepts in Studying Human Development 研究人类发展的基本概念Domains of Development 发展领域 Physical Development 物理发展 Growth of the body and brain, sensory capabilities, motor skills, health. 身体和大脑的成长、感官能力、运动技能、健康。 Cognitive Development 认知发展 Learning, attention, memory, language, thinking, reasoning, creativity. 学习、注意力、记忆、语言、思考、推理、创造力。 Psychosocial Development 心理社会发展 Emotions, personality, social relationships. 情感、个性、社会关系。 Interaction Between Domains 领域间的互动 耳部感染影响语言发展；青春期影响自我意识。 Periods of the Life Span 生命周期的阶段Social Construction 社会建构 Division of the life span into periods is an invention of a particular culture or society. 将生命周期分为几个阶段是某一特定文化或社会的发明。 Stages 阶段 Prenatal Period 产前期 Conception–Birth Infancy and Toddlerhood 婴儿期和幼儿期 Birth–3 years Early Childhood 早期童年 3–6 years Middle Childhood 中期童年 6–11 years Adolescence 青春期 11–20 years Young Adulthood 青年期 20–40 years Middle Adulthood 中年期 40–65 years Late Adulthood 晚年期 65 years and over Influences on Development 影响发展的因素 Normative Influences 规范性影响 Normative Age-Graded Influence 规范性年龄分级影响 Similar for an age group; e.g., puberty. 对一个年龄组相似；例如青春期。 Normative History-Graded Influence 规范性历史分级影响 Events that shape attitudes of a historical generation; e.g., WWII. 影响历史一代人态度的事件；例如二战。 Non-Normative Influences 非规范性影响 Unusual events that have a major impact on individual’s lives; e.g., death of parents when young. 对个体生活有重大影响的不寻常事件；例如幼年失去父母。 Atypical time: Atypical event: Timing of Influence 影响的时机 Is there a critical period for language acquisition? Case studies and research findings. 是否存在语言习得的关键期？案例研究和研究结果。 Contexts of Development 发展的背景Family 家庭 Nuclear Family 核心家庭 One or two parents and their children. 一或两个父母和他们的孩子。 Extended Family 扩展家庭 Multigenerational network. 多代网络。 Socioeconomic Status and Neighborhood 社会经济地位和社区 Income, education, occupation. 收入、教育、职业。 Culture and Race 文化和种族 Customs, traditions, laws, knowledge, beliefs and values, languages. 习俗、传统、法律、知识、信仰和价值观、语言。 Historical Context 历史背景 Unique time in which people live and grow up. 人们生活和成长的独特时间。 Conclusion 结论 The study of human development helps in understanding how individuals grow and change over time and the factors that influence these processes. 研究人类发展有助于理解个体如何随时间成长和变化以及影响这些过程的因素。","link":"/psy2033-ch01-lecture-notes/"},{"title":"PSY2033 Ch04 Lecture Notes","text":"PSY2033 Developmental Psychology Ch04 Birth and Physical Development during the First Three Years Outline 大纲 Childbirth and Culture 分娩和文化 The Birth Process 分娩过程 The Newborn Baby 新生儿 Complications of Childbirth 分娩并发症 Survival and Health 生存与健康 Early Physical Development 早期身体发育 Motor Development 运动发育 Childbirth Mortality Rate 分娩死亡率 Childbirth 分娩 Dramatic reductions in the mortality rate are due to 减少死亡率的显著原因: Antibiotics 抗生素 Blood transfusions 输血 Safe anesthesia 安全麻醉 Improved hygiene 改善卫生 Drugs for inducing labor 引产药物 Improvements in prenatal assessment and care 改善产前评估和护理 Home Birth 家庭分娩 Trends 趋势: Increase in home births in the US from 1990 to 2021 美国1990年至2021年家庭分娩增加 Home births accounted for 1.41% of all deliveries in 2021 2021年家庭分娩占所有分娩的1.41% Concept Check 概念检查: Research shows that home births with a plan for hospitalization for emergencies can be 研究表明，有紧急住院计划的家庭分娩可能是: B. As safe as a hospital birth. 与医院分娩一样安全。 The Newborn Baby 新生儿Neonatal Period 新生儿期 First 4 weeks of life 生命的前4周 Entire support from mother, transitioning to an independent existence 完全依赖母亲，过渡到独立存在 Loss of body weight in the first few days due to fluid loss 在最初几天体重减少是由于失水 Fontanels 囟门: Flexible skull bones that ease birth, close by 18 months 柔软的颅骨帮助分娩，18个月内闭合 Lanugo 胎毛: Fuzzy prenatal hair 柔软的胎毛 Vernix Caseosa 胎脂: Oily protection against infection, dries within a few days 预防感染的油性保护层，几天内干燥 Newborn Body System 新生儿体系统 Umbilical Cord and Placenta 脐带和胎盘: During pregnancy, fetus gets oxygen through the umbilical cord, which carries used blood to the placenta and returns a fresh supply 怀孕期间，胎儿通过脐带获取氧气，脐带将用过的血液运送到胎盘，再返回新鲜的血液 Anoxia 缺氧: If a neonate does not begin breathing within about 5 minutes, may suffer permanent brain injury 如果新生儿在约5分钟内未开始呼吸，可能会遭受永久性脑损伤 Meconium 胎便: Greenish-black waste matter formed in the fetal intestinal tract, excreted in the first few days 胎儿肠道形成的绿色黑色废物，出生后几天内排出 Neonatal Jaundice 新生儿黄疸: Yellowing of skin and eyeballs due to immaturity of the liver, common in half of all babies, usually does not need treatment 由于肝脏未成熟，皮肤和眼球黄染，半数新生儿常见，通常不需要治疗 Concept Check 概念检查: The condition of a baby whose Apgar score is 3 is Apgar评分为3的新生儿的情况是: D. Dangerous; the baby needs immediate resuscitation. 危险；需要立即复苏。 Principle of Development 发育原则Principles 原则 Cephalocaudal Principle 头尾原则: Development proceeds from head to tail 发育从头到尾进行 Example: Grasping before walking 例子：先抓握再行走 Proximodistal Principle 近远原则: Development proceeds from inner to outer 发育从内向外进行 Example: Head and trunk develop before arms and legs, then hands and feet, then fingers and toes 例子：头部和躯干先于手臂和腿部发育，然后是手和脚，然后是手指和脚趾 Brain Development during Gestation 胎儿期的脑发育 Brain Recap 脑总结 Glial Cells 神经胶质细胞: Cells that support and protect neurons 支持和保护神经元的细胞 Lateralization 大脑半球功能侧化: Specialization of function in each hemisphere 每个大脑半球的功能专门化 Corpus Callosum 胼胝体: Reaches adult size by age 10 10岁时达到成人大小 Cerebral Cortex 大脑皮层: Outer surface of cerebrum, matures by 6 months 大脑的外表面，6个月时成熟 Concept Check 概念检查: Why are babies’ heads so large in proportion to their body size? 为什么婴儿的头部相对于身体尺寸这么大？ B. The baby’s brain and head are more developed than other parts of the body. 婴儿的脑部和头部比身体的其他部分更发达。 Reflexes and Motor Development 反射与运动发育Reflexes 反射 Primitive Reflexes 原始反射 Rooting, sucking, and grasping reflexes 寻乳、吸吮和抓握反射 Postural Reflexes 姿势反射 Reactions to changes in posture or balance 对姿势或平衡变化的反应 Locomotor Reflexes 移动反射 Walking and swimming reflexes 行走和游泳反射 Motor Development 运动发育 Stages 阶段 Lifting head, rolling over, sitting up, crawling, standing, walking 抬头、翻身、坐起、爬行、站立、行走 Concept Check 概念检查: Rank the motor development stages in the correct order. 按正确顺序排列运动发育阶段。 Brain Development 脑发育Early Brain Development 早期脑发育 Spinal Cord + Brain Stem 脊髓和脑干 Fully developed by birth 出生时完全发育 Cerebellum 小脑 Develops during the first year 在第一年发育 Cerebral Cortex 大脑皮层 Matures by 6 months 6个月时成熟 Plasticity 可塑性 Definition 定义 Molding of the brain through experience 通过经验塑造大脑 Two Sides of the Coin 硬币的两面 Positive 积极: Enables learning to adapt to the environment 使学习适应环境 Negative 消极: Can lead to damage if exposed to harmful inputs (e.g., toxins, stress) 如果暴露于有害输入（如毒素、压力），可能导致损害 Early Sensory Capabilities 早期感官能力Touch and Pain 触觉和疼痛 First sense to develop 首先发育的感官 Rooting reflex, ability to experience pain at birth 寻乳反射，出生时能体验疼痛 Smell and Taste 嗅觉和味觉 Develops in womb 在子宫内发育 Newborns prefer sweet tastes 新生儿喜欢甜味 Hearing 听觉 Functional before birth 出生前起作用 3-day-olds can distinguish new speech sounds 3天大的婴儿可以区分新的语音 Sight 视觉 Least developed at birth 出生时最不发达 20/20 vision by 6 months 6个月时达到20/20视力 Binocular vision (depth perception) develops around 4.5 months 双目视觉（深度感知）在4.5个月左右发育 Motor Development 运动发育Ecological Theory of Perception 生态知觉理论 James J. Gibson and Eleanor J. Gibson Locomotor development depends on infants’ increasing sensitivity to the interaction between their changing physical characteristics and new and varied characteristics of their environment. 运动发育取决于婴儿对其变化的身体特征与环境中新特征之间相互作用的敏感性。 Dynamic Systems Theory 动态系统理论 Ester Thelen Learning occurs through detecting the many features of an environment 学习通过检测环境的许多特征发生 With experience, babies learn to gauge their environment 随着经验，婴儿学会评估其环境 Cultural Influences on Motor Development 文化对运动发育的影响 Cultural Practices 文化实践 African and West Indian cultures encourage early motor strength 非洲和西印度群岛文化鼓励早期运动力量 Other cultures may discourage early movement 其他文化可能不鼓励早期运动","link":"/psy2033-ch04-lecture-notes/"},{"title":"PSY2033 Ch05 Lecture Notes","text":"PSY2033 Developmental Psychology Ch05 Cognitive Development during the First Three Years Outline 大纲 Six different approaches 六种不同的研究方法 Language development 语言发展 Cognitive Development – Six Approaches 认知发展 – 六种方法Behaviorist Approach 行为主义方法 Focus 重点: Study the basic mechanics of learning; how behavior changes in response to experience 研究学习的基本机制；行为如何随经验而改变 Classical Conditioning 经典条件反射 Definition 定义: Prediction of an event based on the association with a natural stimulus 通过与自然刺激的联系预测事件 Operant Conditioning 操作性条件反射 Definition 定义: Consequences of behavior and how they affect the likelihood of that behavior 行为的结果及其对行为发生可能性的影响 Infant Memory 婴儿记忆 Infantile Amnesia 婴儿期遗忘症 Explanation 解释: Piaget: Brain is not developed enough to store memory 大脑发育不够完善，无法储存记忆 Freud: Early memories are stored but often repressed because they are emotionally distressing 早期记忆被储存，但由于情感上的痛苦经常被压抑 Nelson: Evolutionary approach, abilities develop as they become useful for adaptation 进化论观点，能力随着适应需求的发展而发展 Research 研究: Operant Conditioning with Mobiles 操作性条件反射与婴儿床移动物 Findings 发现: 2-month infants remember the conditioned response for 2 days 2个月大的婴儿记得条件反射2天 18-month toddlers remember the conditioned response for 13 weeks 18个月大的幼儿记得条件反射13周 Length of time a conditioned response lasts increases with age 条件反射持续时间随着年龄增加而增加 Psychometric Approach 心理测量方法 Focus 重点: Quantify the factors that make up intelligence and predict future performance 量化构成智力的因素并预测未来表现 Testing Infants and Toddlers 测试婴幼儿 Bayley Scales 贝利量表 Purpose 目的: Assess children from 1 month to 3.5 years in five developmental areas 评估1个月至3.5岁儿童的五个发展领域 Developmental Areas 发展领域: Cognitive, language, motor, social-emotional, adaptive behavior 认知、语言、运动、社会情感、适应行为 Finding 发现: Early measures of infant behavior have low predictive validity for later intelligence except in extreme cases 婴儿行为的早期测量对后期智力的预测效度较低，除非在极端情况下 Early Home Environment 早期家庭环境 HOME: Home Observation for Measurement of the Environment 家庭观察量表 Parental Responsiveness 父母反应 Positively correlated with IQ, achievement test scores, classroom behavior 与智商、成就测试分数、课堂行为正相关 Learning Stimulation 学习刺激 Number of books, educational playthings 书籍数量，教育玩具 Associated with kindergarten achievement scores, language competence, motor and social development 与幼儿园成就分数、语言能力、运动和社会发展相关 Piagetian Approach 皮亚杰方法 Jean Piaget’s Theory of Cognitive Development 皮亚杰的认知发展理论 Stages 阶段: Sensorimotor Stage 感知运动阶段: Birth to 2 years 出生至2岁 Preoperational Stage 前运算阶段: Ages 2 to 7 2至7岁 Concrete Operational Stage 具体运算阶段: Ages 7 to 11 7至11岁 Formal Operational Stage 形式运算阶段: Ages 12 and up 12岁及以上 Substages of Sensorimotor Stage 感知运动阶段的子阶段: Reflexes Reactions (0-1 month) 反射 婴儿主要依赖先天的反射动作，如吸吮和抓握。 e.g. 当婴儿的嘴唇碰到乳头时，他们会自然地吸吮。 Primary Circular Reactions (1-4 months) 初级循环反应 婴儿开始重复有趣或愉快的身体内部动作，通常涉及他们自己的身体。 e.g. 婴儿会重复吮吸拇指，因为这给他们带来舒适感。 Secondary Circular Reactions (4-8 months) 次级循环反应 婴儿开始重复那些对外部世界有影响的动作，探索外部环境的反应。 为了得到超出自已身体范围 重复一个涉及外部对象的行为 e.g. 婴儿摇动一个带响铃的玩具，因为他们发现这样可以发出声音。 Coordination of Secondary Circular Reactions (8-12 months) 协调次级计划 婴儿开始将多个次级循环反应进行协调，表现出早期的问题解决能力和目标导向行为。 主要是发展目的和手段之间的协调能力 e.g. 婴儿会推动障碍物以便拿到藏在后面的玩具。 Tertiary Circular Reactions(12-18 months) 三级循环反应 发现新的手段，来达成目标 e.g. 婴儿会反复从不同高度将玩具扔到地上，以观察结果的不同。 Mental Representation (18-24 months) 心理表征 婴儿开始发展出心理表征，即在头脑中形成物体和事件的内部图像，可以进行延迟模仿和假装游戏。 婴儿会假装用玩具电话打电话，模仿成人的行为。 Concepts 概念: Circular Reaction 循环反应: Infant learns to reproduce events originally discovered by chance 婴儿学会重现偶然发现的事件 Object Permanence 物体永恒性: Understanding that objects continue to exist even when they cannot be seen 理解物体即使看不见也依然存在 Imitative Abilities 模仿能力: Visible Imitation 可见模仿 Invisible Imitation 不可见模仿 Deferred Imitation 延迟模仿 Elicited Imitation 引导模仿 Information-Processing Approach 信息处理方法 Focus 重点: Analyze the separate parts of a complex task to figure out necessary abilities and their development age 分析复杂任务的各个部分，以确定所需的能力及其发展年龄 Concepts 概念: Habituation 习惯化: Reduced response to familiar stimulus 对熟悉的刺激反应减少 Dishabituation 去习惯化: Increased response to new stimulus 对新刺激的反应增加 Visual Preference 视觉偏好: Preference for new visual stimuli, showing recognition memory 对新视觉刺激的偏好，显示识别记忆 Cross-Modal Transfer 跨模态转移: Using one sense to guide another sense 使用一种感官指导另一种感官 Joint Attention 共同注意: Following an adult’s gaze, important for social interaction and language acquisition 跟随成人的视线，对社会互动和语言习得很重要 Predictors of Intelligence 智力预测 Visual Expectation Paradigm 视觉期望范式 Measures visual reaction time and visual anticipation 测量视觉反应时间和视觉预期 Categorization 分类: Perceptual 感知: Based on how things look 根据外观分类 Conceptual 概念: Based on what things are 根据事物的性质分类 Cognitive Neuroscience Approach 认知神经科学方法 Focus 重点: Neurological maturation as a factor in cognitive development 神经系统成熟是认知发展的一个因素 Brain Growth Spurts 脑生长突增: Coincide with cognitive changes 与认知变化同时发生 Memory Systems 记忆系统: Explicit Memory 外显记忆: Conscious recollection of facts and events 对事实和事件的有意识回忆 Implicit Memory 内隐记忆: Unconscious recollection, such as habits and skills 无意识的回忆，如习惯和技能 Hippocampus and Prefrontal Cortex 海马体和前额皮质: Develop for long-term and working memory 发展用于长期记忆和工作记忆 Social-Contextual Approach 社会-情境方法 Focus 重点: Guided participation with adults in activities 与成人在活动中引导参与 Cultural Differences 文化差异 US Children 美国儿童: More play activities 更多的玩耍活动 Guatemalan Children 危地马拉儿童: More work activities 更多的工作活动 Language Development 语言发展Early Stages of Language Development 语言发展的早期阶段 Early Vocalization 早期发声 Crying 哭泣 Cooing 咿呀学语: Repeating vowel sounds, starts around 6-8 weeks 重复元音音，约6-8周开始 Babbling 咿呀学语: Repeating consonant sounds, starts around 6-10 months 重复辅音音，约6-10个月开始 Phonemes 音素 Definition 定义: Smallest units of sound in speech 语音中的最小声音单位 Discrimination 辨别: Infants can initially discriminate sounds of any language 婴儿最初可以辨别任何语言的声音 First Words and Sentences 第一词汇和句子 First Words 第一词汇: Around 10-14 months, verbal expression that conveys meaning 约10-14个月，表达意义的口语 Holophrase 单词句: Single words with complex meanings 单词具有复杂的意义 First Sentences 第一句子: Around 18-24 months, telegraphic speech using 2-3 words 约18-24个月，使用2-3个词的电报式语言 Syntax 句法: Rules for putting sentences together, gradually increases 句子组合规则，逐渐增加 Early Speech Characteristics 早期语言特点 Underextension 词义狭化: Word used only for specific object 词只用于特定对象 Overextension 词义泛化: Word used for a broader range of objects 词用于更广泛的对象 Overregularization 过度规则化: Applying grammatical rules too widely 过度广泛地应用语法规则","link":"/psy2033-ch05-lecture-notes/"},{"title":"PSY2033 Ch07 Lecture Notes","text":"PSY2033 Developmental Psychology Ch07 Physical and Cognitive Development in Early Childhood (3-6) Outline 大纲 Physical changes in early childhood 早期儿童的身体变化 Three views of the cognitive changes that occur in early childhood 早期儿童认知变化的三种观点 Early language development 早期语言发展 Early childhood education 早期儿童教育 Physical Changes 身体变化General Physical Changes 一般身体变化 Slim down and shoot up 瘦下来并长高 Less sleep &amp; More sleep problems 睡眠减少和更多的睡眠问题 Begin to show handedness 开始显示出利手性 Improvement in motor skills 运动技能的提高 Examples: running, hopping, skipping, jumping, and throwing balls 例如：跑步、跳跃、跳绳、跳跃和投掷球 Cartilage turns to bone at a faster rate 软骨转化为骨头的速度加快 Bones become harder, providing a firmer shape and protecting internal organs 骨骼变硬，提供更坚固的形状，保护内脏 Sleep Patterns 睡眠模式 By age 5, most U.S. children 到5岁时，大多数美国儿童： Average about 11 hours of sleep a night 每晚平均睡眠约11小时 Give up naps 放弃午睡 Cultural variations in bedtime 不同文化的睡眠时间差异： Zuni 祖尼人: No regular bedtime, sleep when sleepy 没有固定的睡觉时间，困了就睡 Canadian Hare 加拿大野兔人: Bedtime after dinner, no naps, sleep as long as they wish in the morning 晚饭后睡觉，不午睡，早晨睡到自然醒 Sleep Disturbances 睡眠障碍 Causes 原因: Accidental activation of the brain’s motor control system 脑部运动控制系统的意外激活 Incomplete arousal from deep sleep 深度睡眠中的不完全唤醒 Disordered breathing or restless leg movements 呼吸紊乱或不安腿运动 Types of sleep disturbances 睡眠障碍的类型: Night Terrors 夜惊 Abrupt awakening from deep sleep, extremely frightened 深度睡眠中的突然醒来，非常害怕 Walking and Talking 梦游和说梦话 Fairly common, best not to interrupt 相当常见，最好不要打断 Nightmares 恶梦 Common, caused by staying up too late, eating too much before sleep, overexcitement 常见，由熬夜、睡前吃太多或过度兴奋引起 Frequent nightmares may signal excessive stress 频繁的恶梦可能表明过度的压力 Bed-wetting (Enuresis) 尿床 Involuntary urination at night, more common in boys, about 10-15% of 5-year-olds 夜间不自主排尿，男孩更常见，约10-15%的5岁儿童 Brain Development 脑发育 Rapid and Profound 快速而深远 Age 3: Brain is approx. 90% of adult weight 大脑约为成人重量的90% Age 3-6: Frontal areas regulate planning and goal setting, density of synapses in prefrontal cortex peaks at age 4 3-6岁：额叶区域调节计划和目标设定，前额皮质的突触密度在4岁时达到峰值 Age 6: Brain is at 95% peak volume 大脑达到峰值体积的95% Corpus Callosum 胼胝体: Linking left and right hemispheres 连接左、右半球 Improves coordination of senses, attention, arousal, speech, hearing 改善感官协调、注意力、唤醒、言语、听力 Myelination continues until age 15 髓鞘化持续到15岁 Motor Skills 运动技能 Gross motor skills 大运动技能 Involves large muscle groups, e.g., jumping and running 涉及大肌肉群，例如跳跃和跑步 Fine motor skills 精细运动技能 Using eye-hand and small-muscle coordination, e.g., buttoning a shirt, drawing pictures 使用眼手和小肌肉协调，例如扣纽扣、画画 Handedness 利手性 Usually evident by age 3 通常在3岁时显现 Boys are more likely to be left-handed than girls 男孩比女孩更有可能左撇子 Environmental influence 环境影响: Low birth weight and difficult deliveries are associated with left-handedness 低出生体重和困难分娩与左撇子有关 Twins and triplets are more likely to be left-handed than singletons 双胞胎和三胞胎比单胎更可能左撇子 Artistic Development 艺术发展 Universal progression of changes 普遍的变化进程: Age 2: Scribble, not randomly but in patterns (vertical and zigzag lines) 涂鸦，不是随机的，而是有模式的（垂直和锯齿线） Age 3: Shapes (circles, squares, rectangles, triangles, crosses, and Xs) 形状（圆形、方形、矩形、三角形、十字和X形） Age 4-5: Pictorial Stage, switch from abstract form to depicting real objects 图画阶段，从抽象形式转向描绘真实物体 Health and Safety 健康和安全 Preventing obesity 预防肥胖 Undernutrition 营养不良 Food allergies 食物过敏 Death and accidental injuries 死亡和意外伤害 Health in Context: SES, Homelessness, Pollutants 环境中的健康：社会经济地位、无家可归、污染物 Exposure to Pollutants 曝露于污染物: Parental smoking increases the risk of respiratory infections 父母吸烟增加呼吸道感染的风险 Air pollution increases the risk of chronic respiratory diseases 空气污染增加慢性呼吸道疾病的风险 Pesticide poisonings mostly occur in young children 杀虫剂中毒主要发生在幼儿 Cognitive Development 认知发展Piagetian Approach: Preoperational Child 皮亚杰方法：前运算阶段 Cognitive Advances 认知进步: Symbolic thinking 符号思维 Understanding of identities 理解身份 Understanding of cause and effect 理解因果关系 Ability to classify 分类能力 Understanding of number 数字理解 Empathy 同理心 Theory of mind 心理理论 Immature Aspects 未成熟方面: Centration: Inability to decenter 集中化：不能分心 Irreversibility 不可逆性 Focus on states rather than transformations 关注状态而非变化 Transductive reasoning 直觉推理 Egocentrism 自我中心 Animism: Attribute life to inanimate objects 拟人化：赋予无生命物体生命 Inability to distinguish appearance from reality 无法区分外表与现实 Understanding Objects in Space 理解空间中的物体 Challenges for children under age 3 对3岁以下儿童的挑战: Difficulty understanding scale models and maps 困难理解比例模型和地图 Advancing spatial thinking 提升空间思维: Using simple maps and models becomes easier after age 3 3岁后使用简单的地图和模型变得更容易 False Belief and Deception 错误信念与欺骗 Understanding false beliefs 理解错误信念: Related to awareness of false beliefs 与错误信念的意识相关 Requires the ability to refer to two conflicting mental representations simultaneously 需要能够同时参考两个冲突的心理表征 Fantasy vs. Reality 幻想与现实 Distinguishing between real and imagined events 区分真实和想象的事件 Magical thinking declines near the end of the preschool period 幼儿园阶段结束时，魔法思维下降 Theory-of-Mind Development 心理理论发展 Influences 影响: Infant social attention 婴儿社会注意力 Social skills 社交技能 Encouragement from families 家庭的鼓励 Bilingual children show better performance in theory-of-mind tasks 双语儿童在心理理论任务中表现更好 Information-processing Approach 信息处理方法Memory Development 记忆发展 Young children 年幼儿童: Focus on exact details of an event 专注于事件的确切细节 May fail to notice important aspects of a situation 可能忽略情况的重要方面 Older children and adults 年长儿童和成人: Generally concentrate on the gist of what happened 通常专注于事件的要点 Types of Memory 记忆类型 Sensory Memory 感官记忆: Temporary storehouse for incoming sensory information 感官信息的临时存储 Fades quickly without encoding 如果不编码会迅速消退 Working Memory 工作记忆: A short-term storehouse for information 短期信息存储 Limited capacity, permits the development of executive function 容量有限，允许执行功能的发展 Executive function: Conscious control of thoughts, emotions, and actions to accomplish goals or solve problems 执行功能：对思想、情感和行为的有意识控制，以实现目标或解决问题 Long-term Memory 长期记忆: Storehouse of virtually unlimited capacity that holds information for long periods 几乎无限容量的存储库，可以长时间保存信息 Memory Retrieval 记忆提取 Recall 提取: Ability to reproduce knowledge from memory 从记忆中再现知识的能力 Recognition 识别: Ability to identify something encountered before 识别以前遇到的事物的能力 Childhood Memories 儿童记忆 Generic Memory 通用记忆 (Age 2 岁): Produce “scripts”—general outlines of repeated and familiar events 产生“脚本”——重复和熟悉事件的大纲 Episodic Memory 情景记忆: Remembering a specific event at a specific time 记住特定时间的特定事件 Autobiographical Memory 自传记忆 (Age 3-4 岁): Memories that form a person’s life history 构成人生历史的记忆 Specific and long-lasting 具体且持久 Influence on Memory Retention 记忆保留的影响 Uniqueness of event 事件的独特性 Social interaction model (Vygotsky’s sociocultural approach) 社会互动模型（维果茨基的社会文化方法）: Children collaborate with parents and adults when constructing autobiographical memories 儿童在构建自传记忆时与父母和成人合作 Culture affects what children remember 文化影响儿童记忆的内容 Mothers in middle-class Western cultures tend to be more elaborative than mothers in non-Western cultures 中产阶级西方文化中的母亲往往比非西方文化中的母亲更详细 Intelligence 智力Psychometric and Vygotskian Approaches 心理测量和维果茨基的方法 Tests 测试: Include verbal items 包括语言项目 Results are more reliable than nonverbal tests for younger children 结果比年轻儿童的非语言测试更可靠 Examples: Stanford-Binet Intelligence Scale, Wechsler Preschool and Primary Scale of Intelligence (WPPSI-III) 例子：斯坦福-比奈智力量表，韦氏学前和初级智力量表 (WPPSI-III) Influences on Measured Intelligence 对测量智力的影响 IQ score IQ得分: Measures how well a child can do certain tasks at a certain time compared with other children of the same age 衡量儿童在特定时间与同龄儿童相比能做某些任务的能力 Correlation between socioeconomic status and IQ 社会经济地位与智商之间的相关性 Twin studies show that family life has its strongest influence in early childhood, which diminishes greatly by adolescence 双胞胎研究表明，家庭生活在早期儿童时期的影响最强，但在青春期大大减弱 Vygotsky’s Theory 维果茨基的理论 Zone of Proximal Development (ZPD) 最近发展区: Children use “scaffolds” to learn—the temporary support of adults 儿童使用“脚手架”学习——成人的临时支持 Assess potential with dynamic tests 动态测试评估潜力 Examiners help the child when necessary by asking questions, giving examples or demonstrations, and offering feedback, making the test itself a learning situation 检查员通过提问、提供示例或演示和提供反馈在必要时帮助孩子，使测试本身成为一个学习情境 Language Development 语言发展Vocabulary 词汇 Fast Mapping 快速映射: Child learns the meaning of a word after hearing it only once or twice 儿童在听到一个词一次或两次后学习其含义 By age 3, average child knows 900–1,000 words 3岁时，普通儿童知道900–1,000个词 By age 6, knows about 2,600 words and understands more than 20,000 6岁时，知道大约2,600个词并理解超过20,000个词 Grammar and Syntax 语法和句法 Developments 发展: Use plurals, possessives, and past tense 使用复数、所有格和过去时 Know the difference between I, you, and we 知道I、you和we的区别 Longer and more complicated sentences by age 5-7, using more conjunctions, prepositions, and articles 5-7岁时，句子更长更复杂，使用更多的连词、介词和冠词 Rarely use passive voice, conditional sentences, or auxiliary verb “have” 很少使用被动语态、条件句或助动词“have” Errors with irregular verbs, e.g., “holded” instead of “held” 不规则动词错误，例如，“holded”而不是“held” Pragmatics 语用学 How we use language to communicate 如何使用语言进行交流: Knowing how to ask for something, e.g., “May I please have a cookie?” vs. “Give me a cookie now.” 知道如何请求，例如，“我可以要块饼干吗？” 与 “现在给我块饼干。” Social Speech 社会言语 Speech intended to be understood by the listener 旨在让听者理解的言语: Trying to explain something clearly 尝试清楚地解释某事 Private Speech 私语 Talking aloud with no intended listener 无意听者的大声说话: Normal and common in childhood 童年时期正常且常见 Piaget: A sign of cognitive immaturity 皮亚杰：认知不成熟的标志 Vygotsky: Conversation with the self 维果茨基：与自己的对话 More research supports Vygotsky’s view 更多研究支持维果茨基的观点 Delay in Language Development 语言发展的延迟 About 3% of preschool-age children 约3%的学龄前儿童: May have problems in fast mapping 可能在快速映射上有问题 Many children catch up—especially if comprehension is normal 许多儿童赶上来——特别是如果理解正常 Dialogic reading helps 对话式阅读有帮助 Early Education 早期教育Preparation for Literacy 识字准备 General linguistic skills 一般语言技能: Vocabulary, syntax, etc. 词汇、句法等 Specific skills 具体技能: Phonological skills (awareness): Understanding that words are composed of sounds 音韵技能（意识）：理解单词由声音组成 Vocabulary and grammatical skills: Reading comprehension 词汇和语法技能：阅读理解 Social interaction: Reading to children 社交互动：给孩子读书 Types of Preschools 幼儿园类型 Child-centered (U.S.) 儿童中心（美国）: Stress social and emotional growth 强调社会和情感成长 Children choose activities and interact individually with the teacher 儿童选择活动并与老师单独互动 Academically focused (e.g., China) 以学术为中心（如中国） Montessori method 蒙台梭利方法 Educating children with disabilities 教育有障碍的儿童 Reggio Emilia Approach 瑞吉欧艾米利亚方法","link":"/psy2033-ch07-lecture-notes/"},{"title":"PSY2033 Ch08 Lecture Notes","text":"PSY2033 Developmental Psychology Ch08 Psychosocial Development in Early Childhood Psychosocial Development in Early Childhood (Ages 3-6) 早期儿童的心理社会发展 (3-6岁)中英双语笔记 Outline 大纲 The Developing Self 自我发展 Gender Development 性别发展 Play: The Business of Early Childhood 游戏：早期儿童的业务 Parenting 教养 Relationships with Other Children 与其他儿童的关系 The Developing Self 自我发展Self Concept 自我概念 Definition 定义: Total picture of our abilities and traits; a cognitive construction 我们能力和特征的总体图景；一种认知建构 Components 组成部分: Descriptive Representations 描述性表征: How we describe ourselves Evaluative Representations 评价性表征: How we evaluate ourselves Social Aspect 社会方面: Incorporate understanding of how others see them 融入对他人如何看待自己的理解 Changes in Self-definition 自我定义的变化 Age 4: Single Representations 单一表征 One-dimensional without logical connections 单一维度，没有逻辑连接 Cannot imagine two emotions at once 无法同时想象两种情感 Cannot differentiate real self from ideal self 无法区分真实自我与理想自我 Age 5-6: Representational Mappings 表征映射 Make logical connections between one aspect of self and another 在自我的一个方面和另一个方面之间建立逻辑联系 Statements are still completely positive, all-or-nothing 陈述仍然完全是积极的，非黑即白 Middle Childhood: Representational Systems 表征系统 Integrate specific features into a general, multidimensional concept 将特定特征整合为一般的、多维的概念 More balanced and realistic 更加平衡和现实 Self-esteem 自尊 Definition 定义: Evaluative part of self-concept; a child’s judgment of their overall worth 自我概念的评价部分；儿童对自身整体价值的判断 Developmental Changes 发展变化: Initially overestimated and unidimensional 最初被高估且单维度 Based on feedback from others 基于他人的反馈 The “Helpless” Pattern “无助”模式 High self-esteem motivates success 高自尊激励成功 When self-esteem is contingent on success, failure can lead to feeling helpless 当自尊依赖于成功时，失败会导致无助感 Belief in whether traits are fixed or changeable impacts response to failure 相信特质是固定的还是可变的会影响对失败的反应 Emotions 情感Understanding Emotions 理解情感 Preschool Children 学龄前儿童: Experiences elicit emotions based on desires 经验引发的情感基于欲望 Age 5-7: More complex emotional understanding 更复杂的情感理解 Simultaneous Emotions 同时情感: Young children struggle to recognize multiple emotions simultaneously 年幼的儿童难以同时识别多种情感 Emotions toward Self 自我情感 Develop around age 3 在3岁左右发展: Guilt, Shame, Pride 内疚、羞愧、自豪 Become more complex with age 随着年龄增长变得更复杂 Erikson: Initiative vs. Guilt 埃里克森：主动性与内疚 Conflict 冲突: Growing sense of purpose vs. desire for approval 不断增长的目标感与对认可的渴望之间的冲突 Virtue of Purpose 目标的美德: Courage to pursue goals without fear of punishment 在不惧惩罚的情况下追求目标的勇气 Gender Development 性别发展Gender Identity 性别认同 Awareness of being male or female 对性别的认知 Develops within societal context 在社会背景下发展 Influences behavior: Toy choices, play activities, playmates 影响行为：玩具选择、游戏活动、玩伴 Gender Differences 性别差异 Behavioral Differences 行为差异: Boys: Superior motor performance and more active physical activity 男孩：运动表现优越，体力活动更多 Girls: Better attention and inhibition of inappropriate behavior 女孩：注意力更好，抑制不当行为 Cognitive Differences 认知差异: Few measurable differences 可测量的差异很少 Theories of Gender Development 性别发展的理论 Biological Approach 生物学方法: Genetic, hormonal, and neurological evidence 基因、激素和神经证据 Evolutionary Approach 进化论方法: Gender roles are biologically based and have evolutionary purposes 性别角色是生物基础的，有进化目的 Psychoanalytic Approach 精神分析方法: Identification with same-sex parent 与同性父母的认同 Cognitive Approach 认知方法: Gender knowledge before gendered behavior 性别知识先于性别化行为 Social Learning Approach 社会学习方法: Observation and imitation of gender-typed behaviors 观察和模仿性别类型化行为 Kohlberg’s Cognitive-developmental Theory 科尔伯格的认知发展理论 Stages 阶段: Gender Identity 性别认同 Gender Stability 性别稳定 Gender Consistency 性别一致 Gender-Schema Theory 性别图式理论 Schema 图式: Mentally organized information influencing behavior 精神组织的信息影响行为 Promotes Gender Stereotypes 促进性别刻板印象 Socialization-Based Approach 社会化方法 Family, Peer, and Cultural Influences 家庭、同伴和文化的影响 Play 游戏Types of Play 游戏类型 Functional Play 功能性游戏: Simple, repetitive activities with objects or physical movements 简单的重复性活动或身体运动 Constructive Play 建构性游戏: Using objects to build or create something 使用物体建造或创造某物 Dramatic Play 戏剧性游戏: Involves imaginary situations and role-playing 包含想象情境和角色扮演 Social Dimension of Play 游戏的社会维度 Solitary Independent Play 独自独立游戏 Parallel Play 平行游戏 Associative Play 关联游戏 Cooperative Play 合作游戏 Gender Influences on Play 性别对游戏的影响 Gender Segregation 性别隔离: Boys: Active, physically aggressive, exploratory 男孩：积极、身体上攻击性强、探索性强 Girls: Structured, nurturing, pretend play 女孩：结构化、培育性、假装游戏 Parenting 教养Discipline 纪律 Methods 方法: Reinforcement 强化: External: Tangible (candy, money), Intangible (praise, attention) 外部：有形（糖果、金钱），无形（赞美、关注） Internal: Sense of accomplishment 内部：成就感 Punishment 惩罚: Isolation, denial of privileges, corporal punishment 隔离、剥夺特权、体罚 Parenting Styles 教养方式 Authoritarian 专制型: High demand, low responsiveness 高要求，低反应 Authoritative 权威型: High demand, high responsiveness 高要求，高反应 Permissive 溺爱型: Low demand, high responsiveness 低要求，高反应 Uninvolved 漠不关心型: Low demand, low responsiveness 低要求，低反应 Support and Criticisms of Baumrind’s Model 对鲍姆林德模型的支持与批评 Authoritative style has research support 权威型有研究支持 Cultural differences and parental concerns 文化差异和父母关注 Relationships with Other Children 与其他儿童的关系Aggression 攻击性 Types 类型: Instrumental Aggression 工具性攻击: Goal-oriented 目标导向 Overt Aggression 公开攻击: Physical force or threats, more common in boys 身体力量或威胁，男孩更常见 Relational Aggression 关系性攻击: Indirect, psychological manipulation, more common in girls 间接的，心理操纵，女孩更常见 Influences on Aggression 攻击性的影响 Temperament, Genetics, Environment 气质、基因、环境 Parental Behaviors 父母行为 Witnessing Violence 目睹暴力 Altruism 利他行为 Prosocial behavior often entails cost, self-sacrifice, or risk 社会性行为通常包含成本、自我牺牲或风险 Childhood Fears 儿童的恐惧 Common fears and their developmental impact 常见恐惧及其发展影响 The Only Child 独生子女 Research findings on only children 独生子女的研究发现: Tend to be more mature and motivated to achieve 往往更成熟和有成就动机","link":"/psy2033-ch08-lecture-notes/"},{"title":"PSY2033 Ch09 Lecture Notes","text":"PSY2033 Developmental Psychology Ch09 Physical and Cognitive Development in Middle Childhood (7-12) Describe physical changes and health in school-age children. 学龄儿童经历稳定的身体生长和发育。与婴幼儿期和幼儿期相比，他们通常体重和身高的增长速度较慢。他们的运动技能变得更加精细，使他们能够参与像体育运动和游戏等复杂的体育活动。此外，牙齿健康在这一时期变得越来越重要，永久牙齿的喷发和正确的口腔卫生习惯需求增加。 Describe cognitive development in school-age children. 学龄儿童的认知发展涉及到注意力、记忆、问题解决和语言等各个领域的显著进步。他们展示出改善的注意力和集中力，使他们能够参与更长时间的专注学习。他们理解抽象概念和逻辑思维的能力也变得更加复杂，有助于学业成就和批判性思维能力的发展。 Explain how language abilities continue developing in school-age children. 学龄儿童的语言能力通过词汇扩展、语法精炼和识字能力的习得继续发展。他们对语言结构和使用的理解变得更加深入，使他们能够在口头和书面上更有效地表达自己。阅读理解和写作能力在这一阶段显著提高，为学业成功和沟通技能奠定了基础。 Summarize children’s adjustment to school and influences on school achievement. 学龄儿童在开始正式教育时经历了一个重要的适应期。学校准备情况、与同龄人和老师的社交互动、父母参与以及教室环境等因素都会影响他们的学业表现和对学校的整体适应情况。积极的经历、支持性关系和富有刺激性的学习环境有助于成功适应学校并取得学业成就。 Describe how schools educate children with special needs. 学校采用各种教育方法和支持服务来满足有特殊需求的儿童的多样化需求。这些可能包括个别化的教育计划（IEP）、特殊教育课程、资源室、辅助技术和根据每个孩子的具体优势和挑战量身定制的适应措施。包容性教育实践旨在促进所有学生的全面参与和学业成功，无论他们的能力或残障如何。 Physical Development 身体发展Growth生长发育 Weight 体重: Doubles from age 6 to 11. 从6岁到11岁增加一倍。 Height 身高: Increases about 2–3 inches each year. 每年增加约2-3英寸。 Body Composition 身体组成: Girls retain more fatty tissue than boys. African American children tend to grow faster in muscles and body mass compared to white children. 女孩比男孩保留更多脂肪组织。与白人儿童相比，非裔美国儿童在肌肉和体重上增长更快。 Nutrition营养 Daily Caloric Intake 每日热量摄入: Approximately 2,400 calories. 约2400卡路里。 Diet 饮食: Should include whole grains, fruits, vegetables, and complex carbohydrates. Less than 10% of calories should come from saturated fats. 应包括全谷物、水果、蔬菜和复杂碳水化合物。饱和脂肪的摄入应少于总热量的10%。 Sleep睡眠 Age 5: 每晚大约11小时。 Age 9: 每晚大约10小时。 Age 13: 每晚大约9小时。 Alertness 警觉性: Children should be alert during the daytime. 儿童在白天应保持清醒。 Brain Development大脑发育 Information Processing 信息处理: Faster and more efficient. 更快、更高效。 提高了忽视干扰的能力。 例如，即使是无聊的课程，孩子们也更容易集中注意力学习 Genetic, Epigenetic, and Environmental Interactions 基因、表观遗传和环境相互作用: Influence brain development. 影响大脑发育。 Gray Matter 灰质: Dense with neurons in the cerebral cortex. Peaks at different ages in different brain regions (e.g., caudate at 7 for girls, 10 for boys; parietal and frontal lobes at 11 for girls, 12 for boys; temporal lobe at 16 for both). 大脑皮层中密集的神经元。在不同的年龄在不同的脑区达到高峰（例如，尾状核在女孩7岁、男孩10岁达到高峰；顶叶和额叶在女孩11岁、男孩12岁达到高峰；颞叶在16岁达到高峰）。 White Matter 白质: Composed of glial cells that support neuron function. Increase in white matter facilitates better information transmission. 由支持神经元功能的胶质细胞组成。白质的增加促进了更好的信息传输。 Pruning 修剪: Loss of gray matter density due to the pruning of unused dendrites. 由于未使用的树突的修剪导致灰质密度的减少。 Cortical Changes 皮层变化: Thickening in the temporal and frontal lobes; thinning in the rear portion of the frontal and parietal cortex in the left hemisphere. 颞叶和额叶的增厚；左半球额叶和顶叶皮层后部的变薄。 Recess-time Play课间玩耍 Nature of Play 游戏性质: Informal and spontaneous. 非正式和自发的。男孩参与更多的体力活动，而女孩则喜欢涉及语言表达的游戏。 Rough-and-Tumble Play 粗犷游戏: Involves vigorous activities like wrestling, kicking, chasing, and screaming. Accounts for 10% of free play and has adaptive benefits. 包括摔跤、踢、追逐和尖叫等剧烈活动。占自由游戏的10%，并具有适应性益处。 Sports and Activities体育和活动 Participation 参与: 大约40%的9至13岁儿童参加有组织的体育活动，而77%参加非组织的活动。 Motor Skill Improvement 运动技能提高: Sports programs should offer a variety of sports and focus on skill-building rather than winning. 体育项目应提供各种运动，并专注于技能培养而非赢得比赛。 Cognitive Development 认知发展Piagetian Approach: Concrete Operational Stage 皮亚杰方法：具体运算阶段 Age Range 年龄范围: 7-12岁。 Logic 逻辑: Active and appropriate use of logic but limited to real, concrete situations. 积极且恰当地使用逻辑，但仅限于实际、具体的情况。 Decentering 去中心化: Ability to consider multiple aspects of a situation. 能够考虑到情况的多个方面。 Cognitive Advances认知进步 Spatial Relationships and Causality 空间关系和因果关系 Spatial Thinking 空间思维: 使用地图或模型寻找隐藏的物体。 Cause and Effect 因果关系: Earlier: 天平两侧的物体数量影响表现 Later: 物体距离天平中心的距离也很重要 Categorization 分类 Seriation 序列化: 根据某个维度将物体按顺序排列（例如，从最轻到最重）。 Transitive Inference 传递推理: 根据第三个对象理解两个对象之间的关系。 Class Inclusion 类包含: 认识到一个子集（例如玫瑰）是一个更大类别的一部分（例如花）。 Reasoning 推理 Inductive Reasoning 归纳推理: 从具体实例中概括（例如，所有狗都会叫，因为我的狗和她的狗都会叫）。 Deductive Reasoning 演绎推理: 基于一般原则做出具体陈述（例如，所有狗都会叫，Spot是一只狗，因此Spot会叫）。 Wason’s Four-Card Problem Wason的四卡问题: 理解逻辑推理中的证伪原则。 Falsification principle 伪证原则：为了验证一个规则，你必须寻找那些可以推翻这个规则的情况。 大多数参与者都未能做到这一点 具体的日常术语：当问题以具体的、与日常生活相关的方式呈现时，参与者更容易正确地解决问题。比如，如果规则改为“如果一个人喝酒，他必须年满18岁”，人们更容易理解并找出违反规则的情况（例如，一个喝酒但未满18岁的人）。 Conservation 守恒: Understanding that quantity remains the same despite changes in shape or appearance. 理解数量在形状或外观改变的情况下保持不变。 Number and Mathematics 数字和数学 Counting On 继续计数: Starting from a number and counting up (e.g., starting at 5 to add 5 and 3). 从一个数字开始向上计数（例如，从5开始加5和3）。 Story Problems 故事问题: Solving simple mathematical problems. 解决简单的数学问题。 Fractions 分数: Intuitive understanding of fractions. 直观地理解分数。 Estimation 估算: Estimating quantities and measurements. 估算数量和测量值。 Piagetian Moral Reasoning degree of offense vs. intent过错程度 vs. 意图 皮亚杰的道德发展理论描述了儿童的道德理解随着年龄增长而经历的不同阶段。以下是主要阶段： Rigid obedience to authority 严格服从权威（2-7岁） Increasing flexibility 逐渐灵活（7-11岁）： Notion of equity 公平观念（大约11或12岁）： 在这个阶段，儿童对公平和正义有了更深的理解。他们认识到不同的情况和个体可能需要不同的处理方法。例如，他们理解一个2岁小孩不小心洒了墨水不应被要求承担与一个10岁小孩同样的道德责任，因为年幼的孩子理解和控制能力较低。 Information-Processing Approach 信息处理方法 Executive Function 执行功能: 在前额皮质发育的推动下，有意识地控制思想、情绪和行为。 Home environment Available resources 获取教育材料和资源的机会 Cognitive stimulation 认知刺激：促进思维和学习的活动。 Maternal sensitivity 母亲的敏感性：一种响应性和支持性的育儿风格，有助于儿童管理情绪和行为。 Executive functioning is involved in the capacity to make good decisions 做出良好决策 and monitor whether goals are being met 监控目标进展 Selective Attention 选择性注意: 有意地引导自己的注意力并排除干扰的能力 依赖于 executive skill 中的抑制控制，即自愿抑制不需要的反应。 Working Memory 工作记忆: 信息的短期存储和处理，对认知发展至关重要。 Metamemory 元记忆: 对自己记忆过程的意识和理解。 Mnemonics 记忆术: Strategies for improving memory, including external aids, rehearsal, organization, and elaboration. 改善记忆的策略，包括外部辅助、复述、组织和详述。 Information processing and Piagetian 信息处理的改进可能有助于解释皮亚杰描述的进步： 例如，9岁的孩子能够扫描场景，抓住其重要特征，并记住按顺序遇到的物体。 记忆的改进可能有助于掌握守恒任务： 例如，同时在工作记忆中保持物体的长度和宽度会有困难。 Psychometric Approach: Intelligence Assessment of Intelligence Otis-Lennon School Ability Test Wechsler Intelligence Scale for Children (WISC-IV) The IQ Controversy 支持 有大量关于有效性和可靠性的资料 中童时期的分数对学业成绩有较好的预测作用 批评 这些测试可能低估那些考试不好的孩子 测试不直接测量天生能力，只测试当前知识 Alternative Theories 替代理论: Gardner’s Theory of Multiple Intelligences, Sternberg’s Triarchic Theory of Intelligence. 加德纳的多元智能理论，斯腾伯格的三元智力理论。 Sternberg’s Triarchic Theory of Intelligence 斯滕伯格的三元智力理论 构成要素（Componential element）：这是分析性智力，涉及个体在处理和分析信息时的效率。比如，解决逻辑问题或数学计算时表现出的能力。 经验要素（Experiential element）：这部分是指有洞察力或创造性的智力。它涉及个体如何应对新情况，如何运用以前的经验进行创新和解决问题。 情境要素（Contextual element）：这部分是实际性智力，指个体如何在实际情境中进行评估和决策。它强调的是实际生活中的应用能力，比如在复杂的社会情境中做出有效的决策。 Language and Literacy 语言和读写能力Language Development语言发展 Verb Precision 动词精确性: 越来越多地使用精确动词。 Complex Syntax 复杂句法: 使用被动语态和条件句。 Pragmatics 语用学: 实际使用语言进行交流，包括对话和叙述技能。 Use of conversational skills 在引入一个话题之前先提问，以确保对方熟悉这个话题。 Use of narrative skills 开始在讲故事时描述动机和因果关系。 Second-Language Education 第二语言教育: Methods include English-immersion, bilingual education, and dual-language learning. 方法包括英语沉浸、双语教育和双语学习。 Reading阅读 Decoding 解码: Matching visual features and phonemes. 匹配视觉特征和音素。 Approaches 方法: Phonetic (code-emphasis) approach and whole-language approach. 语音（强调代码）方法和整体语言方法。 语音（重视编码）方法 拼出单词，将其转换为语音，然后从长期记忆中检索。 声音和字母的对应关系。 整体语言方法 基于视觉的检索。 看单词然后检索它。 Writing Skills写作技能 Development 发展: 随着阅读技能的发展而进步。早期作文简短且简单，注重拼写、标点、语法和大写。 Educating Children with Special Needs 特殊需要儿童教育 Special Education 特殊教育: Strategies and approaches tailored to individual needs, emphasizing inclusivity and support for children with various disabilities and learning challenges. 针对个体需求的特殊教育策略和方法，强调包容性和对各种残障和学习挑战儿童的支持。","link":"/psy2033-ch09-lecture-notes/"},{"title":"PSY2033 Ch03 Lecture Notes","text":"PSY2033 Developmental Psychology Ch03 Forming a New Life Learning Objectives 学习目标 Explain how conception occurs and what causes multiple births解释受孕如何发生以及导致多胞胎的原因 Describe the mechanism of heredity in normal and abnormal human development描述正常和异常人类发展中的遗传机制 Explain how heredity and environment interact in human development解释遗传和环境如何在人类发展中相互作用 Describe prenatal development, including environmental influences描述产前发育，包括环境影响 Discuss the importance of high-quality prenatal care讨论高质量产前护理的重要性 Conceiving a New Life 受孕新生命Fertilization (Conception) 受精（受孕） Process 过程 Sperm + Ovum -&gt; combine to create a single cell called a zygote 精子 + 卵子 -&gt; 结合形成一个称为受精卵的单细胞 Multiple Births 多胞胎 Dizygotic Twins 异卵双胞胎 两个卵子被两个不同的精子受精 More common, run in families 异卵双胞胎，分享50%的基因，与非双胞胎兄弟姐妹相似 Monozygotic Twins 同卵双胞胎 一个卵子被一个精子受精，分裂成两个 Identical twins, usually occur by chance 同卵双胞胎，分享100%的基因 Mechanism of Heredity 遗传机制Genetic Code 遗传密码 Chromosomes 染色体 由DNA构成的包含基因的结构。 Genes 基因 Units of heredity that maintain their structural identity from one generation to another. 维持其结构特性从一代传到另一代的遗传单位。 Determination of Sex 性别决定 染色体决定个体的性别：女性为XX，男性为XY。 Patterns of Genetic Transmission 遗传传递模式 Genotype 基因型 The underlying genetic makeup of an organism, including both expressed and unexpressed genes. 有机体的潜在遗传构成，包括表达和未表达的基因。 Phenotype 表型 The observable characteristics or traits of an organism, influenced by both genotype and environment. 有机体的可观察特征或性状，由基因型和环境共同影响。 Multifactorial Transmission 多因素传递 Most traits are influenced by multiple genes and environmental factors. 大多数性状受多个基因和环境因素的影响。 For example, height is influenced by genes, nutrition, and overall health. 例如，身高受基因、营养和整体健康的影响。 Gene Expression 基因表达 Epigenesis 表观遗传 Definition 定义 Genes are turned off or on as they are needed by the developing body or when triggered by the environment. 基因在发育过程中根据需要或在环境触发下被关闭或开启。 Mechanism 机制 Chemical molecules (or “tags”) attach to a gene and alter the way a cell reads the gene’s DNA. 化学分子（或“标签”）附着在基因上，改变细胞读取基因DNA的方式。 Environmental Factors 环境因素 Factors such as nutrition, smoking, sleep habits, stress, physical activity, social isolation, etc. 如营养、吸烟、睡眠习惯、压力、体力活动、社会隔离等因素。 Critical Periods 关键期 细胞在青春期和怀孕等关键期特别容易受到表观遗传修改的影响。 Genetic Imprinting 基因印记 某些基因的表达取决于它们是从母亲还是父亲继承的。 Heredity and Environment 遗传与环境Behavioral Genetics 行为遗传学 Definition 定义 定量测量遗传和环境对特定性状的影响程度。 Heritability 遗传力 Statistical estimate of the contribution of heredity to individual differences in a specific trait in a given population. 估算遗传对特定群体中个体差异的贡献。 Measuring Heritability 测量遗传力 Concordance 一致性: The degree to which monozygotic (MZ) and dizygotic (DZ) twins resemble each other for a trait. Family Studies 家族研究: Examine the degree to which biological relatives share traits. Adoption Studies 领养研究: Compare adopted children to their biological and adoptive families. Twin Studies 双胞胎研究: Compare monozygotic and dizygotic twins to assess genetic influence. Interplay Between Heredity and Environment 遗传与环境的相互作用Reaction Range 反应范围 Definition 定义 The range of potential expression of a hereditary trait. 遗传性状潜在表达的范围。 Example 例子 Body size can be influenced by both genetic potential and environmental factors such as nutrition. 身体大小可以受到遗传潜力和环境因素（如营养）的影响。 Canalization 通道化 Definition 定义 Heritable restrictions on the range of trait development. 性状发展的遗传限制。 Example 例子 Traits such as eye color and sequence of motor development are strongly programmed by genes. 眼睛颜色和运动发展的顺序等性状由基因强烈编程。 Genotype-Environment Interaction 基因型-环境相互作用 Definition 定义 Effects of similar environmental conditions on genetically different individuals. 相同环境条件对遗传不同个体的影响。 Example 例子 Children exposed to pollen and dust may develop allergic reactions based on their genetic predisposition. 暴露于花粉和灰尘的儿童可能会根据他们的遗传易感性发展出过敏反应。 Genotype-Environment Correlation 基因型-环境相关 Definition 定义 Environment reflects or reinforces genetic differences. 环境反映或强化遗传差异。 Types 类型 Passive 被动: Parents provide genes and environment that encourage the development of certain traits. Reactive or Evocative 反应或唤起: Children’s genetic makeup evokes certain reactions from others. Active or Niche Picking 主动或利基选择: Individuals actively select environments compatible with their genetic tendencies. Expanded Notes 扩展笔记: Non-shared Environment 非共享环境 Unique environment in which each child grows up, including accidents, illnesses, and unique interactions with peers. 每个孩子成长的独特环境，包括事故、疾病和与同伴的独特互动。 Prenatal Development 产前发育Gestation 妊娠期 Definition 定义 The period between conception and birth, normally between 37 and 41 weeks. 受孕 和出生之间的时期，通常在37到41周之间。 Gestational Age 妊娠年龄 Usually dated from the first day of an expectant mother’s last menstrual cycle. 通常从预期母亲上一次月经周期的第一天算起。 Stages of Prenatal Development 产前发育阶段Germinal Stage 胚种期 Duration 持续时间 Fertilization to 2 weeks 受精到2周 Key Processes 关键过程 Zygote divides, becomes more complex, and is implanted in the wall of the uterus. 受精卵分裂，变得更加复杂，并植入子宫壁。 Implantation 植入: The attachment of the blastocyst to the uterine wall, occurring at about day 6. 植入: 囊胚附着在子宫壁，大约在第6天发生。 Expanded Notes 扩展笔记: Embryonic Disk 胚盘 Ectoderm 外胚层: Becomes the outer layer of skin, nails, hair, teeth, sensory organs, and the nervous system. 成为皮肤外层、指甲、头发、牙齿、感觉器官和神经系统。 Mesoderm 中胚层: Develops into the inner layer of skin, muscles, skeleton, and excretory and circulatory systems. 发育成皮肤内层、肌肉、骨骼、排泄和循环系统。 Endoderm 内胚层: Becomes the digestive system, liver, pancreas, salivary glands, and respiratory system. 成为消化系统、肝脏、胰腺、唾液腺和呼吸系统。 Embryonic Stage 胚胎期 Duration 持续时间 2 to 8 weeks Key Processes 关键过程 Organogenesis: Organs and major body systems develop rapidly. 器官发生：器官和主要身体系统迅速发展。 Critical Period 关键期: Most vulnerable to environmental influences, risk of spontaneous abortion or miscarriage. 最易受环境影响，流产或自然流产的风险。 Fetal Stage 胎儿期 Duration 持续时间 8 weeks to birth 8周到出生 Key Processes 关键过程 Appearance of the first bone, rapid growth, and complexity of organs and body. 第一个骨骼的出现，快速增长，以及器官和身体的复杂性。 “Finishing touches”: fingernails, toenails, eyelids. “最后的润色”：指甲、脚趾甲、眼睑。 Expanded Notes 扩展笔记: Maternal Factors 母体因素 Teratogens 致畸物: Environmental agents that can interfere with normal development. Nutrition and Maternal Weight 营养和母体体重: Adequate nutrition is crucial for healthy fetal development. Drug and Alcohol Intake 药物和酒精摄入: Can lead to conditions such as Fetal Alcohol Syndrome (FAS). Maternal Illnesses 母体疾病: Including sexually transmitted diseases like HIV/AIDS. Maternal Age and Stress 母体年龄和压力: Older age and high stress levels can increase the risk of complications.","link":"/psy2033-ch03-lecture-notes/"},{"title":"PSY2033 Ch06 Lecture Notes","text":"PSY2033 Developmental Psychology Ch06 Psychosocial Development during the First Three Years Learning Outcomes 学习目标 Discuss the development of emotions and personality in infancy讨论婴儿期情感和个性的发育 Describe infants’ social relationships with caregivers, including attachment描述婴儿与护理者的社会关系，包括依恋 Discuss the emerging sense of self, autonomy, and moral development in toddlerhood讨论幼儿期自我意识、自主性和道德发展的萌芽 Explain how social contexts influence early development解释社会环境如何影响早期发展 Explain child maltreatment and its effects解释虐待儿童及其影响 Personality 个性 Relatively consistent blend of emotions, temperament, thought, and behavior情感、气质、思想和行为的相对一致混合 Psychosocial development involves the interplay between personality and social relationships心理社会发展涉及个性与社会关系的相互作用 Emotions 情感 Shape response to the world影响对世界的反应 Temperament is an early building block of personality气质是个性早期的构建模块 Earliest social experiences influence emotional development最早的社会经验影响情感发展 Crying 哭泣 First Signs of Emotion情感的第一个迹象 Hunger, pain, frustration 饥饿、疼痛、挫折 Newborns show piercing cries, flailing limbs, stiff body when upset 新生儿不开心时会尖叫，四肢挥动，身体僵硬 Maternal Sensitivity to Crying母亲对哭泣的敏感性 Sensitive response to crying is associated with later social competence and positive adjustment 对哭泣的敏感反应与后来的社会能力和积极调整相关 Smiling and Laughing 微笑和笑 Involuntary Smiles非自愿微笑 Spontaneous soon after birth due to subcortical brain activity 出生后不久由于皮下脑活动而自发出现 Frequently during REM sleep 经常在快速眼动睡眠期间 Social Smiling社会微笑 By 2 months, infants gaze at parents and smile 2个月时，婴儿注视父母并微笑 By 4-12 months, laughter (smile-linked vocalization) develops 4-12个月时，笑声（与微笑相关的发声）发展 Anticipatory Smiling预期微笑 Rises sharply between 8-10 months, infants smile at an object and then gaze at an adult while continuing to smile 8-10个月之间急剧增加，婴儿微笑着看着一个物体，然后继续微笑着看着一个成年人 Self-conscious Emotions 自我意识情感 Emerge after self-awareness develops (15-24 months)在自我意识发展后出现（15-24个月） Embarrassment, empathy, envy 尴尬、同理心、嫉妒 Self-evaluative Emotions 自我评价情感 Develop around age 3约在3岁时发展 Pride, guilt, shame 骄傲、内疚、羞愧 Emotion Development 情感发展 Orderly development from simple to complex有序地从简单到复杂的发展 Brain Growth and Emotion脑发育与情感 0-3 months: Cerebral cortex becomes functional 0-3个月：大脑皮层开始功能化 9-10 months: Frontal lobes interact with limbic system 9-10个月：额叶与边缘系统相互作用 2nd year: Self-awareness and consciousness develop 第2年：自我意识和意识发展 Age 3: Hormonal changes in ANS coincide with evaluative emotions 3岁：自主神经系统的激素变化与评估性情感一致 Temperament 气质 Biologically based tendency to respond to the environment in predictable ways以生物学为基础的以可预测的方式对环境作出反应的倾向 Temperament Patterns 气质模式 40% “Easy” children 容易养育的儿童 10% “Difficult” children 难养育的儿童 15% “Slow-to-warm-up” children 缓慢适应的儿童 35% do not fit neatly into any of these categories 35%的儿童不完全符合这些类别 Goodness of Fit 合适度 Match between child’s temperament and environmental demands儿童气质与环境需求之间的匹配 Early Social Experiences 早期社会经验Gender Differences 性别差异 Measurable differences are few可测量的差异很少 Behavioral differences between 1 and 2 years1至2岁之间的行为差异 Boys play more aggressively 男孩玩得更有攻击性 Word choices reflect gender perceptions 词汇选择反映性别认知 Parental Influence on Gender Differences 父母对性别差异的影响 Gender-typing 性别定型 Process by which children learn behavior appropriate for their sex 儿童学习适合其性别的行为的过程 Psychosocial Development in Infancy 婴儿期的心理社会发展Erikson Stage 1: Trust vs. Mistrust 艾里克森阶段1：信任与不信任 Develop a sense of reliability of people and objects发展对人和物的信任感 Sensitive, responsive, and consistent care敏感、反应迅速和一致的护理 Attachment 依恋 Studying attachment: Strange Situation研究依恋：陌生情境实验 Types of Attachment 依恋类型 Secure attachment 安全型依恋 Avoidant attachment 回避型依恋 Ambivalent (resistant) attachment 矛盾（抵抗）型依恋 Disorganized-disoriented attachment 迷恋失序型依恋 Long-term Effects of Attachment 依恋的长期影响 More securely attached children develop better social relationships更安全依恋的儿童发展出更好的社会关系 Higher levels of curiosity and self-confidence更高水平的好奇心和自信 Psychosocial Development in Toddlerhood 幼儿期的心理社会发展Emerging Sense of Self 自我意识的萌芽 Self-concept: The image of ourselves自我概念：我们的自我形象 Develops from 3 months to 24 months发展从3个月到24个月 Development of Autonomy 自主性的发展 Erikson Stage 2: Autonomy vs. Shame 艾里克森阶段2：自主性与羞耻 Shift from external control to self-control 从外部控制转向自我控制 Virtue of Will 意志的美德: Begin to substitute their own judgment for their caregivers’ 开始用自己的判断代替护理者的判断 Moral Development 道德发展 Socialization 社会化 Developing habits and values that make children productive members of society 发展使儿童成为社会生产成员的习惯和价值观 Internalization 内化 Making societal standards their own 将社会标准内化为自己的标准 Self-regulation 自我调节 Control over own behavior to conform to caregiver’s standards控制自己的行为以符合护理者的标准 Child Maltreatment 虐待儿童Types of Maltreatment 虐待类型 Physical abuse 身体虐待 Neglect 忽视 Sexual abuse 性虐待 Emotional maltreatment 情感虐待 Long-term Effects of Maltreatment 虐待的长期影响 Victimization of own children in adulthood成年后虐待自己的孩子 Greater risk of depression and anxiety更高的抑郁和焦虑风险","link":"/psy2033-ch06-lecture-notes/"},{"title":"PSY2033 Ch11 Lecture Notes","text":"PSY2033 Developmental Psychology Ch11 Physical and Cognitive Development in Adolescence Outline 概述 Physical Development 身体发育 Puberty 青春期 Adolescent Brain 青春期大脑 Physical and Mental Health 身体和心理健康 Cognitive Development 认知发展 Cognitive Maturation 认知成熟 Education and Vocational Issues 教育和职业问题 Puberty and Adolescence 青春期与青少年期Puberty 青春期 Definition: The process that leads to sexual maturity or fertility. 导致性成熟或生育能力的过程。 Adolescence 青少年期 Developmental Transition 发展过渡期: Involves physical, cognitive, emotional, and social changes. 包括身体、认知、情感和社会的变化。 Social Construction 社会构建: 由文化“创造”。今天，青少年期是一个全球现象，是童年与成年之间的延长过渡期。 Physical Development 身体发育Puberty 青春期Puberty is the process that leads to sexual maturity or fertility. Key Processes 关键过程 Adrenarche 肾上腺发育: 发生在6到9岁之间，涉及肾上腺的成熟和雄激素的产生。 Gonadarche 性腺发育: 性器官的成熟，以第二次DHEA爆发为标志。 女孩: 卵巢增加雌激素。 男孩: 睾丸增加雄激素。 General Changes 一般变化 男性和女性都产生两种类型的激素。 男孩产生更多的睾酮；女孩产生更多的雌激素。 Physical changes 身体变化: Growth spurt, pubic hair, deeper voice, muscular growth. 生长激增，阴毛，声音变深，肌肉增长。 Puberty Onset 青春期的开始Factors 影响因素 体脂: 童年早期较高的体脂百分比导致 Puberty 提前。 女孩: Puberty 通常在8到10岁之间开始。 男孩: Puberty 通常在9到11岁之间开始。 Growth Spurt 生长激增 身高和体重的快速增加，通常持续约两年。 性别差异: 女孩的生长激增比男孩早约两年。 心理影响: 青少年变得更加关注自己的外貌，可能导致饮食失调。 Signs of Sexual Maturity 性成熟的标志Spermarche 初次遗精 定义: 第一次射精，通常发生在平均13岁。 Menarche 初潮 定义: 第一次月经，通常发生在平均12岁半。 Timing Effects of Puberty 青春期的时间效应Secular Trend 世俗趋势 青春期的开始变早 和 成年身高体重增加 Possible Explanations 可能的解释 更高的生活水平/更好的营养: 改善的生活条件和营养可能导致青春期提前。 肥胖问题: 肥胖也会导致青春期提前。 母亲吸烟: 可能导致初潮提前。 父亲关系: 与父亲的关系越亲密，初潮越晚。 Adolescent Brain 青少年大脑Growth Spurt 成长激增 位置: 主要在额叶，影响推理、判断和冲动控制。 White Matter 白质 增加: 稳定的增加使神经冲动传输更快，神经元同步放电率。 Gray Matter 灰质 生长和下降: 在青春期开始激增，随后显著下降。 Risk Taking 冒险行为 Result: From interaction of two brain networks: 社会情感网络（同伴影响）: 在青春期更活跃。 认知控制网络（对刺激的反应）: 逐渐成熟到成年早期。 Physical and Mental HealthSleep 睡眠 基本特征 Decline in Sleep 时间减少 平均睡眠: 在16岁时减少到不到八小时。 睡眠需求: 青少年需要比小时候更多的睡眠，但许多人没有得到足够的睡眠。 College Students 大学生 睡眠不足: 长期睡眠不足，平均睡眠时间显著减少（6-7小时），每晚有2小时的睡眠债。 白天嗜睡: 大多数人经常经历过度的白天嗜睡（50-70%）。 Effects of Sleep Deprivation 睡眠不足的影响 Impaired Alertness 警觉性受损 条件: 一晚睡3小时或两晚睡5小时后警觉性受损。 认知损伤: 即使主观上觉得不困，认知和表现的损伤仍然存在。 Impaired Performance 表现受损 短期记忆: 受损。 反应时间和判断: 减少。 错误: 错误数量增加。 信息处理: 受损。 Health Problems 健康问题 情绪障碍: 抑郁、易怒和焦虑。 体重增加: 增加。 胰岛素抵抗: 导致糖尿病。 免疫力减弱: 减少。 心血管问题: 高血压、中风、心脏病发作。 Body Image 身体形象 Perception 自我感知 关注: 自己认为自己的样子；在青春期最为强烈。 性别模式: 由于女孩身体脂肪的正常增加，在女孩中更为强烈。 Eating Disorders 饮食失调 Anorexia Nervosa 厌食症 自我饥饿: 0.3 – 0.5%的青少女和年轻女性。 扭曲的身体形象: 通常体重不足，但认为自己很胖。 月经不规律: 月经不规律或停止。 性格特征: 通常是好学生和完美主义者。 Bulimia Nervosa 贪食症 症状: 暴饮暴食后排泄。 健康风险: 电解质失衡、胃肠问题、牙齿问题。 Treatment 治疗 即时目标: 让患者进食并增加体重。 住院: 如果严重营养不良可能需要住院。 Therapies: 行为治疗: 奖励进食。 认知治疗: 改变身体形象。 机构和家庭治疗: 结合方法。 Drug Use and Abuse 药物使用和滥用 Substance Use 物质使用 定义: 酒精或其他药物的有害使用。 Dependence or Addiction 依赖或成瘾 类型: 可以是心理上的或生理上的。 青少年的风险: 由于大脑结构的变化尤其危险。 Common Drugs 常见药物 Alcohol, Marijuana, Tobacco 酒精、大麻、烟草: Commonly used by adolescents. Trends 趋势 Illicit Drug Use 非法药物使用: 近一半的美国青少年在高中毕业时已经尝试过 Nonprescription Medication Abuse 非处方药物滥用: 最近的趋势包括滥用止咳药和感冒药。 Binge Drinking 酗酒: 一次饮五杯或更多。 Risk Factors 风险因素 Difficult Temperament: Poor impulse control and sensation seeking. 困难的性格: 冲动控制差和寻求刺激。 Family Influence: Genetic predisposition or inconsistent parenting. 家庭影响: 遗传倾向或不一致的教养。 Behavior Patterns: Early and persistent problematic behavior. 行为模式: 早期和持续的问题行为。 Peer Influence: Rejection, alienation, or rebelliousness. 同伴影响: 被排斥、疏离或叛逆。 Attitudes and Early Initiation: Favorable attitudes toward drug use. 态度和早期使用: 对药物使用持有利态度。 Depression 抑郁症Prevalence 流行率 增加: 青少年期间，发生在12-17岁的9%的儿童中。 治疗: 只有40%接受治疗。 Gender Differences 性别差异 易感性: 女孩比男孩更易感。 青春期: 青春期进展增加抑郁症状。 社会关系: 女孩在社会关系中的压力更大。 Cognitive Development 认知发展Piaget: Formal Operational Stage 皮亚杰：形式运算阶段 Abstract Thought: Capacity for abstract thought, more flexible way to manipulate information. 抽象思维: 抽象思维的能力，更灵活的信息处理方式。 Symbolism: Ability to use symbols to represent other symbols, appreciate hidden messages. 象征: 使用符号代表其他符号的能力，欣赏隐藏的信息。 Hypothetical-Deductive Reasoning 假设演绎推理 Definition: Developing hypotheses and systematically testing them. 定义: 发展假设并系统地测试它们。 Evaluating Piaget’s Theory 评价皮亚杰的理论Criticisms 批评 Timing: Underestimation and overestimation of abilities. Role of Context: Fails to capture the role or context of situations. Metacognition: Does not fully consider the role of metacognition. 时间: 对能力的低估和高估。 情境作用: 未能捕捉到情境的作用。 元认知: 没有完全考虑元认知的作用。 Changes in Information Processing 信息处理的变化Structural Changes 结构变化 Working Memory Capacity 工作记忆容量: 增加。 Long-term Memory长期记忆: 存储更多的知识。 Declarative 陈述性: 事实和信息。 Procedural 程序性: 如何做事。 Conceptual概念性: 理解概念。 Functional Changes 功能变化 Information Handling: Increased ability to obtain, handle, and retain information. Reasoning: Mathematical and scientific reasoning. Proficiency: Improved proficiency in drawing conclusions. 信息处理: 获取、处理和保留信息的能力增加。 推理: 数学和科学推理。 熟练度: 改进得出结论的熟练度。 Language Development 语言发展Adolescents’ Abilities 青少年的能力 Discuss Abstractions: Such as love, freedom, and justice. 讨论抽象概念: 如爱、自由和正义。 Linguistic Features: Pragmatics and semantics. 语言特征: 语用学和语义学。 Pubilect 青春期方言 Definition: Social dialect of puberty, includes teenage slang. 定义: 青春期的社会方言，包括青少年的俚语。 Moral Development 道德发展Components 组成部分 Affective Component 情感成分: 感情如内疚、同情心和良心 Probably least understood: 可能是最不被理解的 Freudian theory or guilt: 弗洛伊德理论或内疚感 Temperament of child: 孩子的性情 Parenting styles: 教养方式 E.g., warmth-love, disciplinary approach: 例如，温暖-爱，纪律方式 Behavioral Component 行为成分: 当我们被诱惑违反规则时的行为。 Can be quite independent of both affect and understanding (e.g., Clinton): 可以完全独立于情感和理解（例如，克林顿） Again, is highly related to both personality and parenting: 同样，与个性和教养密切相关 Again, the not well understood: 再次，不太理解 E.g., knowledge vs behavior– teen pregnancy: 例如，知识与行为的对比——青少年怀孕 Cognitive Component 认知成分: 我们如何思考对错。 While moral behavior depends on socialization, it is also a process of cognitive development: 虽然道德行为依赖于社会化，但它也是一个认知发展的过程 One very influential theory was developed by Lawrence Kohlberg: 劳伦斯·科尔伯格发展了一个非常有影响力的理论 Kohlberg presented “moral dilemmas” to children and studied how their answers changed with development: 科尔伯格向孩子们提出“道德困境”，并研究了他们的答案随着发展而如何变化 Kohlberg’s Theory of Moral Judgment 柯尔伯格的道德判断理论Stages 阶段 Preconventional Level 前习俗水平 Stage 1: Obedience and punishment. Stage 2: Self-interest. Conventional Level 习俗水平 Stage 3: Good interpersonal relationships. Stage 4: Maintaining social order. Post-Conventional Level 后习俗水平 Stage 5: Social contract and individual rights. Stage 6: Universal principles. 前习俗水平 阶段1: 服从和惩罚。 阶段2: 自我利益。 习俗水平 阶段3: 良好的人际关系。 阶段4: 维护社会秩序。 后习俗水平 阶段5: 社会契约和个人权利。 阶段6: 普遍原则。 Evaluating Kohlberg’s Theory 评价柯尔伯格的理论 支持: 道德判断与年龄、教育、智商和社会经济地位等因素的相关性。 批评: 包括低估儿童的灵活性，忽视情感成分，以及忽视道德推理与行为之间的区别。 认知发展 ≠ 同等水平的道德发展 父母的影响（权威型） Gilligan’s Theory 吉利根的理论 性别偏见: 柯尔伯格的理论可能偏向男性的推理风格。 女性视角: 强调关怀和避免伤害。 Prosocial Behavior 亲社会行为Prosocial – care-oriented moral reasoning Alternative to Kohlberg’s justice system Development 发展 增加: 从童年到青少年期。 性别差异: 女孩往往表现出更多的亲社会行为。 Moral Dilemmas 道德困境 情景: 一个人的需求或愿望与另一个人发生冲突。 School Achievement 学校成绩Factors 影响因素 Motivation: Typically declines in high school. Self-efficacy: Belief in one’s ability to master tasks. Twice as important as IQ in accounting for final grades. 动机: 通常在高中下降。 自我效能感: 相信自己能掌握任务的能力。 在解释最终成绩时，比智商重要两倍。 Gender Differences 性别差异 女孩: 阅读、写作和语言使用方面更好。 男孩: 数学素养、视觉和空间功能方面领先。 Adolescents in the Workplace 青少年在工作场所Employment 就业 Prevalence: Vast majority employed at some time during high school. 普遍性: 大多数人在高中期间都有就业经历。 Paths 两种路径 Accelerated Path: Toward adulthood. Leisurely Transition: Balancing work and school. 加速路径: 走向成年。 休闲过渡: 平衡工作和学习。 Positive Effects: More positive effects if working hours are limited and students remain engaged in school activities. 积极效果: 如果工作时间有限，且学生仍然参与学校活动，则效果更积极。","link":"/psy2033-ch11-lecture-notes/"},{"title":"PSY2033 Ch12 Lecture Notes","text":"PSY2033 Developmental Psychology Ch12 Phychosocial Development in Adolescence Identity Formation 身份形成Identity vs Identity Confusion 身份与身份混淆 Identity: A coherent conception of self, vital for becoming an adult with a unique sense of self and role in society. 对自我的连贯概念，对于成为具有独特自我和社会角色的成年人至关重要。 Key Aspects: 职业选择 生活价值观的采纳 性别认同的发展 Successful Resolution 成功解决: Leads to “fidelity” — Sustained loyalty, faith, or a sense of belonging to a loved one, friends, or companions 导致“忠诚”——对亲人、朋友或同伴的持续忠诚和归属感。 成功解决： Danger: Identity confusion, which is a normal part of development but can become problematic if not resolved. 危险：身份混淆，这是一种正常的发育过程，但如果没有解决可能会成为问题。 Male and Female Orientation Male Orientation: Men are seen as incapable of real intimacy until they have achieved a stable identity. 男性在实现稳定的身份之前被认为无法真正亲密。 Female Orientation: Women develop their identity through intimacy rather than before it. 女性通过亲密关系来发展身份，而不是在亲密关系之前。 Marcia’s Identity Statuses马西娅的身份状态James Marcia 根据危机和承诺的存在或不存在，确定了四种身份状态： Identity Achievement 身份成就: 奥利维亚在考虑了自己的兴趣和才能后，计划成为一名工程师。 Foreclosure 过早承诺: 伊莎贝拉计划进入母亲安排的学徒计划，而没有探索其他选择。 Moratorium 延迟状态: 乔希正在为是否上社区大学还是参军而苦恼。 Identity Diffusion 身份扩散: 杰登还不知道他想做什么，也不关心。 Gender Differences in Identity Formation身份形成中的性别差异 Carol Gilligan: 提出女性通过 关系 而不是通过 独立身份 来发展自我意识。 Erik Erikson: 女性的身份和亲密关系同时发展。 Self-esteem Males: individual success Females: connections to others Adolescent Sexuality 青春期的性行为Sexual Identity 性别认同 Key Components: 认识到自己的性取向 Forming sexual, romantic, and affectionate interests Sexual Orientation 性取向 Types: Homosexual (same sex) Heterosexual (opposite sex) Bisexual (both sexes) Factors: Partly genetic, moderately heritable 部分是遗传的 – 中等程度可遗传 哥哥越多，年轻弟弟同性恋的几率增加33% Brain Differences: 喜欢男生的人大脑左右半球对称，喜欢女生的人右半球稍微大一点 在同性恋者中，涉及情感的amygdala 杏仁核连接方式, are typical of the other sex。 Size of the hypothalamus 下丘脑的大小 男性汗液的气味激活了同性恋男性的下丘脑，就像它在异性恋女性中一样。 同性恋女性和异性恋男性对女性pheromones 信息素的反应更加积极。 Sexual Activity 性行为 第一次性交的平均年龄： 女性：17岁 男性：16岁 Concerns: 性传播感染（STIs） 青少年怀孕 Factors Associated with Early Sex 与早期性行为相关的因素 Early puberty Poverty Poor school performance History of sexual abuse or neglect Cultural or family patterns Perception of peer norms 对同龄人规范的看法 Protective Factors 保护因素 参与和投入的亲子关系 双亲家庭的存在 与母亲的亲密关系 宗教信仰或道德 Contraceptive Use 避孕使用 处于稳定关系中的青少年更可能持续使用避孕措施，特别是如果他们在发生性行为之前讨论避孕并使用多种方法。 Sources of Information about Sex 关于性的消息来源 Friends Parents Sex education at school Media (often problematic) Sexually Transmitted Infections (STIs)性传播感染（STIs） Prevalence: High among teenagers 由于早期性行为、避孕套使用不当和有年长的伴侣，青少年中的流行率很高。 常见STIs： 衣原体和淋病（可治愈但如果不治疗会导致盆腔炎） 人乳头瘤病毒（HPV）导致宫颈癌 Trichomoniasis 滴虫病和 Genital herpes simplex 生殖器单纯疱疹 HIV: High prevalence among young people aged 15-24; early detection is crucial. 艾滋病毒：15-24岁年轻人中的流行率高；早期检测至关重要。 Social RelationshipsRelationship with Family Adolescent Rebellion 青少年叛逆: A stereotype 一种刻板印象，只适用于五分之一的青少年。 Changing Relationships: Adolescents spend less time with family and more time alone or with peers, reflecting developmental needs. 关系变化：青少年花更少的时间与家人在一起，更多的时间独处或与同龄人在一起，反映了发展需求。 Family Conflict: 日常事务上的常见冲突，如家务、学业、着装、金钱、宵禁、约会和朋友。 Individuation — adolescent’s struggle for autonomy and personal identity More decision-making opportunities lead to higher self-esteem and better emotional regulation. 更多的决策机会会导致更高的自尊和更好的情绪调节。 Parenting Styles教养方式 Authoritative Parenting: 促进健康的心理社会发展。 Authoritarian Parenting: 可能导致青少年拒绝父母的影响，并不惜一切代价寻求同龄人的支持。 Friendships友谊 Characteristics: 青少年时期的友谊强度和与朋友在一起的时间可能比其他任何时候都更多。 更大的亲密度（女孩&gt;男孩） 忠诚 与朋友分享秘密 More reciprocal and stable than in childhood 增加的亲密度 Adolescent Crowds and Cliques: Clique ‐ 小圈子，一个有结构的朋友群体 服务于帮助建立身份、加强联盟和促进同一组内友谊等目的。 Antisocial Behavior Early Onset早发型：在11岁之前开始，可能导致慢性的青少年犯罪。 Late Onset 晚发型: 青春期后出现，通常是暂时的，并且是对青春期变化的反应。 Factors: 遗传基础、神经生物学缺陷和家庭环境 Becoming a Delinquent 成为不良少年 An interaction between influences: Parental Peers Community Collective efficacy 集体效能 - 邻居如何支持彼此？ Preventing Delinquency 预防不良少年行为: 提供家庭援助、支持网络以及家庭与学校之间的干预的项目可以帮助减少犯罪。","link":"/psy2033-ch12-lecture-notes/"},{"title":"PSY2033 Ch10 Lecture Notes","text":"PSY2033 Developmental Psychology Ch10 Phychosocial Development in Middle Childhood Outline of the Lecture 课程大纲: Emotional and Personality Development 情绪与人格发展 Changes in Family Relationships 家庭关系的变化 Changes in Peer Relationships 同伴关系的变化 Mental Health: Emotional Disorders, Treatment Techniques, and Children’s Ability to Cope with Stress 心理健康：情绪障碍、治疗技术与儿童应对压力的能力 Self-Concept 自我概念 Definition 定义: Self-concept refers to how children perceive and evaluate themselves. It encompasses self-awareness, self-esteem, and self-identity. 自我概念指的是儿童如何看待和评价自己。它包含自我意识、自尊和自我认同。 Age 8-11: 8-11岁: Children begin to express mixed feelings. 儿童开始表达复杂的情感。例如，他们可能会说：“我很高兴下雨了，但又生气，因为不能出去玩。” 相比之下，年幼的孩子以具体的术语思考，例如：“我住在大房子里，有一条宠物鱼。” 在早期儿童时期，自我概念往往是非此即彼的，例如“我从不害怕。” Forming Representational Systems 形成表象系统: Children’s self-concepts become more conscious, realistic, balanced, and comprehensive. 儿童的自我概念变得更加有意识、现实、平衡和全面。 他们发展广泛、包容的自我概念，整合自我的不同方面。 They start comparing the real self with the ideal self. 他们开始将现实自我与理想自我进行比较。 Erikson’s Theory: Industry vs. Inferiority 埃里克森理论：勤奋对自卑 Industry vs. Inferiority: 勤奋对自卑: 根据埃里克森的理论，这一阶段关注儿童掌握技能和完成任务的能力。 Successful resolution of this crisis results in the virtue of “competence”. 成功解决这一危机会产生“能力”这一美德。 Influence of Parents 父母的影响: 父母在塑造孩子对能力的信念方面起着至关重要的作用。 Cultural Influences on Self-Concept 文化对自我概念的影响 Euro American Children: 欧洲裔美国儿童: They tend to use personal references, e.g., “I am a wonderful and very smart person.” 他们倾向于使用个人参考，例如：“我是一个很棒而且非常聪明的人。” Chinese Children: 中国儿童: They often use social references, e.g., “I’m my mom and dad’s child, my grandma and grandpa’s grandson.” 他们经常使用社会参考，例如：“我是我爸爸妈妈的孩子，我爷爷奶奶的孙子。” Emotional Growth 情绪成长Awareness of Emotions 情绪意识 By Age 7 or 8: 到7或8岁: Children become aware of feelings such as shame, guilt, and pride. 儿童开始意识到耻辱、内疚和自豪等情感。 They also learn the cultural rules for expressing emotions. 他们还学习表达情感的文化规则。 Emotional Self-Regulation 情绪自我调节 Definition 定义: Emotional self-regulation involves voluntary control over emotions, attention, and behavior. 情绪自我调节涉及对情绪、注意力和行为的自愿控制。 Example 例子: Pretending to like a gift or smiling when angry. 假装喜欢礼物或生气时微笑。 Effortful Control 努力控制: Children low in effortful control may show visible anger or frustration when interrupted. 努力控制能力低的儿童在被打断时可能会表现出明显的愤怒或沮丧。 Those high in effortful control can stifle the impulse to show negative emotions at inappropriate times. 努力控制能力高的儿童可以抑制在不适当时候表现出负面情绪的冲动。 Empathy and Prosocial Behavior 同理心和亲社会行为 Empathy 同理心: Children become more empathetic and inclined towards prosocial behavior. 儿童变得更具同理心，并倾向于亲社会行为。 There is a relationship between empathy and prefrontal activation. 同理心与前额叶激活之间存在关系。 Child in the Family 家庭中的孩子Family Atmosphere 家庭氛围 Parental Discord 父母不和: Children exposed to parental discord often exhibit high levels of: 暴露于父母不和的儿童往往表现出高水平的: Internalizing Behaviors 内化行为: Anxiety, fearfulness, and depression. 焦虑、恐惧和抑郁。 Externalizing Behaviors 外化行为: Aggressiveness, fighting, disobedience, and hostility. 攻击性、打架、不服从和敌意。 Parenting Issues 育儿问题 Coregulation 共调节: Parents and children share power. Parents provide general supervision while children engage in self-regulation. 父母和孩子分享权力。父母提供一般监督，而孩子进行自我调节。 Discipline 纪律: Inductive Techniques 归纳技术: Pointing out the consequences of actions, e.g., “Hitting Jeremy hurts him and makes him feel bad.” 指出行为的后果，例如：“打杰里米会伤害他，让他感到难受。” Effects of Parents’ Work 家长工作的影响 Employment and Satisfaction 就业与满意度: The more satisfied a mother is with her employment, the more effective she is as a parent. 母亲对其工作越满意，她作为父母的有效性就越高。 Poverty and Parenting 贫困与育儿 Statistics 统计数据: Approximately 22% of all U.S. children under age 18 live in poverty. 大约22%的美国18岁以下儿童生活在贫困中。 Impact 影响: Poor children are more likely to have emotional and behavioral problems and suffer academically. 贫困儿童更有可能出现情感和行为问题，并在学业上遭受困境。 Family Structure 家庭结构 Divorce 离婚: Factors affecting adjustment include age, gender, and psychosocial adjustment. 影响适应的因素包括年龄、性别和心理社会适应。 Joint Custody 共同监护: Shared decision-making and physical time with each parent. 共同决策和与每位父母的实际相处时间。 长期影响 反社会行为：孩子可能会表现出更多的反社会行为。 与权威人物的冲突：孩子可能会与教师、父母等权威人物发生更多冲突。 辍学：孩子辍学的风险可能增加。 情感或心理问题：孩子可能会经历更多的情感或心理问题，如焦虑。 One-Parent Families 单亲家庭: 大约28%的美国儿童生活在单亲家庭中。这些儿童在社会和教育方面可能会滞后。 Cohabiting Families 同居家庭: 往往处于更不利的地位，收入、教育较少，心理健康问题更多。 收入较低：同居家庭通常有较低的家庭收入。 教育程度较低：同居家庭的成员通常教育程度较低。 更多心理健康问题：同居家庭成员更容易面临心理健康问题。 分手的可能性更大：同居家庭比已婚家庭更有可能分手。 Stepfamilies 继亲家庭: Adjustment can be stressful due to the involvement of multiple adults and loyalty conflicts. 由于涉及多个成年人和忠诚冲突，适应可能会充满压力。 Gay or Lesbian Parents 同性父母: 研究表明，儿童的发展没有特殊的关注点。 Adoptive Families 领养家庭: 领养带来了特殊的挑战，包括将孩子融入家庭以及有关生父母的决定。 Peer Relationships 同伴关系 Positive Aspects 积极方面: Develop sociability, intimacy, leadership, and communication skills. 发展社交、亲密关系、领导力和沟通技能。 Gain a sense of belonging. 获得归属感。 Negative Aspects 消极方面: Cliques can reinforce prejudice and foster antisocial tendencies. 小团体可以强化偏见并助长反社会倾向。 Stages of Friendship 友谊的阶段 阶段 描述 Momentary Friendship 瞬时友谊 Egocentric 自我中心的 - “她住在我家那条街上。” One-way Assistance 单向帮助 Unilateral 单方面的 - 一个“好朋友”会按你的要求做事 Two-way 双向互动 Reciprocal 互惠的 - 一种付出与回报的关系 Intimate 亲密关系 Mutal 相互的 - 友谊有自己的生命 Interdependent 相互依赖 一段良好的友谊需要承诺 Aggression 攻击性: Instrumental or Proactive Aggression 工具性或主动攻击: 减少 将 coercion 强制 视为达到目的的有效手段 小明想要在课堂上获得更多的注意力，所以他故意在其他同学发言时大声打断。这种行为是为了达到自己的目的，即获得老师的关注，他认为通过强制性的方法可以达到这个目标。 Hostile Aggression 敌对攻击: 增加 目的是伤害受害者，通常以关系形式出现。 攻击者可能有 hostile attribution bias 敌对归因偏见 – 认为他人是在试图伤害他们 小红发现小丽在社交媒体上没有邀请她参加生日聚会，她感到非常愤怒，认为小丽是故意排斥她。于是小红开始在班级群里散布关于小丽的谣言，试图伤害小丽的社会关系。小红的攻击行为是为了伤害小丽，而且她的行为源于一种敌对归因偏见，即她认为小丽是故意要伤害她的。 Bullying 欺凌 Definition: Aggression deliberately directed against a particular target Types of Bullying 欺凌的类型: Proactive 主动: To show dominance. 展示支配地位。 Reactive 反应性: In response to an attack. 应对攻击。 Cyberbullying 网络欺凌: Negative comments online. 在网上发表负面评论。 Patterns 规律: 早期建立：欺凌行为可以在幼儿园时期就开始。 在中学时期增加：欺凌行为在中学时期通常会增加，然后下降。 暂时性增加：特别是在中学男孩中，社交网络和动态会导致欺凌的暂时增加。 性别差异： 男孩：更有可能使用公开（身体）侵略。 女孩：倾向于使用关系性侵略，如社会排斥或传播谣言。 Media and Aggression 媒体与攻击性 普遍性：10个电视节目中有6个描绘暴力。 表现方式：媒体中的暴力通常被美化、淡化或荣耀化。 因果关系：大多数研究表明媒体暴力与观众的侵略行为之间存在联系。 虚拟 vs. 被动媒体： 虚拟暴力：互动媒体（如视频游戏）对侵略行为的影响可能比被动媒体（如电视）更强。","link":"/psy2033-ch10-lecture-notes/"},{"title":"PSY2033 Final Exam Prepare","text":"准备一下发展心理学的 Final Exam Overview来自 Raine 的 Slides Final Exam Duration: 2 hours50 MC (50%)+ 2 Short Essays (25% each)MC: all the chapters covered by lectureEssay: Choose Two out of Fours questions to answerTopics Covered: Language development, Play, Friendship, Nature vs. Nurture MC整理下自己在 Weekly Concept Check 里面不会或者容易做错的题 Ch1 Normative history-graded influences include all of the following EXCEPT ______ a. death of a spouse. b. introduction of the contraceptive pill. c. worldwide economic depression. d. AIDS epidemic. Normative History-Graded Influence 影响历史一代人态度的事件；例如二战。 Normative Age-Graded Influence 对一个年龄组相似；例如青春期。 Non-Normative Influences 对个体生活有重大影响的不寻常事件；例如幼年失去父母。 Ch2 According to social learning theory, the most important element in how children learn a language, deal with aggression, develop a sense of morality, and learn gender-appropriate behavior is a. classical conditioning. b. punishment of inappropriate behavior. c. shaping of appropriate behavior. d. observation and imitation. Social Learning Theory (Albert Bandura): Behaviors are learned by observing and imitating models. Dr. Willard is studying the way in which infant siblings interact with one another in the home. According to the ecological approach, Dr. Willard is studying the children in their a. mesosystem. b. microsystem. c. exosystem. d. macrosystem. 根据布朗芬布伦纳的生态系统理论（Ecological Systems Theory），人类的发展受到多个层次的环境系统的影响。这些系统包括： 微系统（microsystem）：这是个体直接接触和互动的环境，包括家庭、学校、同伴关系等。在这个层次上，个体与环境之间的相互作用是最直接和最亲密的。 中系统（mesosystem）：这是指不同微系统之间的相互关系和相互作用。例如，家庭与学校之间的互动，父母与老师之间的交流等。 外系统（exosystem）：这是个体并不直接参与但会间接影响个体发展的环境，例如父母的工作场所、社区服务、地方政府政策等。 宏系统（macrosystem）：这是指更广泛的文化、社会价值观、法律和经济系统，这些都会影响个体的成长和发展。 因此，根据生态系统理论，Dr. Willard 是在研究孩子们的微系统（microsystem），因为他关注的是孩子们在家庭这个直接互动环境中的行为。 Ch3 During which prenatal stage do the major body systems and organs develop? a. Germinal b. Fetal c. Embryonic d. Terminal Germinal 胚种期 Embryonic 胚胎期 – 器官发生：器官和主要身体系统迅速发展。 Fetal 胎儿期 – 第一个骨骼的出现，快速增长，以及器官和身体的复杂性 Genetic action that triggers the development of the body and brain are often regulated by a. hormone levels that stimulate genes. b. the specific strength and viability of growth genes. c. adequate nutrition during the developmental process. d. the amount of stress present in the environment. Ch5 According to Piaget, infants who repeat actions in order to get results outside their own bodies are engaging in a. sensorimotor conditioning. b. secondary circular reactions. c. deferred imitation. d. primary circular reactions. 详见 Ch5 Lecture Notes A child’s first word appears at about what age? a. 16 to 18 months b. 4 to 6 months c. 7 to 9 months d. 10 to 14 months Ch5 The judgment children make about their overall worth is their a. self-esteem. b. self-worth. c. self-description. d. self-concept. Ch9-10 The most widely used individually administered IQ test is the a. Wechsler Intelligence Scale for Children (WISC-III). b. Otis-Lennon School Ability Test. c. Kaufman Assessment Battery for Children (K-ABC). d. Stanford-Binet Intelligence Scale. FriendshipStages of Friendship 阶段 描述 Momentary Friendship 瞬时友谊 Egocentric 自我中心的 - “她住在我家那条街上。” One-way Assistance 单向帮助 Unilateral 单方面的 - 一个“好朋友”会按你的要求做事 Two-way 双向互动 Reciprocal 互惠的 - 一种付出与回报的关系 Intimate 亲密关系 Mutal 相互的 - 友谊有自己的生命 Interdependent 相互依赖 一段良好的友谊需要承诺 in Adolescence Characteristics: Adolescence 时期的友谊强度和与朋友在一起的时间可能比其他任何时候都更多。 更大的亲密度（女孩&gt;男孩） 忠诚 与朋友分享秘密 More reciprocal and stable than in childhood 增加的亲密度、稳定性 Adolescent Crowds and Cliques: Clique ‐ 小圈子，一个有结构的朋友群体 服务于帮助建立身份、加强联盟和促进同一组内友谊等目的。 in Young Adulthood Stability: Less stable than either adolescence or later adulthood. 比 adolescence 或 later adulthood更不稳定。 原因之一是成年期通常是一个充满变化的时期，人们可能会因为工作、婚姻、搬迁等因素频繁调整自己的生活，这些变化可能导致友谊的变动和调整。 一些友谊比恋人或配偶的关系更稳定。 以工作和育儿活动为中心。 分享秘密和建议。 Developmental Changes: Young singles rely on friendship for social needs. Number of friends and amount of time with friends decreases. Gender Differences: Women have social needs met by friends more than men. Women share confidences and talk about marital problems. 女性分享秘密并谈论婚姻问题。 Men share information and activities. Exercise 解释友谊在不同发展阶段的特点。 友谊在不同的发展阶段具有不同的特点： 瞬时友谊（Momentary Friendship）：这是一种以自我为中心的友谊，主要基于地理上的接近，如“她住在我家那条街上”。 单向帮助（One-way Assistance）：这种友谊是单方面的，一个“好朋友”会按你的要求做事。 双向互动（Two-way）：这种友谊是互惠的，关系中的双方都会付出与回报。 亲密关系（Intimate）：这是相互的友谊，友谊有自己的生命。 相互依赖（Interdependent）：良好的友谊需要承诺，双方互相依赖。 描述青少年时期友谊的特点，并说明为什么这一时期的友谊通常比童年时期更稳定。 青少年时期的友谊具有更大的亲密度（尤其在女孩中）、忠诚和分享秘密的特点。相比童年时期，青少年的友谊更具互惠性和稳定性，因为青少年时期个体开始寻求更深层次的情感支持和认同。青少年期的小圈子（Clique）也有助于建立身份、加强联盟和促进同一组内的友谊，这些都增加了友谊的稳定性。 分析青年早期友谊的稳定性，并解释为什么这一时期的友谊通常不如青少年期或成年期后期稳定。 青年早期的友谊通常比青少年期或成年期后期不稳定，这是因为青年期通常是一个充满变化的时期。工作、婚姻、搬迁等因素频繁调整人们的生活，导致友谊的变动和调整。尽管如此，有些友谊比恋人或配偶的关系更稳定，特别是那些以工作和育儿活动为中心的友谊。 比较男女在青年早期友谊中的不同特点。 在青年早期，男女在友谊中的特点有显著差异： 女性：女性通过朋友满足社会需求的比例高于男性。她们更倾向于分享秘密和讨论婚姻问题。 男性：男性的友谊更多是分享信息和活动。他们倾向于通过共同参与的活动建立联系。 解释小圈子（Clique）在青少年时期的重要性及其对友谊的影响。 小圈子（Clique）是一个有结构的朋友群体，在青少年时期非常重要。小圈子帮助青少年建立身份认同，强化联盟，并促进同一组内的友谊。通过参与小圈子，青少年可以找到归属感和支持，从而提高友谊的亲密度和稳定性。 为什么青年单身者在社会需求上更多依赖友谊？并说明随着年龄增长，朋友数量和与朋友相处的时间为何减少？ 青年单身者在社会需求上更多依赖友谊，因为他们缺乏伴侣的情感支持，需要通过朋友来满足社会互动和情感支持的需求。随着年龄增长，朋友数量和与朋友相处的时间减少是因为成年期的责任增多，如工作、婚姻和育儿，导致个人可支配的社交时间减少。此外，随着年龄的增长，人们往往更注重质量而非数量，因此友谊关系会趋向于更稳定和更深层次。 PlayTypes of Play 游戏类型 Functional Play 功能性游戏: Simple, repetitive activities with objects or physical movements 简单的重复性活动或身体运动 Constructive Play 建构性游戏: Using objects to build or create something 使用物体建造或创造某物 Dramatic Play 戏剧性游戏: Involves imaginary situations and role-playing 包含想象情境和角色扮演 Social Dimension of Play 游戏的社会维度 Solitary Independent Play 独自独立游戏 Parallel Play 平行游戏 Associative Play 关联游戏 Cooperative Play 合作游戏 Gender Influences on Play 性别对游戏的影响 Gender Segregation 性别隔离: Boys: Active, physically aggressive, exploratory 男孩：积极、身体上攻击性强、探索性强 Girls: Structured, nurturing, pretend play 女孩：结构化、培育性、假装游戏 Recess-time Play 课间玩耍 Nature of Play 游戏性质: Informal and spontaneous. 非正式和自发的。男孩参与更多的体力活动，而女孩则喜欢涉及语言表达的游戏。 Rough-and-Tumble Play 粗犷游戏: Involves vigorous activities like wrestling, kicking, chasing, and screaming. Accounts for 10% of free play and has adaptive benefits. 包括摔跤、踢、追逐和尖叫等剧烈活动。占自由游戏的10%，并具有适应性益处。 Exercise 解释功能性游戏的特点，并举例说明这种游戏在儿童早期发展的作用。 功能性游戏的特点： 功能性游戏涉及简单的、重复性的活动，例如用玩具敲击、摇晃或扔东西。这些活动通常不涉及创造性或想象性的思维，而是基于物体或身体的基本操作。 作用： 在儿童早期发展中，功能性游戏帮助儿童发展基本的运动技能和手眼协调能力。例如，一个孩子可能反复地推倒积木塔，然后再重新搭建，通过这种重复的活动，孩子练习和掌握基本的动作技能。 描述建构性游戏的特点，并解释其对认知发展的影响。 建构性游戏的特点： 建构性游戏包括使用物体来建造或创造某物，例如用积木搭建建筑物或用泥土捏制形状。 影响： 建构性游戏促进认知发展，因为它需要儿童进行规划、解决问题和创造性思考。例如，当孩子用积木搭建桥梁时，他们必须考虑如何使桥梁稳固，并通过反复尝试找到最佳解决方案。 分析戏剧性游戏对儿童情感发展的贡献。 戏剧性游戏的特点： 戏剧性游戏包含想象情境和角色扮演，儿童通过扮演不同的角色和场景来探索和表达情感。 贡献： 戏剧性游戏有助于儿童情感发展，因为它允许他们通过安全的、控制的环境来探索和表达自己的情感。例如，一个孩子可能通过扮演医生来表达对医院的恐惧或好奇心，并学会通过角色扮演来处理和理解这些情感。 比较不同社会维度的游戏类型及其在社交技能发展中的作用。 独自独立游戏（Solitary Independent Play）： 孩子独自玩耍，不与他人互动。这种游戏类型在早期发展阶段常见，有助于培养独立性和自我娱乐的能力。 平行游戏（Parallel Play）： 孩子们在同一个空间中独自玩耍，但不直接互动。平行游戏帮助儿童习惯与他人共享空间，并为后来的互动打下基础。 关联游戏（Associative Play）： 孩子们开始有一些互动，但没有明确的组织或共同目标。例如，共享玩具或讨论游戏，但没有合作。这种游戏类型促进基本的社交技能，如分享和沟通。 合作游戏（Cooperative Play）： 孩子们共同参与有组织的活动，有明确的分工和共同目标。这种游戏类型最能促进高级社交技能，如团队合作、领导和解决冲突。 讨论性别对游戏行为的影响，并举例说明男孩和女孩在游戏中的不同表现。 性别对游戏行为的影响： 男孩： 行为：通常更活跃，喜欢参与探索性和身体上更具攻击性的游戏。 举例：男孩可能喜欢玩捉迷藏、踢足球或搭建冒险型积木结构。 女孩： 行为：更倾向于结构化的游戏，喜欢培育性和假装游戏。 举例：女孩可能喜欢玩“过家家”或照顾娃娃，进行角色扮演和语言表达的活动。 解释粗犷游戏的性质，并讨论其适应性益处。 粗犷游戏的性质： 粗犷游戏包括剧烈的活动，如摔跤、踢、追逐和尖叫。它通常发生在课间或自由玩耍时间，虽然看起来混乱，但有一定的规则和界限。 适应性益处： 身体发展：这种类型的游戏有助于增强体力和运动技能。 社交技能：通过这种游戏，孩子们学习界限和自我控制，了解什么时候应该停止以及如何在激烈活动中保护自己和他人。 情感调节：粗犷游戏提供了一种释放能量和情感的安全途径，有助于儿童管理和调节情绪。","link":"/psy2033-final-exam-prepare/"},{"title":"PSY2033 Ch13 Lecture Notes","text":"PSY2033 Developmental Psychology Ch13 Physical and Cognitive Development in Young Adulthood Emerging Adulthood 崭露头角的成年期Psychological Maturity 心理成熟 发现自我身份，独立于父母，发展一套价值观，建立关系。 Internal Indicators: Sense of autonomy 自主感 Self-control 自我控制 Personal responsibility 个人责任感 Some people never become adults. 有些人永远不会成为成年人。 Criteria for Adulthood 成年的标准 Accepting responsibility for oneself 接受自我责任 Making independent decisions 做出独立决定 Becoming financially independent 经济独立 Emerging adulthood – 年轻人弄清楚他们是谁以及他们想成为什么样的人。 Health Status in Young Adulthood 青年期的健康状况 Most young adults are healthy (95%). Accidents are the leading cause of death. 意外是死亡的主要原因。 Highest poverty rate and lowest level of health insurance of any age group. Genetic Influences on Health 健康的遗传影响 Many disorders have roots in genetics: Obesity Some cancers (lung, prostate, and breast) High cholesterol 高胆固醇 Coronary heart disease 冠心病 HIV/AIDS Behavioral Influences on Health 健康的行为影响 Nutrition Physical Activity Moderate exercise has health benefits. Benefits: Build muscle Strengthens heart and lungs Lowers blood pressure Protects against heart disease, stroke, diabetes, cancers Relieves anxiety and depression Lengthens life Stress Coping Strategies: Emotion-focused coping (more likely used by women) 情绪焦点应对（女性更常用） Problem-focused coping (relationship helps) 问题焦点应对（关系有帮助） Relationship helps Sleep Sleep Deprivation Effects: Physical Cognitive Emotional Social Sleep Quality vs. Sleep Duration Smoking Alcohol Use or Abuse Indirect Influences on Health 健康的间接影响SES and Race/Ethnicity 社会经济地位和种族/民族 高收入人群的健康状况评价较好，寿命较长。 Does income and education cause good health ? 收入和教育会导致良好的健康吗？ Relationships人际关系 Social Integration: 积极参与广泛的社会关系、活动和角色——较低的死亡率。 Social Support: 来自 Social Network 的物质、信息和心理资源，个人可以依靠这些资源来应对压力。 Mental Health Problems 心理健康问题Alcoholism Alcoholism – 一种长期的身体状况，以强迫性饮酒为特征 Heritability Treatments Drug Use and Abuse 药物使用和滥用 20% of 18-25 year olds used drugs during the past month. Substance abuse disorders linked with mood disorders. DepressionPremenstrual Syndrome (PMS) 经前综合症 月经前一到两周内的身体和情绪不适。 Physical Symptoms: Fatigue, headaches, swelling and tenderness of breasts, bloating, nausea, cramps 疲劳、头痛、乳房肿胀和压痛、腹胀、恶心、抽筋 Psychological Symptoms: Irritability, grouchiness, moodiness, acting demanding, aggressiveness, hostility 易怒、脾气暴躁、情绪不稳定、要求苛刻、攻击性、敌意 大约85%的女性至少有一种PMS症状。 Infertility 不孕症 尝试12个月后仍无法怀孕。 7%的美国夫妇经历过不孕症。 Common Causes in Males: Low sperm count Common Causes in Females: 无法产生卵子或卵子异常 宫颈黏液 子宫内膜异位症 Coginitive DevelopmentCognition in Adulthood: Reflective Thinking 成人期的认知：反思性思维 Active and persistent consideration of information or beliefs. 积极且持续地考虑信息或信念。 Questioning supposed facts. 质疑假定的事实。 在20到25岁之间出现。 Cortical regions with enriched myelination. 皮质区域髓鞘化丰富。 Few attain optimal proficiency in this skill. 很少有人在这项技能上达到最佳水平。 Postformal Thought 后形式思维 Ability to deal with: Uncertainty and inconsistency Contradiction Imperfection and compromise 处理以下问题的能力： 不确定性和不一致性 矛盾 不完美和妥协 Flexibility: Draws on different aspects of cognition: logic, intuition, emotion 借鉴认知的不同方面：逻辑、直觉、情感 More flexible and adaptive. 更灵活和适应性强。 Make deeper connections. 建立更深的联系。 Reconcile conflicting ideas. 调和矛盾的想法。 Develop overarching theories that explain different concepts. 发展解释不同概念的总体理论。 Aspects of Postformal Thought Shifting Gears 换挡: Shift back and forth between the abstract and the practical. 在抽象和实际之间来回切换。 Problem Definition: 将问题定义为逻辑问题的一类或类别，并定义其参数。 Process-Product Shift 过程-产品转换: 一个具有普遍应用于类似问题的过程和一个具体解决特定问题的产品。 Pragmatism 实用主义: 选择最佳解决方案并识别标准。 Multiple Solutions: 大多数问题有多个解决方案，可以使用不同的目标和方法来达成解决方案。 Awareness of a Paradox 悖论意识: 一个问题或解决方案包含固有的冲突。 Self-Referential Thought 自我参照思维: 意识到自己在使用后形式思维。 Schaie: Life Span Model of Cognitive Development 认知发展的生命周期模型 Acquisitive Stage 获取阶段 (childhood and adolescence) Achieving Stage 成就阶段 (late teens or early 20s to early 30s) 利用他们所知道的去追求目标，比如职业和家庭。 Responsible Stage 负责阶段 (late 30s to early 60s) Executive Stage (30s or 40s through middle age) 负责社会系统（如政府或商业组织）或社会运动。 处理多层次的复杂关系。 Reorganizational Stage 重组阶段 (end of middle age, beginning of late adulthood) Reintegrative Stage 再整合阶段 (late adulthood) Legacy-Creating Stage 遗产创造阶段 (advanced old age) Sternberg: Insight and Know-how 斯腾伯格：洞察力和技能 Alix、Barbara 和 Courtney 申请了耶鲁大学的研究生课程。 Alix 在大学期间几乎全A，并且在研究生入学考试（GRE）中得分很高。 Barbara 的成绩一般，她的GRE成绩低于耶鲁的标准，但她的推荐信热情地称赞了她出色的研究和创造性想法。 Courtney 的成绩、GRE成绩和推荐信都很好，但不是最好的。Alix 和 Courtney 被录取为研究生。 Alix 在头一年左右表现非常好，但在被要求发展独立的研究想法后表现较差。 Courtney 在研究生院的表现仅仅是公平，但她在之后找工作时最轻松。 Barbara 没有被录取，但被聘为研究助理，并旁听研究生课程。Barbara 以出色的工作表现让招生委员会感到困惑。 Sternberg: Theory of Intelligence 斯腾伯格：智力理论Triarchic Theory of Intelligence 三元智力理论 Componential: Analytical thinking and problem-solving abilities. Experiential: How insightful or creative a person is. Contextual: Practical aspect of intelligence. 成分理论：分析性思维和解决问题的能力。 经验理论：一个人的洞察力或创造力。 背景理论：智力的实际方面。 Tacit Knowledge 隐性知识 Inside information, know-how, savvy. 内部信息，技能，机智。 Self Management 自我管理 Management of Tasks 任务管理 Management of Others 他人管理 Emotional Intelligence (EI) The ability to perceive, use, understand, and manage, or regulate, emotions (our own and those of others)—so as to achieve goals. 感知、使用、理解和管理或调节情绪（我们自己的和他人的）—— 以达到目标的能力。 High score in EI leads to more positive relationships. 高情商得分导致更积极的关系。 High score in EI leads to higher sociability, interpersonal sensitivity, leadership potential, and ability to handle stress and conflict. 高情商得分导致更高的社交能力、人际敏感度、领导潜力和处理压力与冲突的能力。 High score in EI leads to higher salaries and more promotions. 高情商得分导致更高的薪水和更多的晋升机会。","link":"/psy2033-ch13-lecture-notes/"},{"title":"PSY2033 Ch14 Lecture Notes","text":"PSY2033 Developmental Psychology Ch14 Phychosocial Development in Emerging and Young Adulthood Personality Development: Four models1. Normative Stage Model 规范阶段模型 Models that argue for a definite sequence of age-related changes in psychosocial development. 这些模型认为心理社会发展中存在一个确定的年龄相关变化序列。 Erikson: Intimacy versus Isolation: Make commitments to others or face a possible sense of isolation and consequent self-absorption. 达成对他人的承诺，否则可能面临孤立感和随之而来的自我吸收。 Virtue Attained: Love, a mutual devotion between partners who have chosen to share their lives, have children, and help those children achieve their own healthy development. 获得的美德：爱，一种在选择分享生活、生育子女并帮助这些孩子实现自身健康发展的伴侣之间的相互奉献。 Life Structure: The underlying pattern of a person’s life at a given time, built on whatever aspects of life the person finds most important. 一个人在特定时间的生活的基础模式，基于个人认为最重要的生活方面。 Dream: One’s hopes about what one wishes to achieve in the future, part of the entry phase of young adulthood. 梦想：一个人对未来希望实现的目标，是青年期入门阶段的一部分。 Emerging Adulthood: Period between the ages of 18-25. Shifting cultural forces; delayed onset of full adulthood. 文化力量的转变；成年期的延迟开始。 Increase in the amount of education needed for a good career. 良好职业所需教育水平的提高。 Frequency of cohabitation without marriage. 未婚同居的频率。 Continued identity exploration. 持续的身份探索。 Insecurity, instability, self-focus. 不安全、不稳定、以自我为中心。 Normative Studies of Women: Women may face different psychological and environmental constraints in forming life structures than men do. 女性在形成生活结构时可能面临与男性不同的心理和环境限制。 Women’s transitions tend to take longer. 女性的转变往往需要更长时间。 Between age 27-43, women (as opposed to 17-33 for men) develop more self-discipline, commitment, independence, and confidence. 在27-43岁之间，女性（相比男性的17-33岁）发展出更多的自律、承诺、独立和自信。 2. Timing-of-Events Model 事件时机模型 A model that describes adult psychosocial development as a response to the expected or unexpected occurrence and timing of important life events. 一种将成年心理社会发展描述为对重要生活事件预期或非预期发生及其时机的响应的模型。 Social Clock: A set of cultural norms or expectations for the times of life when important events, such as marriage, parenthood, entry into work, and retirement, should occur. 社会时钟：一组关于重要事件（如结婚、育儿、进入职场和退休）应何时发生的文化规范或期望。 3. Traits Model 特质模型 Models that focus on mental, emotional, temperamental, and behavioral traits, or attributes. 这些模型关注心理、情绪、气质和行为特质或属性。 Big Five Personality Traits: Neuroticism: The tendency to experience emotional instability: anxiety, hostility, depression, self-consciousness, impulsiveness, and vulnerability very easily. Extraversion: The tendency to seek stimulation and enjoy the company of other people. Agreeableness: The tendency to be trusting and compassionate rather than distrustful of and antagonistic towards others. Conscientiousness: The tendency to show self-discipline, to be reliable, and to strive for competence and achievement. Openness to Experience: The tendency to enjoy new experiences and new ideas. Big Five Personality Traits： 神经质：情绪不稳定的倾向：容易体验到焦虑、敌意、抑郁、自我意识、冲动和脆弱。 外向性：寻求刺激和享受他人陪伴的倾向。 宜人性：倾向于信任和富有同情心，而不是不信任和对抗他人。 尽责性：表现出自律、可靠，努力追求能力和成就的倾向。 开放性：享受新体验和新想法的倾向。 Continuity and Change: 这意味着一个人的基本人格特质在不同的生活阶段中保持相对稳定。 例如，一个年轻时外向性高的人在老年时仍然可能是外向的。 Other research found change in personality throughout adulthood. 其他研究发现，整个成年期的人格会发生变化。 Evaluation: Research has found gradual, systematic change in personality throughout adulthood, not continuity. 研究发现，整个成年期的人格逐渐、系统地变化，而不是而不是持续不变的。 Five-factor model is based on subjective ratings—may lack validity. 五因素模型基于主观评价，可能缺乏有效性。 4. Typological Models 类型学模型 Models that identify broad personality types or styles. 这些模型识别广泛的人格类型或风格。 Friedman’s and Rosenman’s Personality Types: Type A Personality: A highly competitive, impatient, hurried person who typically has a hostile temperament. Type B Personality: An easygoing, less hurried, and less hostile person. 弗里德曼和罗森曼的人格类型： A型人格：一个非常有竞争力、急躁、匆忙的人，通常具有敌对的性情。 B型人格：一个悠闲、不那么匆忙、不那么敌对的人。 Jack Block’s Personality Types: Ego-Resilient: Well adjusted, confident, and task-focused. Overcontrolled: Shy, quiet, anxious, and withdraw from conflict. Undercontrolled: Active, energetic, impulsive, stubborn, and distractible. 杰克·布洛克的人格类型： 自我韧性：适应良好、自信、任务导向。 过度控制：害羞、安静、焦虑，回避冲突。 欠控制：活跃、精力充沛、冲动、固执且容易分心。 Intimate Relationships and Love 亲密关系和爱情Intimacy 亲密 Requirements: Self-awareness Empathy Ability to communicate emotions Ability to resolve conflicts Sustain commitments 要求： 自我意识 同理心 沟通情感的能力 解决冲突的能力 维持承诺 Interplay between personality and relationship. 人格与关系之间的相互作用。 例如，高神经质的人倾向于进入让他们感到不太安全的关系。 Friendship 友谊 Stability: Less stable than either adolescence or later adulthood. 比青少年或成年晚期更不稳定。 原因之一是成年期通常是一个充满变化的时期，人们可能会因为工作、婚姻、搬迁等因素频繁调整自己的生活，这些变化可能导致友谊的变动和调整。 一些友谊比恋人或配偶的关系更稳定。 以工作和育儿活动为中心。 分享秘密和建议。 Developmental Changes: Young singles rely on friendship for social needs. Number of friends and amount of time with friends decreases. Gender Differences: Women have social needs met by friends more than men. Women share confidences and talk about marital problems. 女性分享秘密并谈论婚姻问题。 Men share information and activities. Sternberg: Triangular Theory of Love 斯滕伯格：三角理论的爱 Components: Intimacy: Emotional element involving self-disclosure. Passion: Motivational element translating physiological arousal into sexual desire. Commitment: Cognitive element involving the decision to love and stay with the beloved. 组成部分： 亲密：涉及自我揭示的情感元素。 激情：将生理唤起转化为性欲的动机元素。 承诺：涉及爱和与所爱之人共度一生的决定的认知元素。","link":"/psy2033-ch14-lecture-notes/"},{"title":"PSY2043 Ch01 Lecture Notes","text":"PSY2043 Introduction to Psychology Ch01 The Nature of Psychology INTENDED LEARNING OUTCOMES Understand the scope of scientific psychology. The scope of psychology is broad, covering topics such as face recognition, social judgments, memory, obesity, violence, and many more. Understand differing historical perspectives on the topics within psychology. Know five contemporary perspectives within psychology. Historical perspectives Structralism (the analysis of mental structures) Functionalism (studying how the mind works so that an organism can adapt to and function in its environment) Behaviorism (the study of behavior without reference to consciousness) Gestalt psychology (which focuses on the patterns formed by stimuli and on the organization of experience) Psychoanalysis (which emphasizes the role of unconscious processes in personality development and motivation) Information-processing theory Psycholinguistics Neuropsychology 5 Contemporary perspectives Biological perspectives Behavioral perspectives Cognitive perspectives Psychoanalytic perspectives Subjectivist perspectives Be familiar with seven major subfields within contemporary psychology. Know four cutting-edge interdisciplinary approaches in psychology. 7 Major subfields Biological psychology Cognitive psychology Developmental psychology Social and personality psychology Clincial and counseling psychology School and educational psychology Organizational and engineering psychology 4 Cutting-edge interdisciplinary approaches in psychology Cognitive neuroscience – learn how mental activities are executed in the brain (scanning). Evolutionary psychology – psychological mechanisms have a genetic basis and in the past increased our ancestors’ chances of surviving and reproducing. Cultural psychology Postive psychology Define psychology. Give examples of psychological research. Psychology can be defined as the scientifc study of behavior and mental process. Examples Brain damage and face recognition Attributing traits to people Childhood amnesia Obesity Effects of media violence on children’s aggresion Identify key ideas and debates that shaped the history of psychology. Give examples of five different perspectives within contemporary psychology. idea – mind and behavior could be the subject of scientific analysis – scientific psychology born debate – nature vs nurture Explain how psychologists use the scientific method to uncover knowledge. Generating a hypothesis Testing it by using a scientific method Experimental method Correlational method Observational method State the principles that guide the ethical conduct of psychological research. Minimal risk Informed consent Right to privacy The Scope of Psychology To evaluate new claims made about psychology, you need to know(1) what psychological facts are already firmly established(2) the standards for scientific evidence. Psychology can be defined as the scientifc study of behavior and mental process. The Historical Origins of Psychology Nature-nurture debate Roots of psychology can be traced to the 4th and 5th centuries B.C. One of the earliest debates about human psychology focused on the question of whether human capabilities are inborn or acquired through experience (the nature–nurture debate). The beginnings of scientific psychology 科学心理学 Scientific psychology was born in the late nineteenth century with the idea that mind and behavior could be the subject of scientific analysis. The first experimental laboratory in psychology was established by Wilhelm Wundt at the University of Leipzig in 1879. （十九世纪末 Wilhelm Wundt 建立） Wilhelm Wundt: Introspection（内省法）- observing and recording the nature of one’s own perceptions, thoughts, and feelings The early ‘schools’ of psychology in the twentieth century Structuralism and funtionalism（结构主义和功能主义） Titchener – structuralism – the analysis of mental structures William James – functionalism – studying how the mind works to enable an organism to adapt to and function in its environment. Both structuralists and functionalists still regarded psychology as the science of conscious experience Behaviorism（行为主义） Watson, and others ascribing to behaviorism, argued that nearly all behavior is a result of conditioning and the environment shapes behavior by reinforcing specific habits. Gestalt psychology（格式塔心理学） The Gestalt psychologists’ primary interest was perception, and they believed that perceptual experiences depend on the patterns formed by stimuli and on the organization of experience. Psychoanalysis（精神分析） At the center of Freud’s theory is the concept of the unconscious – the thoughts attitudes, impulses, wishes, motivations, and emotions of which we are unaware. Later developments in twentieth-century psychology Information-processing theory（信息处理理论） Psycholinguistics（心理语言学） Neuropsychology（神经心理学） Contemporary Psychology Perspectives The biological perspective The behaviroal perspective The cognitive perspective The psychoanalytic perspective The subjectivist perspective An orientation toward understanding behavior and mental processes in terms of the subjective realities people actively construct. Relationships between psychological and biological perspectives Reductionism - Biological researchers often attempt to explain psychological principles in terms of biological ones Major subfields of psychology Biological psychology Cognitive psychology Developmental psychology Social and personality psychology Clincial and counseling psychology School and educational psychology Organizational and engineering psychology How Psychological Research is Done Generating hypotheses Experiments Correlation Observation Literature reviews Ethics of psychological","link":"/psy2043-ch01-lecture-notes/"},{"title":"PSY2043 Ch02 Lecture Notes","text":"PSY2043 Introduction to Psychology Ch02 Biological Foundations of Psychology INTENDED LEARNING OUTCOMES Understand the organization and the physiology of the human brain. Have learned the research methods used to study the brain. computerized axial tomography (CT) magnetic resonance imaging (MRI) positron emission tomography (PET) Be able to consider evolutionary arguments. Darwin – Nature selection – variations on inheritable traits that most contribute to an organism’s survival that are passed on to the next generation. Explain the basics of the biology of the brain. Identify key areas in the human brain, including their function. Understand key principles concerning the heredity of behavior. An individual’s hereditary potential, which is transmitted by the chromosomes and genes, influences his or her psychological and physical characteristics. The Study of the Biological Bases of Psychology peripheral nervous system 周围神经系统 spinal cord 脊柱 afferent nerves 传入神经 efferent nerves 传出神经 somatic nervous system 躯体神经系统 autonomic nervous system 自主神经系统 Neurons, the Building Block of the Nervous System Neurons’ three categories Sensory neurons – transmit impulses from receptors to CNS Motor neurons – carry outgoing signals from CNS to muscles and glands Inter-neurons – connect sensory and motor neurons Action potentials 5分钟极速认识神经系统和脑 - 艾菲的文章 - 知乎神经信号的传递步骤：（看图理解会更快哦~） 前一个神经元的轴突末端，释放化学信号（神经递质），通过突触（前后两个神经元接触的结构），传递至后一个神经元的树突前端的位置； 树突前端的膜打开一道门，接收神经递质携带的信号并产生正负离子交换，在细胞内积累对应电极的离子； 多个树突接收的信号共同形成细胞整体的电信号并达到兴奋临界点时，激发电信号（动作电位）； 电信号通过轴突跳跃式快速传递至末端； 电信号转化为化学物质，再继续传下去； 高中生物静息电位和动作电位 - 朝济夕设版的朝夕的文章 - 知乎 静息电位（K+ 的平衡电位） 产生条件 细胞膜内外离子分布不平衡 就正离子来说，膜内 K+ 浓度较高，约为膜外的30倍。膜外 Na+ 浓度较高约为膜内的10倍。从负离子来看，膜外以Cl-为主，膜内则以大分子有机负离子 (A-) 为主。 膜对离子通透性的选择 在静息状态下，膜对 K+ 的通透性大，对 Na+ 的通透性则很小(Na+ 通道关闭)，对膜内大分子 A- 则无通透性。 产生过程 K+ 顺浓度差向膜外扩散，膜内 A- 因不能透过细胞膜被阻止在膜内。致使膜外正电荷增多，电位变正，膜内负电荷相对增多，电位变负，这样膜内外便形成一个电位差。 当促使 K+ 外流的浓度差和阻止 K+ 外流的电位差这两种拮抗力量达到平衡时，使膜内外的电位差保持一个稳定状态，即静息电位。 动作电位 产生条件 细胞膜内外离子分布不平衡。细胞内外存在着Na+浓度差，Na+在细胞外的浓度是细胞内的13倍之多。 膜对离子通透性的选择。细胞受到一定刺激时，膜对Na+的通透性增加。 产生过程 去极化 细胞受到阀上刺激→细胞外Na+顺浓度梯度流人细胞内→当膜内负电位减小到阈电位时Na+通道全部开放→Na+顺浓度梯度瞬间大量内流（正反馈倍增）→细胞内正电荷增加→膜内负电位从减小到消失,进而出现膜内正电位→膜内正电位增大到足以对抗由浓度差所致的Na+内流→膜两侧电位达到一个新的平衡点。该过程主要是Na+内流形成的平衡电位，可表示为动作电位模式图的上升支。 复极化 达峰值时Na+通道迅速关闭而失活→Na+内流停止→K+通道被激活→膜对K+的通透性增加→K+借助于浓度差和电位差快速外流→膜内电位迅速下降（负值迅速上升）→电位恢复静息值。该过程是K+外流形成的，可表示为动作电位模式图的下降支。 Na+-K+ 泵转运 当膜复极化结束后，有一部分Na+在去极化中扩散到细胞内，一部分K+在复极过程中扩散到细胞外。这样细胞膜上Na+-K+泵就会被激活，并主动将膜内的Na+泵出膜外，同时把流失到膜外的K+泵回膜内,以恢复兴奋前的离子分布的浓度 Synaptic transmission and neural codingNeurotransmittersInhibitory neurotransmitters GABA – Major inhibitory neurotransmitter in brain. Drugs that alleviate anxiety enhance activity of GABA. Serotonin – Important in mood and social behavior. Drugs that alleviate depression and anxiety increase serotonin levels in synapse. Excitatory neurotransmitters Acetylcholine – Involved in memory and attention; decreases associated with Alzheimer’s disease. Also transmits signals between nerve and muscle. Norepinephrine – Increased by psycho-timulants. Low levels contribute to depression. Dopamine – Mediates the effects of natural rewards (food and sex, for example) and drugs of abuse. Glutamate – Major excitatory neurotransmitter in brain. Involved in learning and memory. The Organization of the Brain Categories Location the hindbrain the midbrain the fore brain Function (McLean’s three concentric layer) the central core(brainstem) – regulates our most primitive behaviors the limbic system – controls our emotions the cerebrum – regulates our higher intellectual processes The hindbrain Medulla 髓质 – 一个狭窄的结构，控制呼吸和一些反射，有助于保持直立姿势 Pons 脑桥 – 对控制注意力和睡眠时间非常重要 Reticular formation 网状结构 – control arousal Cerebellum 小脑 – 动作的协调 The midbrain Superior and inferior colliculus 上丘和下丘 – 对于向大脑传递感觉信息和控制运动（包括眼球运动）非常重要 Substantia nigra 黑质 – 多巴胺通路（又称 “奖赏通路”）的重要组成部分 The forebrain Thalamus 丘脑 – 充当感觉中继站，将感官感受器（如视觉和听觉）传入的信息导向大脑 Hypothalamus 下丘脑 – 下丘脑中的中枢调节饮食和性行为。下丘脑通过控制自主神经系统来维持体内平衡（Homeostasis 稳态） Pituitary gland 垂体 – 影响激素的产生 Limbic system Hippocampus – memory Amygdala - emotional Cerebrum Cerebral cortex – the out layer of cerebrum left and right hemispheres 左右大脑半球 每个 hemisphere 可以被分为 4 个 lobes Frontal lobe 额叶 Parietal lobe 顶叶 Occipital lobe 枕叶 Temporal lobe 颞叶 Central fissure 分割额叶和顶叶 Lateral fissure 分割颞叶和其他叶 longitudinal fissure 纵裂 脑裂 – 分割 hemispheres corpus callosum 胼胝体 – 连接大脑皮层的 hemispheres Mapping the brainAsymmetires in the brain Language aphasia 失语症 – 无法产生语言 Broca’s area – 左半球额叶 receptive aphasia 接受性失语症 – 无法理解语言 Wernicke’s area – 左半球颞叶 Split-Brain research – 切断胼胝体会导致两个半球功能上的显著差异 Hemispheric specialization 半球专门化 Left hemisphere – 擅长语言和数学能力 Right hemisphere – 可以理解一些语言，但不能通过言语交流；它具有高度发达的空间和模式感。 The Autonomic Nervous System Autonomic nervous system Sympathetic nervous system – active during excitement Parasympathetic nervous system – dominant during quiescence The Endocrine SystemEvolution, Genes, and BehaviorEvolution of behavior Ultimate causes – help us to understand why a behavior exists in the first place Proximate causes – explain how a behavior is generated Chromosomes and genesGenetic studies of behavior","link":"/psy2043-ch02-lecture-notes/"},{"title":"PSY2043 Ch03 Lecture Notes","text":"PSY2043 Introduction to Psychology Ch03 Psychological Development Intended Learning Outcomes Understand how heredity and environment interact to determine human development. Be able to define the concept of maturation and show how it relates to this interaction. Genetically determined characteristics are expressed through the process of maturation. The environment affects the rate at which children acquire the skills, not the ultimate skill level Maturation – an innately determined sequence of growth and change that is relatively independent of external events 先天决定的成长和变化的顺序，相对独立于外部事件 Be familiar with what psychologists mean by developmental stages and by the related concepts of critical and sensitive periods. Stages of development Behavior at a given stage is organised around a coherent set of characteristics Behavior at each stage is qualitatively different from that at earlier or later stages States that all children go through the same stages in the same order (many psychologists disagree) Environmental factors may affect speed of progress through, but not the order of, stages Critical periods – crucial time periods in a person’s life when specific events occur if development is to proceed normally Sensitive periods – periods that are optimal for a particular kind of development Be able to describe the capacities of the newborn and the procedures used to assess these capacities. Capacities Vision – poor, cannot see as well as an adult until about age 2. 即使新生儿也会注意到声音，他们似乎天生具有已调整到将帮助他们学习语言的人类语音特性的感知机制 Infants can discriminate between different tastes and odors shortly after birth. They seem to show a preference for the taste and odor of breast milk. Infants can learn from the moment they are born and show good memories by three months of age Procedures Know the sequence of Piaget‘s stages of cognitive development and some difficulties with Piaget’s theory and with alternative views. Be able to describe Kohlberg’s work on moral reasoning and its three levels. Piaget’s theory Stages Sensorimotor (0-2) Preoperational (2-7) Concrete operational (7-11) Formal operational (11+) Difficulties Understimate children’s abilities Alternatives Information-processing approaches Knowledge-acquistion approaches Sociocultural approaches Kohlberg Piaget believed children’s understanding of moral rules developed along with cognitive abilities Kohlberg extended Piaget’s work to include adolescence and adulthood and arrived at six developmental stages of moral judgment, grouped into three levels Level 1 – Preconventional morality Level 2 – Conventional morality Level 3 – Postconventional morality Be familiar with characteristics of personality development and early social behavior. Be familiar with some aspects of the physiology of puberty and with psychological effects of this period on various dimensions of the adolescent. Heredity and Environment 先天与后天 Maturation成熟 : an innately determined sequence of growth and change that is relatively independent of external events 先天决定的成长和变化的顺序，相对独立于外部事件 Key debate : nature v.s. nurture? John Locke - “tabula rasa” (white board) - nurture Darwin’s theory of revolution - nature Behaviorists (Skinner, Watson) - nurture Stages of development 发展过程是依循一套性质不同的阶段的固定顺序 Def 每一阶段的行为都环绕着某一强势特征 每一阶段的行为的性质都与前后阶段不同 所有孩子都以相同顺序经历相同的阶段 环境因素会影响速度，但不会改变次序 Critical Period Crucial periods in a person’s life when specific events [occur] 在个人一生的重要阶段中，必须发生某种特殊事件，发展才能正常进行 如果在这一阶段发生了错误，未来将无法逆转 e.g. 视觉发展 Sensitive Period [Optimal] for a particular kind of development 某一特殊发展的最理想时期。如果某些行为无法在这一时期建立好，该行为的潜能就可能无法完全发展 在这一阶段发生的事情未来可以改变但是很难 e.g. 学习新语言 Capacities of newborn 新生儿的能力 Vision Some evidence of facial preference Hearing 灵敏并且表现出对母亲声音的偏好 Taste &amp; Smell 喜欢甜的 出生后不久，能够辨别口味和气味 Learning &amp; Memory - 具有学习能力，良好的记忆 Cognitive Development in Childhood 儿童期的认知发展 Piaget’s stage theory Schemas 图式 Theories about how the physical and social worlds operate 关于物质世界和社会世界如何运作的理论 assimilation 同化 Understand new information in terms of a pre-existing schema accommodation(顺应) Modify a new schema to fit new information The sensorimotor stage (0-2 years) 感知运动阶段 Recognize self as agent of action and begin to act intentionally 自我是行动的主体 Infant uses their senses and motor abilities to understand the world 用感官和运动能力来理解世界 e.g. 婴儿把什么都往嘴巴里面塞 object permanence(客体永久性) 意识到物体在不可见时仍然存在 Preoperational stage (2-7 years) 前运算阶段 学会使用语言 用图像和文字表示物体 Egocentrism 自我中心思考（三山实验） Concrete operational stage (7-11 years) 具体运算阶段 逻辑性思考 掌握 守恒（conversation）并获得可逆性（reversibility）， number (age 6) mass (age 7) weight (age 9) Formal operational stage (11+ years) 抽象运算阶段 对抽象事物的思考 系统性验证假设 例如在能采用控制变量法来验证猜想 对 Piaget’s theory 的批判 Critique 低估儿童能力：实验证明了儿童可以更早的拥有客体永久性概念及数字守恒概念 更多影响 具体运算操作 的因素，如文化环境/学校教育等 Alternatives to Piaget’s theory Information-processing approaches Knowledge-acquistion approaches Sociocultural approaches(Vygotsky) Theory of mind心理理论 理解他人有思考 元认知metacognition - 对思维的思考 Flavell的研究：学前儿童尚未有心理理论，即认为别人拥有与它们不同或与现实相异的信念 自闭症（autism）的儿童缺乏心理理论 The development of moral judgement道德判断的发展 Piaget : 儿童整体的认知发展层次决定他们的道德判断 Kohlberg : 将皮亚杰的道德推理研究拓展至青春期和成人期 三个层级： Level 1. Preconventional morality前习俗水平 Stage 1. Punishment orientation 避免惩罚 Stage 2. Reward orientation 得到回报 Level 2. Conventional morality习俗水平 Stage 3. Good-boy/good-girl orientation 避免他人反对 Stage 4. Authority orientation 权威导向 Level 3. Postconventional morality后习俗水平 Stage 5. Social-contract orientation 社会契约导向 Stage 6. Ethical principle orientation 道德原则导向 Personality and Social Development人格和社会发展 Temperament气质 - 与情绪有关的人格特征 容易型，困难型，迟缓型 遗传基因与环境间的交互作用，造就一位儿童的气质 Early social behavior早期社会行为 smile stranger anxiety 记忆 自主性 Attachment依恋 Harlow’s monkey experiment – 母亲和婴儿间的依恋不只是出于哺育的需要 Strange situation : 评估依恋 Types Securely attached 安全依恋 Insecurely attached: avoidant 不安全依恋：逃避 Insecurely attached: ambivalent 不安全依恋：矛盾 Disorganized 混乱型依恋 Parenting styles 父母反应方式 caregiver’s sensitive responsiveness to baby’s needs produces secure attachment attachment patterns reflect interaction between baby’s temperament and parents’ responsiveness Later development Self-concept Self-esteem Adolescent Development Sexual development 性发展 Puberty 青春期 Menarche 初潮 Psychological effects of puberty 青春期的心理效应 Identity development 自我认同发展 Erickson’s theory of identity development 青春期的重要任务： developing sense of identity Identity crisis 同一性危机：Erickson用来描述青年主动界定自我特性的历程 Identity confusion 同一性混淆：同一性危机处理失败的结果 Identity Statuses 同一性状态 (James Marcia) Identity achivement 同一性获得 Foreclosure 过早自认 Moratorium 同一性延缓 Identity diffusion 同一性扩散 Erikson’s 8 stages of development","link":"/psy2043-ch03-lecture-notes/"},{"title":"PSY2043 Ch06 Lecture Notes","text":"PSY2043 Introduction to Psychology Ch06 Consciousness Intended Learning Outcomes Define consciousness in terms of its function in monitoring information and controlling our actions. Know what is meant by the terms preconscious memories and the unconscious. Be familiar with the phenomena of automaticity and of dissociation. Discuss in some detail sleep schedules, stages of sleep, REM and NREM sleep, and sleep disorders. Describe Freud’s perspective on the purpose of dreams. Define meditation and describe the consequences of meditation training. Know what is meant by the term psychoactive drug. Aspects of Consciousness 意识的不同层面Consciousness 意识 Two definitions of consciousness 监控 Monitoring ourselves and our environment 控制 Controlling ourselves and our environment Altered state of consciousness 意识状态的改变 心理功能模式改变，如睡觉、做梦、受伤 Measuring EEG 脑波 Beta Alpha Theta Delta Preconscious memories 前意识记忆 可被提取而呈现在意识中的记忆 Unconscious 某些引发痛苦情绪的记忆和欲望会被 压抑（repressed），并转入无意识 即使我们未察觉到，也能影响我们 弗洛伊德式失语 Freudian slip Automaticity and dissociation 自动化与分离 Automaticity 自动化 一开始需要意识关注而最终反应习惯化的过程 e.g. 开车 弹钢琴 Dissociation 分离 人的思想和行为会与意识的其他部分分裂分离且个人无法知觉此功能 e.g. 无聊时候的做白日梦，分离性身份障碍 (dissociative identity disorder) Sleep and Dreams 睡眠与梦睡眠的阶段 睡眠阶段的链接 Awake - Alpha REM NREM Stage 1 - light sleep Stage 2 - light sleep have spindle Stage 3 - deep sleep Stage 4 - deep sleep REM 和 NREM 的比较 REM 大脑活跃身体麻痹，梦境真实 生动 情绪性 不合逻辑 NREM 身体非常放松，梦境比较像正常思考 睡眠的理论 Dale Edgar and William Dement : opponent-process model 睡眠与清醒对立过程模式 恒定睡眠驱力 时钟–依赖警觉过程 睡眠失常 Deprivation 睡眠剥夺 Insomnia 失眠 Narcolepsy 嗜睡症 Apnea 睡眠呼吸暂停 梦 Dreaming : altered state of consciousness 每个人都做梦，有些人觉得自己不做梦只是因为自己想不起来了 梦的持续时间和现实中差不多 人们有时能知道自己在做梦 人们有时候能控制自己的梦 Lucid dreamers 梦的理论 弗洛伊德 梦是一种企图欲望实现的伪装 其他理论 see dreaming as insights into the information processing the brain is doing while asleep 一些理论认为，做梦是一种认知过程 Continuity theory : dreaming is an imaginative process that reflects individual’s conceptions, concerns &amp; emotional preoccupations Meditation 冥想 通过有计划的仪式或运动，来 altered state of consciousness 两种常见技术 开放式冥想 opening-up meditation 集中式冥想 concentrative meditation 冥想的结果是，个体极端放松并觉得与外在世界分离的一种略神秘的状态 Hypnosis 催眠Induction of hypnosis 催眠的诱导 Changes Planfulness ceases attention become more selective enriched fantasy easily evoked reality testing reduces suggesstibility increased posthypnotic amnesia often present (forgot what happen) Hyponotic suggestions 催眠暗示 Control of movement 动作控制 Posthypnotic amnesia 催眠后遗忘 Positive and negative hallucinationscinations 正幻觉及负幻觉 Hidden observer 隐藏的观察者Psychoactive Drugs 精神药物 Drugs are used to alter consciousness and mood Repeated use can lead to drug dependence药物依赖 Tolerance抗药性: same effect need more Withdrawal戒断: if stop, unpleasant Compulsive use强迫用药 : self-control is difficult Drug Abuse 药物滥用：一个未产生药物依赖的人，持续的用药 Depressants 抑制剂 Depress central nervous system 镇静剂 tranquilizers, 巴比妥酸盐 barbiturates（安眠药sleeping pills），吸入剂 inhalants，普通酒精 ethyl alcohol 酒精及其影响：头昏眼花，松弛，不再自制 酒精的使用 cause accidents and fetal alcohol syndrome Illicit drugs 非法药物 大麻属 Cannabis Opiates 阿片 鸦片及其衍生物，总称为阿片 Reduce pain perception, induce euphoria, and depress central nervous system Heroin usage Opioid receptors Stimulants Amphetamines Cocaine Ecstasy PSI Phenomena 超觉现象Experimental evidence 实验证据The debate over the evidence 对证据的辩论","link":"/psy2043-ch06-lecture-notes/"},{"title":"PSY2043 Ch05 Lecture Notes","text":"PSY2043 Introduction to Psychology Ch05 Perception Intended Learning Outcomes Describe the role, benefits, and costs of selective attention in perception. benefits – selective attention pares down the amount of necessary information processing to the point where it is manageable by the brain costs – ignoring large parts of the environment, we lose the ability to remember much about those parts of the environment Understand the principles of object separation, distance perception, and motion perception. Object separation Figure and ground 图形和背景 Grouping of objects 物体的分组 邻近性（grouping by proximity） 相似性（similarity） 连续（good continuation） 闭合（closure） Distance perception Binocular cues 双眼线索 Binocular disparity 双眼像差：双眼所得视像间的差异 当物体离我们近时像差最大，距离越远像差越小 Monocular cues 单眼线索 相对大小 重叠 相对高度 透视 阴影 Motion perception Stroboscopic motion 频闪运动 Real motion Selective adaptation (motion aftereffect) Explain how object features are bound together and the involvement of pre-attentive and attentive processes. Feature integration theory 特征整合论 在前注意阶段，基本的特征（primitive features），被知觉到 在注意阶段，using attentions to “glue” features together 特征整合论的问题：研究发现太多的 ”primitives“ （原始特征）并不现实 替代理论 - 动态控制论（dynamic control theory） system rearranges itself for different tasks Learn what the difference is between bottom-up and top-down processing. Bottom-up processes – driven solely by the input Top-down processes – driven by person’s knowledge, experience, attention and expectations Learn why abstraction is important. Abstracted information takes less space and is therefore faster to work with than raw information. Explain how the perceptual system achieves and maintains constancy, and how this can cause illusions. illusions – the perceptual system’s insistence on maintainingconstancies. Briefly describe the neural underpinnings of attention, recognition, and localization. Three separate brain systems The first system is generally associated with arousal. The second, or posterior system, selects objects on the basis of location, shape, or color. The third, or anterior system is responsible for guiding this process, depending on the goals of the viewer. The visual cortex operates according to the principle of division of labor. Localization is mediated by a region near the top of the cortex, and recognition by a region near the bottom of the cortex. Recognition processes are further subdivided into separate modules such as color, shape, and texture. Recognition and localization are carried out by two different regions of the visual cortex. What is the use of perception?Processing and using incoming sensory informationFive functions of perception 1）注意 2）定位 3）辨识 4）抽象 5）恒常性 Attention 注意Selective attention 选择性注意 调整身体的感觉感受器以关照那些感兴趣的物体 Eye movements 眼球运动 视觉扫描采取一种注视的形式，被眼跳动区隔开 注视（eye fixations）：一种眼睛保持短暂静止的状态 眼跳动（saccades）：眼睛从某处快速跳动到另一处的状态 Weapon focus 武器聚焦 Ditected attention without eye movements 不涉及眼动的直接注意 Auditory attention 听觉的注意 选择性注意 Attention, perception, and memory 注意，知觉与记忆 我们对未曾注意的信息将无法察觉，即使有意识，所能记得的也不多 Costs and benefits of selectively attending to stimuliLocalization 定位Separation of objects 物体的分离 Figure and ground 图形和背景 Grouping of objects 物体的分组 邻近性（grouping by proximity） 相似性（similarity） 连续（good continuation） 闭合（closure） Perceiving distance 深度知觉 Binocular cues 双眼线索 Binocular disparity 双眼像差：双眼所得视像间的差异 当物体离我们近时像差最大，距离越远像差越小 Monocular cues 单眼线索 相对大小 重叠 相对高度 透视 阴影 Perceiving motion 运动知觉 Stroboscopic motion 动景运动 Recognition 辨识Global-to-local processing Global processing (what the scene is) Local processing (using knowledge about scene to identify object) The binding problem: pre-attentive &amp; attentive processes 整合的问题：前注意与注意过程 Feature integration theory 特征整合论 在前注意阶段，基本的特征（primitive features），被知觉到 在注意阶段，using attentions to “glue” features together 特征整合论的问题：研究发现太多的 ”primitives“ （原始特征）并不现实 替代理论 - 动态控制论（dynamic control theory） system rearranges itself for different tasks Determining waht an object is 决定物体为何 Shape形状 扮演了重要的角色 Visual processing 视觉处理过程 早期阶段，使用 retina视网膜 上的信息，来描述物体 后期阶段，与视觉记忆中的物体形状比对，并选出最佳配对 Simple cells Complex cells Hypercomplex cells Relations among features Later stages of recognition: network models 辨识的后期阶段：网络模式 Simple networks简单网络 Connectionist models 连接者模式：字母是以某些特征来描述的，而符合知识的特征被包含于一连结的网络中 兴奋型连结（excitatory connections) 为了弥补 Connectionist models 的不足，引入 augmented network（扩大的网络） 抑制性连结（inhibitory connections） Network with feedback反馈网络 Recognising natural objects &amp; top-down processing Features of natural objects The importance of context Bottom-up processes – driven solely by the input Top-down processes – driven by person’s knowledge, experience, attention and expectations 背景合适时，加强知觉；背景不合适时，损害知觉 Special processing of socially relevant stimuli: face recognition Development of special face recognition processes Three sources of evidence 面部辨识困难症 Prosopagnosia 大脑某部分损伤引起的脸盲 面孔倒置效应 Inversion effect 很难辨认倒置的人脸 Failure of recognitionAbstraction 抽象Exact to abstractThe advantages of abstraction: required storage and processing speed 节省储存空间，加快处理速度 Perceptual Constancies 知觉恒常性 即使物体因为其他原因 “感觉” 起来不一样了，我们仍能感知出事物的 实质 reality Color and brightness constancy 颜色和明度恒常性 Shape constancy 形状恒常性 Size constancy 大小恒常性 Dependence on depth cues 深度线索的依恃关系 size-distance invariance principle 大小-距离不变原则 物体被知觉到的大小会依物体在视网膜上成像的大小和被知觉到的距离而增加 Constancies in all sensory modalities 所有感觉都存在恒常性，视觉最突出 Illusions 错觉 恒常性与错觉 Divisions of Labor in the Brain 脑部中的分工 注意的神经基础 三种注意系统 One keeps us alert Posterior system 前部系统: Anterior system 后部系统: controls when and how these features will be used for selection Anterior guides posterior, anterior systems is called CEO. The visual cortex 视皮层 Recognition vs Localization systems 辨识与定位系统 Perceptual Development 知觉的发展Discrimination by infants 婴儿的识别能力 研究婴儿的方法 视觉偏好法 习惯法：测量婴儿是否能分辨两种物理刺激 形状的知觉 深度的知觉 The Visual Cliff 实验 3个月开始出现，6个月完全建立 知觉的恒常性 Controlled stimulation 在控制刺激环境下养育 缺乏刺激 在黑暗中养育的黑猩猩会缺失知觉能力，并且视神经衰退 天生的视觉能力发展有 Critical Period 限制刺激 在只有水平或垂直线条的房间中养育的小猫，会对另外一个方向刺激毫无反应，视皮层细胞退化 某些类别的刺激对天生知觉能力的维持及发展甚为重要 主动知觉 小猫旋转木马实验 学习在知觉与运动反应的协调中扮演一个主要的角色","link":"/psy2043-ch05-lecture-notes/"},{"title":"PSY2043 Ch15 Lecture Notes","text":"PSY2043 Introduction to Psychology Ch15 Psychological Disorders Intended Learning Outcomes Know the four criteria that may be used in defining abnormality as well as the characteristics that are considered indicative of normality. Abnormality Deviation from cultural norms 偏离文化规范 Deviation from statistical norms 偏离统计常模 Maladaptive behavior 行为的适应性（对个人或社会产生不利影响） Personal distress 个人痛苦 Nomality Appropriate perception of reality 对现实的正确知觉 Ability to exercise voluntary control over behavior 自主控制行为 Self-esteem and acceptance 自尊及自我接纳 Ability to form affectionate relationships 形成亲密关系的能力 Productivity 具有生产力 Understand the advantages and disadvantages of classifying abnormal behavior into categories. Advantages Aids diagnosis &amp; treatment Enables quick and concise communication Disadvantages Labeling induces us to overlook unique features of person and expect person to conform to classification doesn’t tell us how the symptoms originated or what causes them to continue stigma in many societies Know the broad perspectives of the biological, psychoanalytic, behavior, cognitive, and sociocultural models. Biological – brain disorders Psychoanalytic – unconscious conflicts Behavior – conditioning and reinforcement &amp; learned fear &amp; learned maladaptive behavior Cognitive – maladaptive cognitive process Sociocultural models – social context Vulnerability-stress model – the interaction between a predisposition that make a person vulnerable to a particular health problem and stressful environmental Describe four types of anxiety disorders. Understand the development of anxiety disorders from the standpoint of biological, cognitive, behavioral, and psychodynamic theories. Know what research on biological factors has contributed thus far to our understanding of these disorders. Anxiety disorders Generalized anxiety (constant worry and tension) Panic disorders (sudden attacks of overwhelming apprehension) Phobias (irrational fears of specific objects or situations) Obsessive-compulsive disorder Describe the two major mood disorders and to compare cognitive-behavior, psychoanalytic, and interpersonal theories of depression. Mood disorders Depressive disorder Bipolar disorder Cognitive theories attribute depression to pessimistic views of the self, the world, and the future and to maladaptive attributional styles. Psychodynamic theories view depression as a reactivation of loss of parental affection in a person who is dependent on external approval and tends to turn anger inward. Interpersonal theories view depression as the result of insecurities about relationships and maladaptive patterns of social interaction. Know the defining characteristics of schizophrenia and be able to give examples of each characteristic. Disturbances of thought and attention loosening of associations – word salad delusion Disturbances of perception hallucinations Disturbances of emotional expression express emotions that are inappropriately linked to the situation or to the thought being expressed, such as smiling while speaking of tragic events. Be familiar with the research on the causes of schizophrenia; be able to discuss the probable contributions of genetic, biochemical, and psychological factors. Genetic – Schizophrenia clearly is transmitted genetically Biochemical – have problems in dopamine regulation Psychological – Psychosocial factors play important role in overall severity &amp; triggering of new episodes Define personality disorders; know the defining characteristics and probable causes of antisocial personalities and borderline personality disorder. Definition – long-standing patterns of maladaptive behavior involving difficulties in coping with stress or solving problems ASPD Biological factors Genetic factors play a role in development of antisocial personality – twin studies confirm genetic component Deficits in executive functions could lead to poor impulse control &amp; difficulty in anticipating consequences Social factors Neglectful &amp; hostile parents may contribute to disorder Personality factors Children with antisocial personalities process information about social interactions in ways that promote aggressive reactions BPD Psychoanalytic theorists argue poorly developed views of self &amp; others stem from poor early relationships with caregivers Others argue deficit in ability to regulate emotions Understand the patterns of behavior that constitute autism spectrum disorders. Describe the biological causes of autism spectrum disorders. Diagnose – three types of deficits Social interaction – lack of connection with others Communication – difficulties in communication &amp; speech Activities &amp; interests – preoccupation/routines/rituals Biological causes Genetics Neurological factors – disruption in normal development &amp; organization of the brain DEFINING ABNORMALITY 变态的定义Deviation from cultural norms 偏离文化规范Deviation from statistical norms 偏离统计常模Maladaptive behavior 适应不良的行为（对个人或社会产生不利影响）Personal distress 个人痛苦 Individual’s subjective feelings of distress e.g. anxiety, depression, or agitation 烦躁, or insomnia 失眠, loss of appetite or numerous pains and aches Maybe the only symptom to determin disorder What is normality? 对现实的有效知觉 自主控制行为的能力 自尊及接纳 形成亲密关系的能力 具有生产力 Classifying mental health problems Advantages Aids diagnosis &amp; treatment Enables quick and concise communication Disadvantages Labeling induces us to overlook unique features of person and expect person to conform to classification doesn’t tell us how the symptoms originated or what causes them to continue stigma in many societies Perspectives on mental health problems Biological perspectives – due to brain disorders Psychological perspective – issues in mind functioning Psychoanalytic perspective – unconscious conflicts &amp; defense mechanisms Behavioral perspective – fears become conditioned Cognitive perspective – maladaptive cognitive processes Cultural/sociological perspective – social context Vulnerability-stress model Interaction between a predisposition, which makes a person vulnerable for developing a particular mental health problem, and stressful environmental conditions encountered by that person 易受性+压力 ANXIETY DISORDERS 焦虑障碍 Anxiety 4 types of symptoms Physiological 生理 – 心跳加速、肌肉紧绷、冒汗、呼吸急促 Cognitve 认知 – 确信自己要遭重了 Behavioral 行为 – 僵住、动弹不得 Emotional 情绪 – 害怕与恐惧感 Generalised anxiety disorder 广泛性焦虑障碍（经常性的担心和紧张） Person experience constant 持续 sense of tension &amp; dread Panic disorders 惊恐障碍（突然爆发强烈的焦虑） Panic attack 惊恐发作 : episode of acute &amp; overwhleming terror Panic disorder: diagnosed if panic attacks become frequent &amp; individual worries about having one Agoraphobia 广场恐惧症 害怕被困在不安全的地方 Understanding panic disorder and agoraphobia 遗传或其他生物上的【易受性】 易患有 panic disorder 的个体可能遗传有“战斗或逃跑过度反应”这种特质 边缘系统受损、神经递质5-HT不足 认知–行为论 【压力】 倾向于只关注自己的身体，并将身体的感觉进行消极的解释和以灾难性方式 清楚地记得发病场所 – 导致广场恐惧症 易受性–压力模式将上述两个理论整合 Phobias 恐怖症（对特定目标或情景有非理性的害怕） 对大多数人并不认为特别危险的刺激/情境产生强烈恐惧，这种恐惧干扰了个人生活 通常了解自己是非理性的，但依然会感到焦虑 3 broad categories Agoraphobia Specific/simple phobia: fear of simple object/animal/situation Social phobia (social anxiety disorder): 社恐 最常见的有害怕公众场合讲话或者吃东西 通常开始于青少年，如果不加以治疗，往往会成为长期病 Understanding phobias Behaviorists: develop from classical &amp; operant conditioning 中性刺激与创伤事件配对，引发焦虑 e.g. 水和溺水 回避恐惧对象，减轻焦虑 Freud: 行为主义的治疗往往比较成功，精神分析的治疗往往比较失败 Obsessive-compulsive disorder 强迫症 OCD Lives dominated by repetitive acts (compulsions) or thoughts (obsessions) Obsessions: 持续出现的 unwelcome thoughts Compulsions: 无法抗拒地做出 certain acts 来减轻焦虑 Understading obsessive-compulsive disorder Cognitivists &amp; behavioralists : 更难 “关闭 “侵入性想法，因为他们倾向于僵化的、道德主义的思维方式 Gene &amp; Possible dysfunctional neural circuit 基因与可能的功能失调神经回路 许多焦虑症可能是生物和心理因素共同作用的结果。 许多焦虑症患者可能都有遗传、神经或生化方面的易焦虑性。 MOOD DISORDERS 心境障碍Depressive disorder 抑郁障碍：会有一段时间的悲伤、抑郁或平淡情绪； 轻微的抑郁症状是对生活压力的正常反应 当影响正常生活工作的时候，并持续长达数周的时候，抑郁成为一种疾病 Prevalence 各国家之间的抑郁症发病率差异很大，从 6% 到 20% 女性的发病率高于男性 Symptoms Emotional symptoms sadness loss of pleasure Cognitive symptoms Negative views of self Hopelessness Poor concentration and memory; confusion Motivational symptoms Passivity Will not initiate or persist at activities Physicla symptoms Changes in appetite and sleep Fatigue 疲惫 Increase in aches and pains 疼痛增加 Bipolar disorder 双相障碍：抑郁期和躁狂期（情绪高涨或激动）之间交替出现，通常在两个极端之间情绪会恢复正常 以前叫 manic depreesion 躁狂抑郁症 相对不常见，占成年人 2% 或更少 Manic symptoms often change from joyful exuberance to hostile agitation 欢欣鼓舞到敌意激昂 Understanding mood disorders Biological perspective tendency inherited 通常是遗传性的 归因于：遗传和在调节5-羟色胺与正肾上腺素方面的问题 大脑结构和功能异常可能是情绪障碍的前兆和原因，也可能是情绪障碍中对大脑的不良结果 Cognitive perspective negative thoughts about the self &amp; present &amp; future 对自我、未来、世界的悲观看法 Maladaptive attributional styles 适应不良归因风格 心理分析观点 依赖外在赞许而且将怒气转向内部的个体，因为丧失亲情的反应重被激起而造成的 Interpersonal perspective too dependent on opinions &amp; support of others Psychosocial factors in bipolar disorders 双相的社会心理因素 stressful life events Beck’s theory Beck: the father of Cognitive Behavior Therapy 5 principle errors SCHIZOPHRENIA 精神分裂症 通常出现于 late adolescence 或 early adulthood, just when an individual is beginning career and starting a family Characteristics of schizophrenia Disturbance of thought and attention Loosening of association 连结松散 – word salad Disturbance of perception Hallucinations Disturbance of emotional expression Motor symptoms and withdrawal from reality exhibit bizarre motor activity 表现出怪异的运动活动 Culture and the progression of schizophreniaUnderstanding schizophrenia Biological perspective 精分可能于生物有密切联系 两种类型的大脑结构缺陷 prefrontal cortex smaller &amp; less active 前额叶皮质缩小且不活跃 enlarged ventricles 脑室扩大 regulation of dopamine 也有问题 The social &amp; psychological perspective Psychosocial factors play important role in overall severity &amp; triggering of new episodes PERSONALITY DISORDERS 人格障碍 Long-standing patterns of maladaptive behavior 长期的适应不良的行为模式 Antisocial personality disorderUnderstanding antisocial personality disorderBoderline personality disorderUnderstanding borderline personality disorderPERVASIVE DEVELOPMENTAL DISORDERS (PDD) No Cure Diagnosis of autism 3 types of deficits Social interaction Communication Activities &amp; interests Asperger’s syndrome and other pervasive develepmental disordersUnerstanding pervasive developmental disorders","link":"/psy2043-ch15-lecture-notes/"},{"title":"PSY2043 Ch07 Lecture Notes","text":"PSY2043 Introduction to Psychology Ch07 Learning and Conditioning Intended Learning Outcomes Understand the history of the study of animal and human learning. Know the different types of conditioning and the way in which they are studied. Understand the brain physiology underlying learning processes. Know the topics of cognition and motivation, as they interact with learning. Identify different types of learning such as: classical versus instrumental conditioning, and observational learning. Explain the empirical paradigms used to study learning processes. Identify situations in which cognitions and/or motivations affect learning. PERSPECTIVES on LEARNING 学习的各种观点 Learning is a relatively permanent change in behavior that is the result of experience 因经验而造成行为相对持久性的改变 Four basic kinds of learning (1) habituation and sensitization (2) classical conditioning (3) instrumental conditioning (4) complex learning 行为主义观点、认知观点、生物观点 Classical Conditioning 经典性条件反射Pavlov’s experiments (1) US to UR (2) CS&amp;US to UR (3) CS to UR Drug tolerance 耐药性 classical conditioning contributes to drug tolerance situational specificity of drug tolerance 药物耐受的情境特异性 Acquisition 习得 define (CS, US) as reinforced trial repeated (CS, US), and CR increase the left panel of the figure(learning curve), called acquistion stage of the experiment 食物同时摇铃，流口水越来越多 Extincition 消退 US omitted, CR diminish Extinction: learning that CS no longer predicts the US 不给食物，只摇铃，慢慢就不流口水了 Spontaneous recovery 自然恢复 if participant allowed to rest and then presents only CS again, CR reappears effect of REST 休息一会后，只摇铃，又会流口水 说明在消退以后，即使不流口水了，习得的东西也没有被忘记 Stimulus generalization 刺激泛化 对相似的刺激产生类似的反应 e.g. 巴甫洛夫的狗听到摇铃铛会流口水，用类似的但不一样的声音刺激，也会流口水 Stimulus discrimination 刺激辨别 如果持续强化刺激，狗最后可能只会对铃铛声音流口水，也就是说能分辨不同刺激 Second-order conditioning 二阶条件反射 e.g. light, meat -&gt; tone, light, meat Conditioning and fear e.g. light, electrical shock, pain -&gt; light, pain Cognitive factors 认知因素 Pavlov &amp; others believed conditioning occurs if CS &amp; US were temporally contiguous a predictive (or reliable) relationship between CS &amp; US more important than temporal contiguity or frequency of pairings (Rescorla, 1972). Biological constraints 生物性限制 animals are “pre-programmed” to learn particular things in particular ways (evolution &amp; gene) 在 classcal conditioning 中，刺激能否被联结受限于生物 Learned taste aversion 习得性味觉厌恶 对某种食物的不良体验会让人对该食物产生厌恶，这不符合经典条件反射 因为有一次体验就会产生厌恶，并没有重复配对而且 CS-US 间隔通常很长 INSTRUMENTAL CONDITIONING / OPERATIONAL CONDITIONING Thorndike’s experiment : law of effect 如果能立即获得奖励的话，行为会被强化 Skinner’s experiments Baseline: the inital rate of pressing Acquisition &amp; extinction: depends on food Bad Good Giving Positive Punishment (behavior -) Positive Reinforcement (behavior +) Taking Away Negative Reinforcement (behavior +) Negative Punishment (behavior -) Shaping：全新的行为 Conditioned/secondary reinforcer：几乎都是二阶反射 Generalization and discrimination Schedules of reinforcement Ratio schedules Fixed ratio schedules (FR) Variable ratio schedules (VR) Interval schedules Aversive conditioning厌恶性条件反射：反应后立即受到负面事件，导致反应减弱 Escape Learning 逃离学习：a response terminates aversive event leave toilet Avoidance Learning 回避学习：a response is learned to prevent aversive event close the door of the toilet Cognitive factors Temporal contiguity is an important factor for it to occur Control: instrumental response is conditioned only when an organism interprets reinforcement as being controlled by its response Contingency Biological constraintsLEARNING AND COGNITIONObservational learning 观察学习 Human often learn without behavior being reinforced immediately through imitation &amp; observational learning – copying behavior of others you deem successful Prior beliefsLEARNING AND THE BRAINHabituation and sensitizationClassical conditioningCellular basis of learningLEARNING AND MOTIVATIONArousalFrom incentives to goalsIntrinsic motivation and learning","link":"/psy2043-ch07-lecture-notes/"},{"title":"PSY2043 Ch16 Lecture Notes","text":"PSY2043 Introduction to Psychology Ch16 Treatment of Mental Health Problems Intended Learning Outcomes Be familiar with the historical background and current trends in the treatment of abnormal behavior, in particular deinstitutionalization and reinstitutionalization. Deinstitutionalization 1960s movement of patients from hospitals to community-based servicesx Be able to describe the following approaches to psychotherapy, including the therapist’s techniques and the patient’s or client’s experiences that are presumed to yield improvement: Psychoanalysis and psychodynamic therapies; Behavior therapies; Cognitive-behavior therapies; Humanistic therapies; Family and marital therapies. Psychoanalysis and psychodynamic therapies Techniques: free association, dream analysis, transference. Behavior therapies Learning &amp; conditioning Systematic desensitization In vivo exposure Selective reinforcement Modelling Behavioral rehearsal Self-regulation Cognitive-behavior therapies Humanistic therapies Client-centred therapy Family and marital therapies Be familiar with the techniques, advantages, and disadvantages of the two forms of biological therapy; be able to describe the major classes of psychotherapeutic drugs, their effects, and their applications to mental disorders. Electroconvulsive therapy Advantage – Subject of controversy but effective in bringing some out of severe depression faster than drug therapy Disadvantage – Can cause permanent memory loss and confusion Drug therapy Antipsychotic drugs – alter levels of the dopamine – schizophrenia Antidepressant drugs – affecting levels of the neurotransmitters serotonin and norepinephrine – Lithium – Regulates levels of serotonin, norepinephrine, and other neurotransmitters – bipolar disorders Antianxiety drugs – Depresses central nervous system Stimulants – Increasing levels of dopamine Be familiar with the suggestions offered for promoting your own emotional well-being. Accept your feelings Know your vulnerabilities Develop your talents and interests Become involved with other people Know when to seek help HISTORICAL BACKGROUND Earliest belief – demon-possessed 鬼附身 古中国：阴阳失衡 Hippocrates：disturbance in body fluids 体液紊乱 Middle ages：demon-possessed Early asylums 1792 Philippe Pinel Morden treatment facilitiesProfessionals who provide psychotherapyTECHNIQUES OF PSYCHOTHERAPYBehavior therapies 行为疗法 以学习及条件作用原则为基础所发展的治疗方法 Systematic desensitization 系统脱敏法 In vivo exposure 实景暴露法 Flooding Selective reinforcement Modeling 模仿 观察一位治疗师握着一只蛇，可以减轻惧蛇者对蛇的恐惧 Behavioral rehearsal 行为演练 治疗师帮助患者预演或练习更适当的行为 Self-regulation Cognitive-behavior therapies 认知行为疗法Treatment methods that use behavior modification techniques but also incorporate procedures designed to change maladaptive beliefs. Psychodynamic therapies 心理动力学疗法 Traditional psychoanalysis Through free association, dream analysis, and transference, attempts to discover the unconscious basis of the client’s current problems so as to deal with them in a more rational way. Contemporary psychodynamic therapies (e.g., interpersonal therapy) More structured and short-term than traditional psychoanalysis; emphasize the way the client is currently interacting with others. Humanistic therapies 人本主义疗法e.g., client-centered therapy Sociocultural approaches to therapySpecial issues in treating childrenThe effectiveness of psychotherapyCommon factors in psychotherapiesBIOLOGICAL THERAPIESPsychotherapeutic drugs Anti-anxiety drugs Purpose: reduce symptoms of tension 作用方式: depresses central nervous system抑制中枢神经系统 Stimulants Electroconvulsive therapyCombining biological and psychological therapiesENHANCING MENTAL HEALTH","link":"/psy2043-ch16-lecture-notes/"},{"title":"PSY2043 Ch17 Lecture Notes","text":"PSY2043 Introduction to Psychology Ch17 Social Influence Intended Learning Outcomes Explore how the presence of others influences people’s behavior. Deindividuation Bystander effects Social facilitation &amp; inhibition Cover how deindividuation and bystanders influence social behavior. Deindividuation enhancing group identity promotes conformity to situation-specific social norms Bystander effects – people are less likely to help if others are present Pluralistic ignorance – everybody in group misleads everybody else by defining situation as non-emergency Diffusion of responsibility – Presence of others, even imagined others, diffuses responsibility so no one person feels need to act Be introduced to classic experiments on compliance and obedience. Asch’s experiment – unanimous agreement among a group exerts strong pressures on individual to conform, even when judgements clearly wrong Milgram’s classical experiment Learn how the classic Zimbardo Prison Experiment illustrates the power of situations and institutional norms. Institutions have norms that strongly govern the behavior of people who occupy critical roles within the institution. An example of how institutional norms shape group interactions is provided by the Stanford Prison Experiment, in which ordinary young men were randomly assigned roles of ‘prisoner’ and ‘guard’ in a simulated prison. Define the fundamental attribution error and provide an example. Fundamental attribution error – tendency to explain other’s actions by overestimating personality influence but underestimating situational influence. e.g. Imagine you witness a colleague arriving late to an important meeting. Instead of considering external factors like traffic or a family emergency, you attribute their tardiness to a lack of punctuality or irresponsibility (internal, dispositional factors). In reality, the colleague might have faced unexpected traffic delays, highlighting the fundamental attribution error by focusing on the person’s traits rather than the situation. Explain when and why social facilitation vs. social inhibition occurs. Social facilitation – simple or well-learned tasks Social inhibition – complex or poorly learned tasks Why – the presence of others narrows people’s attention Describe how deindividuation can produce aggression. Creates increased sensitivity to situation-specific social norms linked with the group. Minimizes people’s personal identities Reduces sense of accountability Explain pluralistic ignorance and why it matters. everybody in group misleads everybody else by defining situation as non-emergency Discuss the differences between informational and normative social influence. Informational social conformity – we conform because we believe that other people’s interpretations of an ambiguous situation are more correct than our own. Normative social influence – we conform because we believe that other people’s interpretations of an ambiguous situation are more correct than our own. Explain the importance of Milgram’s experiments on obedience to authority. Showed that ordinary people would obey experimenter’s order to deliver strong electric shocks to innocent victim Discuss various explanations for why people change their attitudes to reflect their past behavior. Cognitive dissonance theory – when people’s behavior conflicts with their attitudes it creats an uncomfortable tension that motivates them to change their attitudes to be more in line with their actions. Rationalization, Self-justification Self-perception theory – stating that inner turmoil does not necessarily occur. To the extent that internal cues are weak, ambiguous, or uninterpretable, people may simply infer their attitudes from their past behavior. Explain group polarization and why it happens. Group polarization: The group decision is in the same direction but is more extreme than the average of the group members’ initial positions. This is not just public conformity; group members’ private attitudes typically shift in response to the group discussion as well. The group polarization effect is due in part to informational social influence, in which group members learn new information and hear novel arguments that are relevant to the decision under discussion. Group polarization is also produced by normative social influence, in which people compare their own initial views with the norms of the group. They may then adjust their position to conform to that of the majority. The Presence of OthersSocial facilitation and social inhibitionDeindividuationBystander effectsCompliance and ObedianceComformity to a MajorityMinority influenceObediance to AuthorityInternalizationSelf-justificationReference groups and idenitifacationGroup InteractionsInstitutional normsGroup decision makingRecap: Social Psychological Views of the Seemingly Inexplicable","link":"/psy2043-ch17-lecture-notes/"},{"title":"PSY2043 Ch04 Lecture Notes","text":"PSY2043 Introduction to Psychology Ch04 Sensory Process senses Include vision, hearing, smell, taste, and touch Sensatation vs Perception At psychological level 心理学层面 Sensatations are raw experiences of stimuli not yet imbued with meaning 原始刺激 Perception involves the integration and meaningful interpretation of these raw sensory experiences 解释信息 At biological level 生物学层面 Sensory processes involve the sense organs and the neural pathways that emanate from them Perceptual processes involve higher levels of the cortex Intended Learning Outcomes Explain how sensations are experienced on a psychological and a biological level. Psychological – raw experiences of stimuli not yet imbued with meaning Biological – sense organs and the neural pathways Describe the role of sensitivity, intensity, and magnitude of above threshold stimuli for the different sensory modalities. 史蒂文斯定律 Stevens’ law （幂函数定律） 知觉的心理强度（$\\Psi$）为物理强度（$\\Phi$）的指数函数 $\\Psi = \\Phi^{r}$ Understand that signals are present in background noise and that they may be missed when present (misses) and may be detected when not present (false alarms). Learn what signal transduction is and how it plays a role in the five senses. Every sensory modality must recode or transduce the physical energy engendered a stimulus into neural impulses. The nature of such coding, unique to each sensory modality, must encode both stimulus intensity, along with various qualitative characteristics of the stimulus Understand to what extent signal transduction in vision is similar to signal transduction in hearing, and understand how they are different. 两个系统，一个系统将声音放大并传送至感受器；另一个系统接收声音并转换为神经冲动 Explain how the different facets of the visual sensory system contribute to the two theories of color vision and to visual acuity Characteristics of Sensory Modalities Sensory system Acquiring information Transfusing it into neural representation in brain Threshold sensitivity 阈值灵敏度（敏感性） Absolute thresholds 绝对阈限: detecting minimum intensities 能确实与完全没有刺激有所区别的最低刺激强度 由 Psychophysical Procedures（心理物理程序）决定 Difference thresholds 差别阈限 区分两种刺激的最小差异 也被称为 “just noticeable dofference” (jnd, 最小可觉差) 韦伯定律 Weber’s law 高于某标准刺激的最小可觉差，是该标准刺激的固定百分比 $\\Delta I / I = k$ $\\Delta I$ 是 jnd，$I$ 是刺激强度，$k$ 是韦伯分数 Suprathreshold sensation 阈上感觉 刺激强度高于阈限 Psychophysical function the relation between stimulus intensity and the magnitude of sensation for above-threshold (‘suprathreshold’) stimuli. 史蒂文斯定律 Stevens’ law （幂函数定律） 知觉的心理强度（$\\Psi$）为物理强度（$\\Phi$）的指数函数 $\\Psi = \\Phi^{r}$ Signal detection theory Hits and false alarms Hits击中 - 正确识别信号 False alarms虚报 - 在只有噪音的情况下判断有信号 命中率和虚报率的高低差异决定了敏感性 Sensitivity and bias 敏感性与偏差 偏差，通常用$\\beta$表示 敏感性，通常用$d’$表示 Sensory coding 传导过程（transduction）：由感受器（receptor）将物理能转换成电信号，然后传导至脑部 Coding of intensity and quality 对刺激强度和刺激性质的编码 改变神经刺激速率和被刺激的神经元数量 the rate of neural firing and the number of neurons firing Intensity 强度 通过神经冲动的速率（the rate of neural impulses） Greater intensity = greater firing rate = greater perceived magnitude of stimulus 编码方式 时间模式（temporal pattern） 通过被激发的神经元数目来将刺激强度编码 Quality 性质 学界中大多同意，脑部对各感觉形式间的性质编码因各自涉及的特殊神经通路而有所不同 specific neural pathway (e.g. vision, hearing) 同一种感觉内分辨性质，例如味觉中酸甜苦辣的分辨： “特殊化”：每种味觉有其对应的特殊神经纤维 ”组型化“：使用激发的神经组型来对感觉性质进行编码 VisionLight and vision 光和视觉 每一种感觉都对特定形态的物理能量起反应 视觉所对应的物理刺激是光 The visual system 视觉系统 人类视觉系统包括眼睛，脑部以及连接它们的通路 The eyes, parts of the brain and pathways between 眼睛 Eyes 包括两个系统 Image formation system 成像系统 将物品反射出来的光线聚焦在视网膜（retina）上形成物体的影像 成像系统本身包含角膜（cornea），瞳孔（pupil）和晶状体（lens） 角膜（cornea）：使光线在成像之前产生弯曲 晶状体（lens）：看近处弯曲成球状，看远处则伸平开来。晶状体将光线聚焦在视网膜上 瞳孔（pupil）：光线微弱时瞳孔放大，光线强时缩小，确保足够的光线以维持成像的质量 Image transduction system 传导系统：将影像转换为电冲动 视网膜（Retina）内的感受器：杆体细胞（rods，夜晚事物）和锥体细胞（cones，白昼事物） 感受器将光线转换为电冲动的过程 感受器内部含有可以吸收光线的光色素（photopigments），光色素吸收光线产生神经冲动。随后神经冲动通过连结神经元传到脑部 rods and cones的反应首先传送到双极细胞（bipolar cells） 然后再从bipolar cells传送到其他称为节细胞（ganglion cells）的神经元 ganglion cells的长轴突从眼睛延伸出去，形成到达脑部的视觉神经（optic nerve Seeing Light 光线的视觉 Sensitivity 敏感性 人体对光线强度的敏感性由 rods and cones 决定，他们之间主要有三个区别 在不同光强下被激活：亮的地方激活锥体cones，暗的地方激活杆体rods 擅长不同任务：锥体cones更擅长高解析度，杆体rods更擅长高敏感度 在视网膜 retina 上的不同位置集聚：中央窝（The fovea）多锥体少杆体，边缘地带（The periphery）多杆体少锥体 Dark adaptation 暗适应 在黑暗中瞳孔放大，同时，感受器的光学变化也增加了感受器对光线的敏感性 暗适应的曲线，显示绝对阈限会随个人出于黑暗中的时间加长而降低。首先锥体细胞快速下降，随后（大约从10分钟开始）杆体细胞缓慢下降 Seeing patterns 形状视觉 视敏度（visual acuity）：眼睛解析细节的能力 一般通过 optician’s eye chart 测量 Seeing color 色觉 Color constancy 色彩恒常性（e.g. 白金还是蓝黑） Color appearance 色貌 看到颜色是主观的，颜色是大脑的构造 但也是客观的，因为任意两个观众对颜色的理解都是相似的 三个维度 hue 色调 brightness 明亮度 saturation 饱和度 孟赛尔体系 Munsell system Color mixture 颜色的混合 色彩配置实验（color matching experiment）证实，所有我们能分辨的色调都可以用三原色混合出来 Metamer（条件等色）：物理成分相当不同但看起来完全相同 Theories of color vision Trichromatic 三原色 Oppenent-color theory 拮抗理论（四原色说） Sensation and perception: a previewAuditionSound waves 声波 正弦波（sine wave） = 纯音（pure tones） Frequency 频率 Amplitude 强度 - 声波的振幅 Timbre 音色 The auditory system 听觉系统 Consists of the ears, parts of the brain and neural pathways between 和眼睛相似，两个系统，一个系统将声音放大并传送至感受器；另一个系统接收声音并转换为神经冲动 传送系统（transmission system） 外耳（outer ear） 耳廓（external ear / pinna） 耳道（auditory canal） 中耳（middile ear） 鼓膜（eardrum） 三块成列的听骨 锤骨（malleus） 砧骨（incus） 镫骨（stapes） 转换系统 Hearing sound intensity 对中频声音更敏感 More sensitive to sounds of intermediate frequency 耳朵之间有细微差距 Hearing pitch 听觉音高 取决于频率 很少听到纯音 但是听到几个纯音复合在一起的时候，仍能分别听到各个声音成分 在视觉上，可以将多种光线混合成同一种；但是听觉不行，说明听觉上少有专司不同频率的感受器，因此听觉的声音频率感受器更具连续性 音频知觉的理论 时间理论 Temporal theory (Rutherford, 1886) 声波引起基底膜振动，基底膜振动速率决定听觉神经中的神经纤维冲动速率 可以解释低频知觉 位置理论 Place theory 可以解释高频知觉 Other SensesOlfaction 嗅觉 The olfactory system 嗅觉系统 鼻腔中的感受器，脑部特定区域，以及神经通路 嗅觉感受器 Sensing intensity and quality 与其他动物相比，人类较不敏感，因为感受器数量较少 能分辨的种类比较多，感受器种类比较多样 Gustation The gustatory system Pressure and temperaturePain- the stimulus intense enough to cause tissue damage 足以造成组织受损 - 刺激影响皮肤中的化学物质释放，然后刺激不同的高阈限感受器 - 由两种不同的神经通路传递的两种疼痛 - Phasic pain 阶段性疼痛：短暂，快速升降 - Tonic pain 紧张性疼痛：较缓和迟钝，但长时间持续且稳定","link":"/psy2043-ch04-lecture-notes/"}],"tags":[{"name":"XCPC","slug":"XCPC","link":"/tags/XCPC/"},{"name":"UIC","slug":"UIC","link":"/tags/UIC/"},{"name":"Codeforces","slug":"Codeforces","link":"/tags/Codeforces/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Icarus","slug":"Icarus","link":"/tags/Icarus/"},{"name":"Deep Learning","slug":"Deep-Learning","link":"/tags/Deep-Learning/"},{"name":"CNN","slug":"CNN","link":"/tags/CNN/"},{"name":"沈阳","slug":"沈阳","link":"/tags/%E6%B2%88%E9%98%B3/"},{"name":"深圳","slug":"深圳","link":"/tags/%E6%B7%B1%E5%9C%B3/"},{"name":"蓝桥杯","slug":"蓝桥杯","link":"/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"},{"name":"初中时期","slug":"初中时期","link":"/tags/%E5%88%9D%E4%B8%AD%E6%97%B6%E6%9C%9F/"},{"name":"杭电多校","slug":"杭电多校","link":"/tags/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/"},{"name":"BNUZH","slug":"BNUZH","link":"/tags/BNUZH/"},{"name":"UIC-ACM","slug":"UIC-ACM","link":"/tags/UIC-ACM/"},{"name":"VP","slug":"VP","link":"/tags/VP/"},{"name":"澳门","slug":"澳门","link":"/tags/%E6%BE%B3%E9%97%A8/"},{"name":"哈尔滨","slug":"哈尔滨","link":"/tags/%E5%93%88%E5%B0%94%E6%BB%A8/"},{"name":"南京","slug":"南京","link":"/tags/%E5%8D%97%E4%BA%AC/"},{"name":"重庆","slug":"重庆","link":"/tags/%E9%87%8D%E5%BA%86/"},{"name":"ABC","slug":"ABC","link":"/tags/ABC/"},{"name":"AtCoder","slug":"AtCoder","link":"/tags/AtCoder/"},{"name":"武汉","slug":"武汉","link":"/tags/%E6%AD%A6%E6%B1%89/"},{"name":"APSY","slug":"APSY","link":"/tags/APSY/"},{"name":"PSY2013","slug":"PSY2013","link":"/tags/PSY2013/"},{"name":"PSY2033","slug":"PSY2033","link":"/tags/PSY2033/"},{"name":"PSY2043","slug":"PSY2043","link":"/tags/PSY2043/"}],"categories":[{"name":"Contest Notes","slug":"Contest-Notes","link":"/categories/Contest-Notes/"},{"name":"Tech Notes","slug":"Tech-Notes","link":"/categories/Tech-Notes/"},{"name":"Lecture Notes","slug":"Lecture-Notes","link":"/categories/Lecture-Notes/"},{"name":"OI Notes","slug":"OI-Notes","link":"/categories/OI-Notes/"},{"name":"Travel Notes","slug":"Travel-Notes","link":"/categories/Travel-Notes/"}],"pages":[{"title":"About","text":"Hi, I’m TosakaUCW. You can just call me Tosaka. QQ: 2736275924 email: tosakaucw0@gmail.com 洛谷: TosakaUCW 大号 TosakaUCVV 小号 Codeforces:","link":"/about/index.html"},{"title":"Links","text":"Here are some links. If you want to put your link here, email me through tosakaucw0@gmail.com or just leave a comment below. Hamakaze 太君 Joyemang33 Mangoyang, https://joyemang33.github.io/ Dilemma MZ 哥哥 DennyQi 学长 Isonan 神 Claris 师兄 DFSlover 可爱 JLB LZM 学长 Kananix 学长 REM_001 二号机 fAKe Zimba! 甘某人 郭沫若 Tosania 天下第一美少女，又强又可爱 CZY 圆坑骑士 markjuruo 马尔谷觉罗 Tony102 牢托","link":"/links/index.html"}]}